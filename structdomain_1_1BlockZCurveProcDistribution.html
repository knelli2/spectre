<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.1"/>
  <title>SpECTRE: domain::BlockZCurveProcDistribution&lt; Dim &gt; Struct Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.08.01</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structdomain_1_1BlockZCurveProcDistribution.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdomain_1_1BlockZCurveProcDistribution-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">domain::BlockZCurveProcDistribution&lt; Dim &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Distribution strategy for assigning elements to CPUs using a Morton ('Z-order') space-filling curve to determine placement within each block.  
 <a href="structdomain_1_1BlockZCurveProcDistribution.html#details">More...</a></p>

<p><code>#include &lt;ElementDistribution.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a505f2bb605cc74a973cbf23ba6c29484"><td class="memItemLeft" align="right" valign="top"><a id="a505f2bb605cc74a973cbf23ba6c29484"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1BlockZCurveProcDistribution.html#a505f2bb605cc74a973cbf23ba6c29484">BlockZCurveProcDistribution</a> (size_t number_of_procs_with_elements, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, Dim &gt;&gt; &amp;refinements_by_block, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; size_t &gt; &amp;global_procs_to_ignore={})</td></tr>
<tr class="memdesc:a505f2bb605cc74a973cbf23ba6c29484"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>number_of_procs_with_elements</code> argument represents how many procs will have elements. This is not necessarily equal to the total number of procs because some global procs may be ignored by the third argument <code>global_procs_to_ignore</code> <br /></td></tr>
<tr class="separator:a505f2bb605cc74a973cbf23ba6c29484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d2b7cb2d96a103a17a80673a726021"><td class="memItemLeft" align="right" valign="top"><a id="aa8d2b7cb2d96a103a17a80673a726021"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1BlockZCurveProcDistribution.html#aa8d2b7cb2d96a103a17a80673a726021">get_proc_for_element</a> (const <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &amp;element_id) const</td></tr>
<tr class="memdesc:aa8d2b7cb2d96a103a17a80673a726021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the suggested processor number for a particular element, determined by the greedy block assignment and Morton curve element assignment described in detail in the parent class documentation. <br /></td></tr>
<tr class="separator:aa8d2b7cb2d96a103a17a80673a726021"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;size_t Dim&gt;<br />
struct domain::BlockZCurveProcDistribution&lt; Dim &gt;</h3>

<p>Distribution strategy for assigning elements to CPUs using a Morton ('Z-order') space-filling curve to determine placement within each block. </p>
<h3>Details</h3>
<p>The element distribution assigns a balanced number of elements to each processor that is allowed to have elements (default all). Specify which processors aren't allowed to have elements by passing in an unordered set of <code>size_t</code>s corresponding to the processor number. This distribution is computed by first greedily assigning to each available processor an allowance of [total number of elements]/[number of processors available] elements from one or more blocks, starting with the lowest number block that still has elements to contribute to an allowance. Then, once those allowances are determined, a separate Z-order curve is established for each block and the elements are assigned to processors within each block by greedily filling each available processors' allowance by contiguous intervals along the Z-order curve. Some examples:</p><ul>
<li>If there are 8 blocks, 16 elements per block, 16 cores, and all cores are allowed to have elements: each core gets an allowance of 128 / 16 = 8 elements, so each core gets half of a block, and the 8 elements for each core within the block are chosen via Z-order curve for the respective blocks.</li>
<li>If there are 3 blocks, 4 elements per block, 4 cores, and all cores are allowed to have elements: each core gets an allowance of 12 / 4 = 3 elements. Core 0 gets three elements from the first block, core 1 gets one element from the first block and two elements from the second block, core 2 gets two elements from the second block and one from the third, and core 3 gets the remaining three elements from the third block. Each collection of elements within the blocks are then assigned using intervals along the Z-order curve for each block.</li>
<li>Same as the previous example, 3 blocks, 4 elements per block, and 4 cores, except now we require that physical cores 1 and 3 don't have any elements on them. The new distribution would look like:<ul>
<li>Elements on old core 0 -&gt; new core 0</li>
<li>No elements on new core 1</li>
<li>Elements on old core 1 -&gt; new core 2</li>
<li>No elements on new core 3</li>
<li>Elements on old core 2 -&gt; new core 4</li>
<li>Elements on old core 3 -&gt; new core 5</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In the third example, even though only 4 cores are used to place elements, the simulation is required to be run on at least 6 cores (4 cores for elements + 2 cores without elements)</dd></dl>
<p>Morton curves are a simple and easily-computed space-filling curve that (unlike Hilbert curves) permit diagonal traversal. See, for instance, <b>[Borrell2018]</b> for a discussion of mesh partitioning using space-filling curves. A concrete example of the use of a Morton curve in 2d is given below.</p>
<p>A sketch of a 2D block with 4x2 elements, with each element labeled according to the order on the Morton curve: </p><div class="fragment"><div class="line">        x--&gt;</div>
<div class="line">        0   1   2   3</div>
<div class="line">      ----------------</div>
<div class="line">y  0 |  0   2   4   6</div>
<div class="line">|    |  | / | / | / |</div>
<div class="line">v  1 |  1   3   5   7</div>
</div><!-- fragment --><p> (forming a zig-zag path, that under some rotation/reflection has a 'Z' shape).</p>
<p>The Morton curve method is a quick way of getting acceptable spatial locality &ndash; usually, for approximately even distributions, it will ensure that elements are assigned in large volume chunks, and the structure of the Morton curve ensures that for a given processor and block, the elements will be assigned in no more than two orthogonally connected clusters. In principle, a Hilbert curve could potentially improve upon the gains obtained by this class by guaranteeing that all elements within each block form a single orthogonally connected cluster.</p>
<p>The assignment of portions of blocks to processors may use partial blocks, and/or multiple blocks to ensure an even distribution of elements to processors. We currently make no distinction between dividing elements between processors within a node and dividing elements between processors across nodes. The current technique aims to have a simple method of reducing communication globally, though it would likely be more efficient to prioritize minimization of inter-node communication, because communication across interconnects is the primary cost of communication in charm++ runs.</p>
<dl class="section warning"><dt>Warning</dt><dd>The use of the Morton curve to generate a well-clustered element distribution currently assumes that the refinement is uniform over each block, with no internal structure that would be generated by, for instance AMR. This distribution method will need alteration to perform well for blocks with internal structure from h-refinement. Morton curves can be defined recursively, so a generalization of the present method is possible for blocks with internal refinement </dd></dl>
</div><hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/Domain/ElementDistribution.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>domain</b></li><li class="navelem"><a class="el" href="structdomain_1_1BlockZCurveProcDistribution.html">BlockZCurveProcDistribution</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
