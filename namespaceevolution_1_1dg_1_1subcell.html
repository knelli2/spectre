<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.1"/>
  <title>SpECTRE: evolution::dg::subcell Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.08.01</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceevolution_1_1dg_1_1subcell.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">evolution::dg::subcell Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of a generic finite volume/conservative finite difference subcell limiter.  
<a href="namespaceevolution_1_1dg_1_1subcell.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1Actions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1Actions.html">Actions</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1Actions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions for the DG-subcell hybrid solver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1fd"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fd.html">fd</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code specific to a conservative finite difference subcell limiter. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1fv"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1fv.html">fv</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1fv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code specific to a finite volume subcell limiter. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1OptionTags"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1OptionTags.html">OptionTags</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1OptionTags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option tags for the DG-subcell solver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceevolution_1_1dg_1_1subcell_1_1Tags"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell_1_1Tags.html">Tags</a></td></tr>
<tr class="memdesc:namespaceevolution_1_1dg_1_1subcell_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags for the DG-subcell solver <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds data needed for the relaxed discrete maximum principle troubled-cell indicator.  <a href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevolution_1_1dg_1_1subcell_1_1SubcellOptions.html">SubcellOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the system-agnostic subcell parameters, such as numbers controlling when to switch between DG and subcell.  <a href="classevolution_1_1dg_1_1subcell_1_1SubcellOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga97fbd926840d2508e331694db731e18a"><td class="memItemLeft" align="right" valign="top"><a id="ga97fbd926840d2508e331694db731e18a"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DgSubcellGroup.html#ga97fbd926840d2508e331694db731e18a">ActiveGrid</a> { <b>Dg</b>
, <b>Subcell</b>
 }</td></tr>
<tr class="memdesc:ga97fbd926840d2508e331694db731e18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The grid that is currently being used for the DG-subcell evolution. <br /></td></tr>
<tr class="separator:ga97fbd926840d2508e331694db731e18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0e7c210ef7a735febf6723a2ab757705"><td class="memItemLeft" align="right" valign="top"><a id="a0e7c210ef7a735febf6723a2ab757705"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, <a class="el" href="group__DgSubcellGroup.html#ga97fbd926840d2508e331694db731e18a">ActiveGrid</a> active_grid)</td></tr>
<tr class="separator:a0e7c210ef7a735febf6723a2ab757705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042e846c862648cf4dc53938bda921df"><td class="memTemplParams" colspan="2"><a id="a042e846c862648cf4dc53938bda921df"></a>
template&lt;typename... CorrectionTags, typename BoundaryCorrection , typename... PackageFieldTags&gt; </td></tr>
<tr class="memitem:a042e846c862648cf4dc53938bda921df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_boundary_terms</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; tmpl::list&lt; CorrectionTags... &gt;&gt; * &gt; boundary_corrections_on_face, const BoundaryCorrection &amp;boundary_correction, const Variables&lt; tmpl::list&lt; PackageFieldTags... &gt;&gt; &amp;upper_packaged_data, const Variables&lt; tmpl::list&lt; PackageFieldTags... &gt;&gt; &amp;lower_packaged_data)</td></tr>
<tr class="separator:a042e846c862648cf4dc53938bda921df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae6f64395a3d32f5023a5f7a73e909d"><td class="memTemplParams" colspan="2">template&lt;bool OverwriteInternalMortarData, size_t Dim, typename DgPackageFieldTags &gt; </td></tr>
<tr class="memitem:a9ae6f64395a3d32f5023a5f7a73e909d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a9ae6f64395a3d32f5023a5f7a73e909d">correct_package_data</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; DgPackageFieldTags &gt; * &gt; lower_packaged_data, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; DgPackageFieldTags &gt; * &gt; upper_packaged_data, const size_t logical_dimension_to_operate_in, const <a class="el" href="classElement.html">Element</a>&lt; Dim &gt; &amp;element, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;subcell_volume_mesh, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;&gt;, <a class="el" href="classevolution_1_1dg_1_1MortarData.html">evolution::dg::MortarData</a>&lt; Dim &gt;, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;&gt;&gt;&gt; &amp;mortar_data)</td></tr>
<tr class="memdesc:a9ae6f64395a3d32f5023a5f7a73e909d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the DG package data to the subcells. Data received from a neighboring element doing DG is always projected, while the data we sent to our neighbors before doing a rollback from DG to subcell is only projected if <code>OverwriteInternalMortarData</code> is <code>true</code>.  <a href="namespaceevolution_1_1dg_1_1subcell.html#a9ae6f64395a3d32f5023a5f7a73e909d">More...</a><br /></td></tr>
<tr class="separator:a9ae6f64395a3d32f5023a5f7a73e909d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a564d78dfa7ec47f32ce686542eacd"><td class="memTemplParams" colspan="2">template&lt;typename Metavariables , typename DbTagsList &gt; </td></tr>
<tr class="memitem:a21a564d78dfa7ec47f32ce686542eacd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a21a564d78dfa7ec47f32ce686542eacd">neighbor_reconstructed_face_solution</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTagsList &gt; * &gt; box, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; const <a class="el" href="classTimeStepId.html">TimeStepId</a>, <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Metavariables::volume_dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Metavariables::volume_dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Metavariables::volume_dim &gt;&gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; <a class="el" href="classMesh.html">Mesh</a>&lt; Metavariables::volume_dim &gt;, <a class="el" href="classMesh.html">Mesh</a>&lt; Metavariables::volume_dim - 1 &gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;&gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;&gt;, ::<a class="el" href="classTimeStepId.html">TimeStepId</a> &gt;, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Metavariables::volume_dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Metavariables::volume_dim &gt;&gt;&gt;&gt;&gt; * &gt; received_temporal_id_and_data)</td></tr>
<tr class="memdesc:a21a564d78dfa7ec47f32ce686542eacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked in directions where the neighbor is doing subcell, this function computes the neighbor data on the mortar via reconstruction on nearest neighbor subcells.  <a href="namespaceevolution_1_1dg_1_1subcell.html#a21a564d78dfa7ec47f32ce686542eacd">More...</a><br /></td></tr>
<tr class="separator:a21a564d78dfa7ec47f32ce686542eacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53caeb742f1c7fe2955b833ec3f267f"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename SymmList , typename IndexList &gt; </td></tr>
<tr class="memitem:ab53caeb742f1c7fe2955b833ec3f267f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#ab53caeb742f1c7fe2955b833ec3f267f">persson_tci</a> (const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt; &amp;tensor, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const double alpha)</td></tr>
<tr class="memdesc:ab53caeb742f1c7fe2955b833ec3f267f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Troubled cell indicator using spectral falloff of <b>[Persson2006sub]</b>.  <a href="namespaceevolution_1_1dg_1_1subcell.html#ab53caeb742f1c7fe2955b833ec3f267f">More...</a><br /></td></tr>
<tr class="separator:ab53caeb742f1c7fe2955b833ec3f267f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629eab44053a01ded5046208438c3d01"><td class="memTemplParams" colspan="2">template&lt;typename Metavariables , typename DbTagsList &gt; </td></tr>
<tr class="memitem:a629eab44053a01ded5046208438c3d01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Metavariables::volume_dim, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a629eab44053a01ded5046208438c3d01">prepare_neighbor_data</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTagsList &gt; * &gt; box)</td></tr>
<tr class="memdesc:a629eab44053a01ded5046208438c3d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add local data for our and our neighbor's relaxed discrete maximum principle troubled-cell indicator, and compute and slice data needed for the neighbor cells.  <a href="namespaceevolution_1_1dg_1_1subcell.html#a629eab44053a01ded5046208438c3d01">More...</a><br /></td></tr>
<tr class="separator:a629eab44053a01ded5046208438c3d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e0cea456d90b8f73c0729e2322eecc"><td class="memTemplParams" colspan="2">template&lt;typename... EvolvedVarsTags&gt; </td></tr>
<tr class="memitem:a08e0cea456d90b8f73c0729e2322eecc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a08e0cea456d90b8f73c0729e2322eecc">rdmp_tci</a> (const Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt;&gt; &amp;active_grid_candidate_evolved_vars, const Variables&lt; tmpl::list&lt; <a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1Inactive.html">Tags::Inactive</a>&lt; EvolvedVarsTags &gt;... &gt;&gt; &amp;inactive_grid_candidate_evolved_vars, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;max_of_past_variables, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;min_of_past_variables, const double rdmp_delta0, const double rdmp_epsilon)</td></tr>
<tr class="memdesc:a08e0cea456d90b8f73c0729e2322eecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Troubled cell indicator using a relaxed discrete maximum principle, comparing the candidate solution with the past solution in the element and its neighbors.  <a href="namespaceevolution_1_1dg_1_1subcell.html#a08e0cea456d90b8f73c0729e2322eecc">More...</a><br /></td></tr>
<tr class="separator:a08e0cea456d90b8f73c0729e2322eecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968c96e91ab29c14225e7335e0ed22b6"><td class="memTemplParams" colspan="2"><a id="a968c96e91ab29c14225e7335e0ed22b6"></a>
template&lt;typename... EvolvedVarsTags&gt; </td></tr>
<tr class="memitem:a968c96e91ab29c14225e7335e0ed22b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a968c96e91ab29c14225e7335e0ed22b6">rdmp_max_min</a> (const Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt;&gt; &amp;active_grid_evolved_vars, const Variables&lt; tmpl::list&lt; <a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1Inactive.html">Tags::Inactive</a>&lt; EvolvedVarsTags &gt;... &gt;&gt; &amp;inactive_grid_evolved_vars, const bool include_inactive_grid)</td></tr>
<tr class="memdesc:a968c96e91ab29c14225e7335e0ed22b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the max and min of each component of the active and inactive variables. If <code>include_inactive_grid</code> is <code>false</code> then only the max over the <code>active_grid_evolved_vars</code> for each component is returned. <br /></td></tr>
<tr class="separator:a968c96e91ab29c14225e7335e0ed22b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad877b2f7c54778c125c4df89e8f4072d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#ad877b2f7c54778c125c4df89e8f4072d">rdmp_tci</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;max_of_current_variables, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;min_of_current_variables, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;max_of_past_variables, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;min_of_past_variables, double rdmp_delta0, double rdmp_epsilon)</td></tr>
<tr class="memdesc:ad877b2f7c54778c125c4df89e8f4072d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current variables satisfy the RDMP. Returns <code>true</code> if the cell is troubled.  <a href="namespaceevolution_1_1dg_1_1subcell.html#ad877b2f7c54778c125c4df89e8f4072d">More...</a><br /></td></tr>
<tr class="separator:ad877b2f7c54778c125c4df89e8f4072d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bd5601a2f8a45020a0560874ec1bee"><td class="memItemLeft" align="right" valign="top"><a id="a08bd5601a2f8a45020a0560874ec1bee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pup</b> (PUP::er &amp;p, <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> &amp;rdmp_tci_data)</td></tr>
<tr class="separator:a08bd5601a2f8a45020a0560874ec1bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbba5504a2b65408db342e144e39d56"><td class="memItemLeft" align="right" valign="top"><a id="aecbba5504a2b65408db342e144e39d56"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (PUP::er &amp;p, <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> &amp;rdmp_tci_data)</td></tr>
<tr class="separator:aecbba5504a2b65408db342e144e39d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb704aea399becf5a60440cdc0965c1"><td class="memItemLeft" align="right" valign="top"><a id="afdb704aea399becf5a60440cdc0965c1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> &amp;lhs, const <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> &amp;rhs)</td></tr>
<tr class="separator:afdb704aea399becf5a60440cdc0965c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb97b7990f700e9e8690044b554d50ac"><td class="memItemLeft" align="right" valign="top"><a id="adb97b7990f700e9e8690044b554d50ac"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> &amp;lhs, const <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> &amp;rhs)</td></tr>
<tr class="separator:adb97b7990f700e9e8690044b554d50ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a11dc1017155a83e75710aafa8d2c0"><td class="memItemLeft" align="right" valign="top"><a id="ad0a11dc1017155a83e75710aafa8d2c0"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="el" href="structevolution_1_1dg_1_1subcell_1_1RdmpTciData.html">RdmpTciData</a> &amp;t)</td></tr>
<tr class="separator:ad0a11dc1017155a83e75710aafa8d2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d813229d62781a81b5ca4773a2b5848"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename TagList &gt; </td></tr>
<tr class="memitem:a2d813229d62781a81b5ca4773a2b5848"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a2d813229d62781a81b5ca4773a2b5848">slice_data</a> (const Variables&lt; TagList &gt; &amp;volume_subcell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, const size_t number_of_ghost_points, const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, bool &gt; &amp;directions_to_slice)</td></tr>
<tr class="memdesc:a2d813229d62781a81b5ca4773a2b5848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice the subcell variables needed for neighbors to perform reconstruction.  <a href="namespaceevolution_1_1dg_1_1subcell.html#a2d813229d62781a81b5ca4773a2b5848">More...</a><br /></td></tr>
<tr class="separator:a2d813229d62781a81b5ca4773a2b5848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d346f707b4a65a29139c956224d7c2f"><td class="memTemplParams" colspan="2"><a id="a5d346f707b4a65a29139c956224d7c2f"></a>
template&lt;size_t Dim, typename VectorType &gt; </td></tr>
<tr class="memitem:a5d346f707b4a65a29139c956224d7c2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>slice_tensor_for_subcell</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; VectorType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt;&gt;, index_list&lt;&gt;&gt; * &gt; sliced_scalar, const Tensor&lt; VectorType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt;&gt;, index_list&lt;&gt;&gt; &amp;volume_scalar, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, size_t number_of_ghost_points, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="separator:a5d346f707b4a65a29139c956224d7c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644fa78d6814795a8dd5ef0c6801477e"><td class="memItemLeft" align="right" valign="top"><a id="a644fa78d6814795a8dd5ef0c6801477e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classevolution_1_1dg_1_1subcell_1_1SubcellOptions.html">SubcellOptions</a> &amp;lhs, const <a class="el" href="classevolution_1_1dg_1_1subcell_1_1SubcellOptions.html">SubcellOptions</a> &amp;rhs)</td></tr>
<tr class="separator:a644fa78d6814795a8dd5ef0c6801477e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cef1c11c1fb9f3d8bca3ca505cd961"><td class="memItemLeft" align="right" valign="top"><a id="a53cef1c11c1fb9f3d8bca3ca505cd961"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classevolution_1_1dg_1_1subcell_1_1SubcellOptions.html">SubcellOptions</a> &amp;lhs, const <a class="el" href="classevolution_1_1dg_1_1subcell_1_1SubcellOptions.html">SubcellOptions</a> &amp;rhs)</td></tr>
<tr class="separator:a53cef1c11c1fb9f3d8bca3ca505cd961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446bc69f2fdb2d809a3bf17a342cacbf"><td class="memTemplParams" colspan="2">template&lt;typename... DgEvolvedVarsTags, typename... SubcellEvolvedVarsTags&gt; </td></tr>
<tr class="memitem:a446bc69f2fdb2d809a3bf17a342cacbf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a446bc69f2fdb2d809a3bf17a342cacbf">two_mesh_rdmp_tci</a> (const Variables&lt; tmpl::list&lt; DgEvolvedVarsTags... &gt;&gt; &amp;dg_evolved_vars, const Variables&lt; tmpl::list&lt; SubcellEvolvedVarsTags... &gt;&gt; &amp;subcell_evolved_vars, const double rdmp_delta0, const double rdmp_epsilon)</td></tr>
<tr class="memdesc:a446bc69f2fdb2d809a3bf17a342cacbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Troubled cell indicator using a relaxed discrete maximum principle, comparing the solution on two grids at the same point in time.  <a href="namespaceevolution_1_1dg_1_1subcell.html#a446bc69f2fdb2d809a3bf17a342cacbf">More...</a><br /></td></tr>
<tr class="separator:a446bc69f2fdb2d809a3bf17a342cacbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abe52620b5dcd9ed2e7c0a7bc19abeedb"><td class="memItemLeft" align="right" valign="top"><a id="abe52620b5dcd9ed2e7c0a7bc19abeedb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#abe52620b5dcd9ed2e7c0a7bc19abeedb">add_cartesian_flux_divergence</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; dt_var, double one_over_delta, const <a class="el" href="classDataVector.html">DataVector</a> &amp;inv_jacobian, const <a class="el" href="classDataVector.html">DataVector</a> &amp;boundary_correction, const <a class="el" href="classIndex.html">Index</a>&lt; 1 &gt; &amp;subcell_extents, size_t dimension)</td></tr>
<tr class="memdesc:abe52620b5dcd9ed2e7c0a7bc19abeedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and add the 2nd-order flux divergence on a Cartesian mesh to the cell-centered time derivatives. <br /></td></tr>
<tr class="separator:abe52620b5dcd9ed2e7c0a7bc19abeedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8afd602bce8d264d6f5d89f2eaccded"><td class="memItemLeft" align="right" valign="top"><a id="aa8afd602bce8d264d6f5d89f2eaccded"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#aa8afd602bce8d264d6f5d89f2eaccded">add_cartesian_flux_divergence</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; dt_var, double one_over_delta, const <a class="el" href="classDataVector.html">DataVector</a> &amp;inv_jacobian, const <a class="el" href="classDataVector.html">DataVector</a> &amp;boundary_correction, const <a class="el" href="classIndex.html">Index</a>&lt; 2 &gt; &amp;subcell_extents, size_t dimension)</td></tr>
<tr class="memdesc:aa8afd602bce8d264d6f5d89f2eaccded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and add the 2nd-order flux divergence on a Cartesian mesh to the cell-centered time derivatives. <br /></td></tr>
<tr class="separator:aa8afd602bce8d264d6f5d89f2eaccded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a57972f935d235591528577c33a08e5"><td class="memItemLeft" align="right" valign="top"><a id="a3a57972f935d235591528577c33a08e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a3a57972f935d235591528577c33a08e5">add_cartesian_flux_divergence</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> * &gt; dt_var, double one_over_delta, const <a class="el" href="classDataVector.html">DataVector</a> &amp;inv_jacobian, const <a class="el" href="classDataVector.html">DataVector</a> &amp;boundary_correction, const <a class="el" href="classIndex.html">Index</a>&lt; 3 &gt; &amp;subcell_extents, size_t dimension)</td></tr>
<tr class="memdesc:a3a57972f935d235591528577c33a08e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and add the 2nd-order flux divergence on a Cartesian mesh to the cell-centered time derivatives. <br /></td></tr>
<tr class="separator:a3a57972f935d235591528577c33a08e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab0764d979685439b92d864c698cb94ce"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename VectorType , typename... Structure&gt; </td></tr>
<tr class="memitem:ab0764d979685439b92d864c698cb94ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#ab0764d979685439b92d864c698cb94ce">slice_tensor_for_subcell</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; VectorType, Structure... &gt; * &gt; sliced_tensor, const Tensor&lt; VectorType, Structure... &gt; &amp;volume_tensor, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, size_t number_of_ghost_points, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ab0764d979685439b92d864c698cb94ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice a single volume tensor for a given direction and slicing depth (number of ghost points).  <a href="namespaceevolution_1_1dg_1_1subcell.html#ab0764d979685439b92d864c698cb94ce">More...</a><br /></td></tr>
<tr class="separator:ab0764d979685439b92d864c698cb94ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad043d022db1fdc2e6591c33ff1a67e46"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename VectorType , typename... Structure&gt; </td></tr>
<tr class="memitem:ad043d022db1fdc2e6591c33ff1a67e46"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; VectorType, Structure... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#ad043d022db1fdc2e6591c33ff1a67e46">slice_tensor_for_subcell</a> (const Tensor&lt; VectorType, Structure... &gt; &amp;volume_tensor, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, size_t number_of_ghost_points, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ad043d022db1fdc2e6591c33ff1a67e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice a single volume tensor for a given direction and slicing depth (number of ghost points).  <a href="namespaceevolution_1_1dg_1_1subcell.html#ad043d022db1fdc2e6591c33ff1a67e46">More...</a><br /></td></tr>
<tr class="separator:ad043d022db1fdc2e6591c33ff1a67e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac8b7317e7b3e03f813fd59f7274544f0"><td class="memTemplParams" colspan="2"><a id="ac8b7317e7b3e03f813fd59f7274544f0"></a>
template&lt;size_t Dim, typename TagList &gt; </td></tr>
<tr class="memitem:ac8b7317e7b3e03f813fd59f7274544f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#ac8b7317e7b3e03f813fd59f7274544f0">slice_variable</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; TagList &gt; * &gt; &amp;sliced_subcell_vars, const Variables&lt; TagList &gt; &amp;volume_subcell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, const size_t ghost_zone_size, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ac8b7317e7b3e03f813fd59f7274544f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice a Variables object on subcell mesh for a given direction and slicing depth (number of ghost points). <br /></td></tr>
<tr class="separator:ac8b7317e7b3e03f813fd59f7274544f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25b23788ffdce75036fc25e3a3d209d"><td class="memTemplParams" colspan="2"><a id="ac25b23788ffdce75036fc25e3a3d209d"></a>
template&lt;size_t Dim, typename TagList &gt; </td></tr>
<tr class="memitem:ac25b23788ffdce75036fc25e3a3d209d"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; TagList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#ac25b23788ffdce75036fc25e3a3d209d">slice_variable</a> (const Variables&lt; TagList &gt; &amp;volume_subcell_vars, const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;subcell_extents, const size_t ghost_zone_size, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ac25b23788ffdce75036fc25e3a3d209d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice a Variables object on subcell mesh for a given direction and slicing depth (number of ghost points). <br /></td></tr>
<tr class="separator:ac25b23788ffdce75036fc25e3a3d209d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a406a38cf2405cc31533f321bb7759dd8"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a406a38cf2405cc31533f321bb7759dd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a406a38cf2405cc31533f321bb7759dd8">tci_status</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; status, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;subcell_mesh, <a class="el" href="group__DgSubcellGroup.html#ga97fbd926840d2508e331694db731e18a">subcell::ActiveGrid</a> active_grid, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; <a class="el" href="group__DgSubcellGroup.html#ga97fbd926840d2508e331694db731e18a">subcell::ActiveGrid</a> &gt; &amp;tci_history)</td></tr>
<tr class="memdesc:a406a38cf2405cc31533f321bb7759dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>status</code> to <code>1</code> if the cell is marked as needing subcell, otherwise set <code>status</code> to <code>0</code>. <code>status</code> has grid points on the currently active mesh.  <a href="namespaceevolution_1_1dg_1_1subcell.html#a406a38cf2405cc31533f321bb7759dd8">More...</a><br /></td></tr>
<tr class="separator:a406a38cf2405cc31533f321bb7759dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c67ea99cd65021e04e6f52519f275c6"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a8c67ea99cd65021e04e6f52519f275c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a8c67ea99cd65021e04e6f52519f275c6">tci_status</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;dg_mesh, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;subcell_mesh, <a class="el" href="group__DgSubcellGroup.html#ga97fbd926840d2508e331694db731e18a">subcell::ActiveGrid</a> active_grid, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; <a class="el" href="group__DgSubcellGroup.html#ga97fbd926840d2508e331694db731e18a">subcell::ActiveGrid</a> &gt; &amp;tci_history)</td></tr>
<tr class="memdesc:a8c67ea99cd65021e04e6f52519f275c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>status</code> to <code>1</code> if the cell is marked as needing subcell, otherwise set <code>status</code> to <code>0</code>. <code>status</code> has grid points on the currently active mesh.  <a href="namespaceevolution_1_1dg_1_1subcell.html#a8c67ea99cd65021e04e6f52519f275c6">More...</a><br /></td></tr>
<tr class="separator:a8c67ea99cd65021e04e6f52519f275c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of a generic finite volume/conservative finite difference subcell limiter. </p>
<p>Our implementation of a finite volume (FV) or finite difference (FD) subcell limiter (SCL) follows <b>[Dumbser2014a]</b>. Other implementations of a subcell limiter exist, e.g. <b>[Sonntag2014]</b> <b>[Casoni2012]</b> <b>[Hou2007]</b>. Our implementation and that of <b>[Dumbser2014a]</b> are a generalization of the Multidimensional Optimal Order Detection (MOOD) algorithm <b>[CLAIN20114028]</b> <b>[DIOT201243]</b> <b>[Diot2013]</b> <b>[Loubere2014]</b>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9ae6f64395a3d32f5023a5f7a73e909d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae6f64395a3d32f5023a5f7a73e909d">&#9670;&nbsp;</a></span>correct_package_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool OverwriteInternalMortarData, size_t Dim, typename DgPackageFieldTags &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::correct_package_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; DgPackageFieldTags &gt; * &gt;&#160;</td>
          <td class="paramname"><em>lower_packaged_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; DgPackageFieldTags &gt; * &gt;&#160;</td>
          <td class="paramname"><em>upper_packaged_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>logical_dimension_to_operate_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;&gt;, <a class="el" href="classevolution_1_1dg_1_1MortarData.html">evolution::dg::MortarData</a>&lt; Dim &gt;, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>mortar_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the DG package data to the subcells. Data received from a neighboring element doing DG is always projected, while the data we sent to our neighbors before doing a rollback from DG to subcell is only projected if <code>OverwriteInternalMortarData</code> is <code>true</code>. </p>
<p>In order for the hybrid DG-FD/FV scheme to be conservative between elements using DG and elements using subcell, the boundary terms must be the same on both elements. In practice this means the boundary corrections \(G+D\) must be computed on the same grid. Consider the element doing subcell which receives data from an element doing DG. In this case the DG element's ingredients going into \(G+D\) are projected to the subcells and then \(G+D\) are computed on the subcells. Similarly, for strict conservation the element doing DG must first project the data it sent to the neighbor to the subcells, then compute \(G+D\) on the subcells, and finally reconstrct \(G+D\) back to the DG grid before lifting \(G+D\) to the volume.</p>
<p>This function updates the <code>packaged_data</code> (ingredients into \(G+D\)) received by an element doing subcell by projecting the neighbor's DG data onto the subcells. Note that this is only half of what is required for strict conservation, the DG element must also compute \(G+D\) on the subcells. Note that we currently do not perform the other half of the correction needed to be strictly conservative.</p>
<p>If we are retaking a time step after the DG step failed then maintaining conservation requires additional care. If <code>OverwriteInternalMortarData</code> is <code>true</code> then the local (the element switching from DG to subcell) ingredients into \(G+D\) are projected and overwrite the data computed from the FD reconstruction to the interface. However, even this is insufficient to guarantee conservation. To guarantee conservation (which we do not currently do) the correction \(G+D\) must be computed on the DG grid and then projected to the subcells.</p>
<p>Note that our practical experience shows that since the DG-subcell hybrid scheme switches to the subcell solver <em>before</em> the local solution contains discontinuities, strict conservation is not necessary between DG and FD/FV regions. This was also observed with a block-adaptive finite difference AMR code <b>[CHEN2016604]</b> </p>

</div>
</div>
<a id="a21a564d78dfa7ec47f32ce686542eacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a564d78dfa7ec47f32ce686542eacd">&#9670;&nbsp;</a></span>neighbor_reconstructed_face_solution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Metavariables , typename DbTagsList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::neighbor_reconstructed_face_solution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTagsList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; const <a class="el" href="classTimeStepId.html">TimeStepId</a>, <a class="el" href="classFixedHashMap.html">FixedHashMap</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(Metavariables::volume_dim), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Metavariables::volume_dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Metavariables::volume_dim &gt;&gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; <a class="el" href="classMesh.html">Mesh</a>&lt; Metavariables::volume_dim &gt;, <a class="el" href="classMesh.html">Mesh</a>&lt; Metavariables::volume_dim - 1 &gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;&gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;&gt;, ::<a class="el" href="classTimeStepId.html">TimeStepId</a> &gt;, boost::hash&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDirection.html">Direction</a>&lt; Metavariables::volume_dim &gt;, <a class="el" href="classElementId.html">ElementId</a>&lt; Metavariables::volume_dim &gt;&gt;&gt;&gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>received_temporal_id_and_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoked in directions where the neighbor is doing subcell, this function computes the neighbor data on the mortar via reconstruction on nearest neighbor subcells. </p>
<p>The data needed for reconstruction is copied over into <code><a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1NeighborDataForReconstruction.html" title="The neighbor data for reconstruction.">subcell::Tags::NeighborDataForReconstruction</a></code>. Additionally, the max/min of the evolved variables from neighboring elements that is used for the relaxed discrete maximum principle troubled-cell indicator is combined with the data from the local element and stored in <code><a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1DataForRdmpTci.html" title="The data for the RDMP troubled-cell indicator.">subcell::Tags::DataForRdmpTci</a></code>. We handle the RDMP data now because it is sent in the same buffer as the data for reconstruction.</p>
<p>A list of all the directions that are doing subcell is created and then passed to the mutator <code>Metavariables::SubcellOptions::DgOuterCorrectionPackageData::apply</code>, which must return a</p>
<div class="fragment"><div class="line"><a class="code" href="classFixedHashMap.html">FixedHashMap</a>&lt;</div>
<div class="line">    <a class="code" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a>(volume_dim),</div>
<div class="line">    <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;Direction&lt;volume_dim&gt;</a>, <a class="code" href="classElementId.html">ElementId&lt;volume_dim&gt;</a>&gt;,</div>
<div class="line">    <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>,</div>
<div class="line">    boost::hash&lt;std::pair&lt;Direction&lt;volume_dim&gt;, <a class="code" href="classElementId.html">ElementId&lt;volume_dim&gt;</a>&gt;&gt;&gt;</div>
<div class="ttc" id="aclassElementId_html"><div class="ttname"><a href="classElementId.html">ElementId</a></div><div class="ttdoc">An ElementId uniquely labels an Element.</div><div class="ttdef"><b>Definition:</b> ElementId.hpp:52</div></div>
<div class="ttc" id="aclassFixedHashMap_html"><div class="ttname"><a href="classFixedHashMap.html">FixedHashMap</a></div><div class="ttdoc">A hash table with a compile-time specified maximum size and ability to efficiently handle perfect has...</div><div class="ttdef"><b>Definition:</b> FixedHashMap.hpp:81</div></div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_gafa8cb44daebc8f9e080718961530be89"><div class="ttname"><a href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a></div><div class="ttdeci">constexpr size_t maximum_number_of_neighbors(const size_t dim)</div><div class="ttdoc">Returns the maximum number of neighbors an element can have in dim dimensions.</div><div class="ttdef"><b>Definition:</b> MaxNumberOfNeighbors.hpp:15</div></div>
<div class="ttc" id="apair_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a></div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt; double &gt;</a></div></div>
</div><!-- fragment --><p>which holds the reconstructed <code>dg_packaged_data</code> on the face (stored in the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code>) for the boundary correction. A <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a>&lt;volume_dim&gt;, <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a>&lt;volume_dim&gt;&gt;&gt;</code> holding the list of mortars that need to be reconstructed to is passed in as the last argument to <code>Metavariables::SubcellOptions::DgOuterCorrectionPackageData::apply</code>. </p>

</div>
</div>
<a id="ab53caeb742f1c7fe2955b833ec3f267f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53caeb742f1c7fe2955b833ec3f267f">&#9670;&nbsp;</a></span>persson_tci()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename SymmList , typename IndexList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool evolution::dg::subcell::persson_tci </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, SymmList, IndexList &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Troubled cell indicator using spectral falloff of <b>[Persson2006sub]</b>. </p>
<p>Consider a discontinuity sensing quantity \(U\), which is typically a scalar but could be a tensor of any rank. Let \(U\) have the 1d spectral decomposition (generalization to higher-dimensional tensor product bases is done dimension-by-dimension):</p>
<p class="formulaDsp">
\begin{align*} U(x)=\sum_{i=0}^{N}c_i P_i(x), \end{align*}
</p>
<p>where \(P_i(x)\) are the basis functions, in our case the Legendre polynomials, and \(c_i\) are the spectral coefficients. We then define a filtered solution \(\hat{U}\) as</p>
<p class="formulaDsp">
\begin{align*} \hat{U}(x)=c_N P_N(x). \end{align*}
</p>
<p>Note that when an exponential filter is being used to deal with aliasing, lower modes can be included in \(\hat{U}\). The main goal of \(\hat{U}\) is to measure how much power is in the highest modes, which are the modes responsible for Gibbs phenomena. We define the discontinuity indicator \(s^\Omega\) as</p>
<p class="formulaDsp">
\begin{align*} s^\Omega=\log_{10}\left(\frac{(\hat{U}, \hat{U})}{(U, U)}\right), \end{align*}
</p>
<p>where \((\cdot,\cdot)\) is an inner product, which we take to be the Euclidean \(L_2\) norm (i.e. we do not divide by the number of grid points since that cancels out anyway). A cell is troubled if \(s^\Omega &gt; -\alpha \log_{10}(N)\). Typically, \(\alpha=4\) is a good choice.</p>
<p>The parameter <code>zero_cutoff</code> is used to avoid division and logarithms of small numbers, which can be wildly fluctuating because of roundoff errors. We do not check the TCI for tensor components when \(L_2(\hat{U}) \leq \epsilon L_2(U)\), where \(\epsilon\) is the <code>zero_cutoff</code>. If all components are skipped the TCI returns <code>false</code>, i.e. the cell is not troubled. </p>

</div>
</div>
<a id="a629eab44053a01ded5046208438c3d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629eab44053a01ded5046208438c3d01">&#9670;&nbsp;</a></span>prepare_neighbor_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Metavariables , typename DbTagsList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDirectionMap.html">DirectionMap</a>&lt;Metavariables::volume_dim, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt; &gt; evolution::dg::subcell::prepare_neighbor_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTagsList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add local data for our and our neighbor's relaxed discrete maximum principle troubled-cell indicator, and compute and slice data needed for the neighbor cells. </p>
<p>The local maximum and minimum of the evolved variables is added to <code><a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1DataForRdmpTci.html" title="The data for the RDMP troubled-cell indicator.">Tags::DataForRdmpTci</a></code> for the RDMP TCI. Then the data needed by neighbor elements to do reconstruction on the FD grid is sent. The data to be sent is computed in the mutator <code>Metavariables::SubcellOptions::GhostDataToSlice</code>, which returns a <code>Variables</code> of the tensors to slice and send to the neighbors. The main reason for having the mutator <code>GhostDataToSlice</code> is to allow sending primitive or characteristic variables for reconstruction. </p>

</div>
</div>
<a id="ad877b2f7c54778c125c4df89e8f4072d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad877b2f7c54778c125c4df89e8f4072d">&#9670;&nbsp;</a></span>rdmp_tci() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evolution::dg::subcell::rdmp_tci </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_of_current_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_of_current_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_of_past_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_of_past_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rdmp_delta0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rdmp_epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the current variables satisfy the RDMP. Returns <code>true</code> if the cell is troubled. </p>
<p>Let the candidate solution be denoted by \(u^\star_{\alpha}(t^{n+1})\). Then the RDMP requires that</p>
<p class="formulaDsp">
\begin{align*} \min_{\forall\mathcal{N}}\left(u_{\alpha}(t^n)\right) - \delta_\alpha \le u^\star_{\alpha}(t^{n+1}) \le \max_{\forall\mathcal{N}} \left(u_{\alpha}(t^n)\right) + \delta_\alpha \end{align*}
</p>
<p>where \(\mathcal{N}\) are either the Neumann or Voronoi neighbors and the element itself, and \(\delta_\alpha\) is a parameter defined below that relaxes the discrete maximum principle (DMP). When computing \(\max(u_\alpha)\) and \(\min(u_\alpha)\) over a DG element that is not using subcells we first project the DG solution to the subcells and then compute the maximum and minimum over <em>both</em> the DG grid and the subcell grid. However, when a DG element is using subcells we compute the maximum and minimum of \(u_\alpha(t^n)\) over the subcells only. Note that the maximum and minimum values of \(u^\star_\alpha\) are always computed over both the DG and the subcell grids, even when using the RDMP to check if the reconstructed DG solution would be admissible.</p>
<p>The parameter \(\delta_\alpha\) is given by:</p>
<p class="formulaDsp">
\begin{align*} \delta_\alpha = \max\left(\delta_{0},\epsilon \left(\max_{\forall\mathcal{N}}\left(u_{\alpha}(t^n)\right) - \min_{\forall\mathcal{N}}\left(u_{\alpha}(t^n)\right)\right) \right), \end{align*}
</p>
<p>where we typically take \(\delta_{0}=10^{-4}\) and \(\epsilon=10^{-3}\). </p>

</div>
</div>
<a id="a08e0cea456d90b8f73c0729e2322eecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e0cea456d90b8f73c0729e2322eecc">&#9670;&nbsp;</a></span>rdmp_tci() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... EvolvedVarsTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool evolution::dg::subcell::rdmp_tci </td>
          <td>(</td>
          <td class="paramtype">const Variables&lt; tmpl::list&lt; EvolvedVarsTags... &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>active_grid_candidate_evolved_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; tmpl::list&lt; <a class="el" href="structevolution_1_1dg_1_1subcell_1_1Tags_1_1Inactive.html">Tags::Inactive</a>&lt; EvolvedVarsTags &gt;... &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>inactive_grid_candidate_evolved_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_of_past_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_of_past_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rdmp_delta0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rdmp_epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Troubled cell indicator using a relaxed discrete maximum principle, comparing the candidate solution with the past solution in the element and its neighbors. </p>
<p>Let the candidate solution be denoted by \(u^\star_{\alpha}(t^{n+1})\). Then the RDMP requires that</p>
<p class="formulaDsp">
\begin{align*} \min_{\forall\mathcal{N}}\left(u_{\alpha}(t^n)\right) - \delta_\alpha \le u^\star_{\alpha}(t^{n+1}) \le \max_{\forall\mathcal{N}} \left(u_{\alpha}(t^n)\right) + \delta_\alpha \end{align*}
</p>
<p>where \(\mathcal{N}\) are either the Neumann or Voronoi neighbors and the element itself, and \(\delta_\alpha\) is a parameter defined below that relaxes the discrete maximum principle (DMP). When computing \(\max(u_\alpha)\) and \(\min(u_\alpha)\) over a DG element that is not using subcells we first project the DG solution to the subcells and then compute the maximum and minimum over <em>both</em> the DG grid and the subcell grid. However, when a DG element is using subcells we compute the maximum and minimum of \(u_\alpha(t^n)\) over the subcells only. Note that the maximum and minimum values of \(u^\star_\alpha\) are always computed over both the DG and the subcell grids, even when using the RDMP to check if the reconstructed DG solution would be admissible.</p>
<p>The parameter \(\delta_\alpha\) is given by:</p>
<p class="formulaDsp">
\begin{align*} \delta_\alpha = \max\left(\delta_{0},\epsilon \left(\max_{\forall\mathcal{N}}\left(u_{\alpha}(t^n)\right) - \min_{\forall\mathcal{N}}\left(u_{\alpha}(t^n)\right)\right) \right), \end{align*}
</p>
<p>where we typically take \(\delta_{0}=10^{-4}\) and \(\epsilon=10^{-3}\). </p>

</div>
</div>
<a id="a2d813229d62781a81b5ca4773a2b5848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d813229d62781a81b5ca4773a2b5848">&#9670;&nbsp;</a></span>slice_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename TagList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDirectionMap.html">DirectionMap</a>&lt;Dim, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt; &gt; evolution::dg::subcell::slice_data </td>
          <td>(</td>
          <td class="paramtype">const Variables&lt; TagList &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_subcell_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number_of_ghost_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; Dim, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>directions_to_slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slice the subcell variables needed for neighbors to perform reconstruction. </p>
<p>Note that we slice to a grid that is against the boundary of the element but is several ghost points deep. This is in contrast to the slicing used in the DG method which is to the boundary of the element only.</p>
<p>The <code>number_of_ghost_points</code> will depend on the number of neighboring points the reconstruction method needs that is used on the subcell. The <code>directions_to_slice</code> determines in which directions data is sliced. Generally this will be the directions in which the element has neighbors.</p>
<p>The data always has the same ordering as the volume data (tags have the same ordering, grid points are x-varies-fastest). </p>

</div>
</div>
<a id="ab0764d979685439b92d864c698cb94ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0764d979685439b92d864c698cb94ce">&#9670;&nbsp;</a></span>slice_tensor_for_subcell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename VectorType , typename... Structure&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::slice_tensor_for_subcell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; VectorType, Structure... &gt; * &gt;&#160;</td>
          <td class="paramname"><em>sliced_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; VectorType, Structure... &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_ghost_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slice a single volume tensor for a given direction and slicing depth (number of ghost points). </p>
<p>Note that the last argument has the type <code><a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a>&lt;Dim&gt;</code>, not a <a class="el" href="classDirectionMap.html" title="An optimized map with Direction keys.">DirectionMap</a> (cf. <code><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a2d813229d62781a81b5ca4773a2b5848" title="Slice the subcell variables needed for neighbors to perform reconstruction.">evolution::dg::subcell::slice_data</a></code>) </p>

</div>
</div>
<a id="ad043d022db1fdc2e6591c33ff1a67e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad043d022db1fdc2e6591c33ff1a67e46">&#9670;&nbsp;</a></span>slice_tensor_for_subcell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename VectorType , typename... Structure&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;VectorType, Structure...&gt; evolution::dg::subcell::slice_tensor_for_subcell </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; VectorType, Structure... &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_ghost_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slice a single volume tensor for a given direction and slicing depth (number of ghost points). </p>
<p>Note that the last argument has the type <code><a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a>&lt;Dim&gt;</code>, not a <a class="el" href="classDirectionMap.html" title="An optimized map with Direction keys.">DirectionMap</a> (cf. <code><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html#a2d813229d62781a81b5ca4773a2b5848" title="Slice the subcell variables needed for neighbors to perform reconstruction.">evolution::dg::subcell::slice_data</a></code>) </p>

</div>
</div>
<a id="a8c67ea99cd65021e04e6f52519f275c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c67ea99cd65021e04e6f52519f275c6">&#9670;&nbsp;</a></span>tci_status() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;<a class="el" href="classDataVector.html">DataVector</a>&gt; evolution::dg::subcell::tci_status </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DgSubcellGroup.html#ga97fbd926840d2508e331694db731e18a">subcell::ActiveGrid</a>&#160;</td>
          <td class="paramname"><em>active_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; <a class="el" href="group__DgSubcellGroup.html#ga97fbd926840d2508e331694db731e18a">subcell::ActiveGrid</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tci_history</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <code>status</code> to <code>1</code> if the cell is marked as needing subcell, otherwise set <code>status</code> to <code>0</code>. <code>status</code> has grid points on the currently active mesh. </p>
<dl class="section note"><dt>Note</dt><dd>It is possible to encounter a <code>status</code> of <code>0</code>, indicating a smooth solution, even though the active mesh is the subcell mesh. This can occur when using a multistep time integration method like Adams Bashforth, where the FD/FV scheme is used as long as <em>any</em> of the timestepper history is flagged for FD/FV subcell evolution. An example of this would be just after a shock leaves the cell: the solution is now smooth (<code>status</code> takes value <code>0</code>), but the multistep method continues to take FD timesteps (<code>status</code> is defined on the subcell mesh) until the entire history is flagged as smooth. Thus, <code>tci_history.front()</code> (which corresponds to the most recent TCI status) is used to set the status when using multistep time integrators, while the <code>active_grid</code> is used when using other time steppers. </dd></dl>

</div>
</div>
<a id="a406a38cf2405cc31533f321bb7759dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406a38cf2405cc31533f321bb7759dd8">&#9670;&nbsp;</a></span>tci_status() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evolution::dg::subcell::tci_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DgSubcellGroup.html#ga97fbd926840d2508e331694db731e18a">subcell::ActiveGrid</a>&#160;</td>
          <td class="paramname"><em>active_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; <a class="el" href="group__DgSubcellGroup.html#ga97fbd926840d2508e331694db731e18a">subcell::ActiveGrid</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tci_history</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <code>status</code> to <code>1</code> if the cell is marked as needing subcell, otherwise set <code>status</code> to <code>0</code>. <code>status</code> has grid points on the currently active mesh. </p>
<dl class="section note"><dt>Note</dt><dd>It is possible to encounter a <code>status</code> of <code>0</code>, indicating a smooth solution, even though the active mesh is the subcell mesh. This can occur when using a multistep time integration method like Adams Bashforth, where the FD/FV scheme is used as long as <em>any</em> of the timestepper history is flagged for FD/FV subcell evolution. An example of this would be just after a shock leaves the cell: the solution is now smooth (<code>status</code> takes value <code>0</code>), but the multistep method continues to take FD timesteps (<code>status</code> is defined on the subcell mesh) until the entire history is flagged as smooth. Thus, <code>tci_history.front()</code> (which corresponds to the most recent TCI status) is used to set the status when using multistep time integrators, while the <code>active_grid</code> is used when using other time steppers. </dd></dl>

</div>
</div>
<a id="a446bc69f2fdb2d809a3bf17a342cacbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446bc69f2fdb2d809a3bf17a342cacbf">&#9670;&nbsp;</a></span>two_mesh_rdmp_tci()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... DgEvolvedVarsTags, typename... SubcellEvolvedVarsTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool evolution::dg::subcell::two_mesh_rdmp_tci </td>
          <td>(</td>
          <td class="paramtype">const Variables&lt; tmpl::list&lt; DgEvolvedVarsTags... &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>dg_evolved_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variables&lt; tmpl::list&lt; SubcellEvolvedVarsTags... &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>subcell_evolved_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rdmp_delta0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rdmp_epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Troubled cell indicator using a relaxed discrete maximum principle, comparing the solution on two grids at the same point in time. </p>
<p>Checks that the subcell solution \(\underline{u}\) and the DG solution \(u\) satisfy</p>
<p class="formulaDsp">
\begin{align*} \min(u)-\delta \le \underline{u} \le \max(u)+\delta \end{align*}
</p>
<p>where</p>
<p class="formulaDsp">
\begin{align*} \delta = \max\left[\delta_0, \epsilon(\max(u) - \min(u))\right] \end{align*}
</p>
<p>where \(\delta_0\) and \(\epsilon\) are constants controlling the maximum absolute and relative change allowed when projecting the DG solution to the subcell grid. We currently specify one value of \(\delta_0\) and \(\epsilon\) for all variables, but this could be generalized to choosing the allowed variation in a variable-specific manner. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceevolution.html">evolution</a></li><li class="navelem"><a class="el" href="namespaceevolution_1_1dg.html">dg</a></li><li class="navelem"><a class="el" href="namespaceevolution_1_1dg_1_1subcell.html">subcell</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
