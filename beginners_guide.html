<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.1"/>
  <title>SpECTRE: A Hitchhiker&#39;s Guide to Running SpECTRE</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.08.01</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('beginners_guide.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">A Hitchhiker's Guide to Running SpECTRE </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_Tutorials_BeginnersTutorial"></a> SpECTRE can be a bit complicated to get started with, especially if you aren't familiar with our core concepts of task-based parallelism and Template Meta-Programming (TMP). However, [Don't Panic](<a href="https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Don't_Panic">https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Don't_Panic</a>) . This guide aims to get you introduced to building, running, visualizing, editing, and then rebuilding SpECTRE to give you a feel for what SpECTRE is all about, all on your own laptop! Hopefully by the end of this guide you'll feel comfortable enough to look at other executables and maybe even venture into the code itself!</p>
<h1><a class="anchor" id="autotoc_md27"></a>
Prerequisites</h1>
<p>To start off, you'll need to obtain an environment to build and run SpECTRE in. You could try and install all the dependencies yourself, but that is very tedious and very error prone. Instead, we provide a <a href="https://docs.docker.com/get-docker/">Docker</a> container with all the dependencies pre-installed for you to use. Probably the easiest way to get started with this is to follow our <a class="el" href="dev_guide_quick_start_docker_vscode.html">Code development quick-start with Docker and Visual Studio Code</a> tutorial which will have you</p>
<ol type="1">
<li>Clone SpECTRE</li>
<li>Install Docker</li>
<li>Install VSCode</li>
<li>Open the repository in VSCode in the Development Container</li>
</ol>
<p>You can stop before the "Configure, compile and run SPECTRE" section as we will be going through that here as well, but with different and more in-depth examples.</p>
<p>If you'd rather not use VSCode and instead just run the docker container in a terminal, you can follow the <a class="el" href="installation.html#docker_install">Using Docker to obtain a SpECTRE environment</a> tutorial in the <a class="el" href="installation.html">Installation</a> page.</p>
<p>Another program you will need for this tutorial is <a href="https://www.paraview.org/download/">Paraview</a> for visualizing the output. If you are running any Debian-based OS (like Ubuntu), you can just install it via your package manager</p>
<div class="fragment"><div class="line">sudo apt-get install paraview</div>
</div><!-- fragment --><p>Otherwise, you can just download the binary/executable. This is what you will need to do if you are running Windows or MacOS.</p>
<h1><a class="anchor" id="autotoc_md28"></a>
Building the ExportTimeDependentCoordinates3D Executable</h1>
<p>First, make sure you are inside the Docker container (whether this be in VSCode or just a terminal). First we will need to run <code>cmake</code> to set up everything because we use CMake as our build system.</p>
<h2><a class="anchor" id="with_terminal"></a>
With a Terminal</h2>
<p>Inside the SpECTRE repository, make a directory called <code>build</code>. This is where all the compiled objects will go. <code>cd</code> into the <code>build</code> directory. To configure SpECTRE in Release mode (which is recommended for running simulations), run the following command</p>
<div class="fragment"><div class="line">cmake -D CMAKE_BUILD_TYPE=Release \</div>
<div class="line">      -D CHARM_ROOT=/work/charm_7_0_0/multicore-linux-x86_64-clang \</div>
<div class="line">      -D CMAKE_CXX_COMPILER=/usr/bin/clang++-10 \</div>
<div class="line">      -D CMAKE_C_COMPILER=/usr/bin/clang-10 ../</div>
</div><!-- fragment --><p><a href="http://charmplusplus.org/">Charm++</a> is the library we use for task-based parallelism. The <code>../</code> is the path to the root of the SpECTRE directory (relative or absolute, it doesn't matter). This should only take a few seconds to run.</p>
<p>Now that everything is configured, you can build the <code>ExportTimeDependentCoordinates3D</code> executable like so</p>
<div class="fragment"><div class="line">make ExportTimeDependentCoordinates3D -jN</div>
</div><!-- fragment --><p>Here, <code>N</code> is the number of cores you'd like to use to build. It's entirely up to you on how many you'd like to use. Since you are most likely running this on a laptop, <code>-j4</code> should be sufficient.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
With VSCode</h2>
<p>If you are using VScode, open the <a href="https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette">command palette</a> and run the following commands:</p>
<ol type="1">
<li><code>CMake: Select a Kit</code> - Select the <code>Default</code> kit</li>
<li><code>CMake: Select Variant</code> - Select the <code>Release</code> variant to make the code run faster.</li>
<li><code>CMake: Configure</code> - This will create a build directory called <code>build-Default-Release</code> and run an appropriate <code>cmake</code> command for you automatically.</li>
<li><code>CMake: Build Target</code> - Select the <code>ExportTimeDependentCoordinates3D</code> executable.</li>
</ol>
<p>This will most likely use all the cores on your laptop to build the executable. If configuring and building with VSCode doesn't work, just open a terminal and do it manually as in the <a class="el" href="beginners_guide.html#with_terminal">With a Terminal</a> section.</p>
<p>Once the executable is built, you're ready to run it!</p>
<h1><a class="anchor" id="autotoc_md30"></a>
Running ExportTimeDependentCoordinates3D</h1>
<p>To run an executable that you built inside the container, you must remain inside the container. Make a directory <code>runs</code> inside your build directory where you will run everything. Copy over the input file <code>tests/InputFiles/ExportCoordinates/InputTimeDependent3D.yaml</code> into your <code>runs</code> directory. We will be visualizing the coordinates of a binary black hole domain. To run the executable, do</p>
<div class="fragment"><div class="line">../bin/ExportTimeDependentCoordinates3D --input-file InputTimeDependent3D.yaml</div>
</div><!-- fragment --><p>This will run it on one core. If you'd like to use more cores, add the <code>++ppn N</code> option where, again, <code>N</code> is the number of cores. After this finishes you should see two <code>H5</code> files in your run directory:</p>
<ol type="1">
<li>ExportTimeDependentCoordinates3DVolume0</li>
<li>ExportTimeDependentCoordinates3DReductions</li>
</ol>
<p>The <code>Volume</code> file is where we store data from every element in our domain, like the coordinates or the metric. The <code>Reductions</code> file is for more global quantities like the minimum grid spacing over all the elements in our domain.</p>
<dl class="section note"><dt>Note</dt><dd>Next time you run the executable, you will have to either move or delete the existing <code>H5</code> files as SpECTRE will error if it detects that an output file already exists. This is to prevent you from accidentally overwriting data.</dd></dl>
<h1><a class="anchor" id="autotoc_md31"></a>
Visualizing our BBH Coordinates</h1>
<p>Now it's time to use Paraview to visualize the coordinates we use for our BBH evolutions! SpECTRE will actually export the physical frame coordinates for every executable we have because they are a really useful diagnostic to have. We are just using the ExportCoordinates executable here so that you don't have to run a BBH evolution on your laptop which probably wouldn't work because of memory requirements.</p>
<p>Before we get to Paraview, we have to tell paraview how to actually use the coordinates in the <code>Volume</code> <code>H5</code> file. To do this we have an executable called <code>GenerateXdmf</code> which is automatically built whenever you build an executable (it's just a python script so it isn't really built). Inside the <code>runs</code> directory where you have the <code>H5</code> files, run</p>
<div class="fragment"><div class="line">../bin/GenerateXdmf \</div>
<div class="line">  --file-prefix ExportTimeDependentCoordinates3DVolume \</div>
<div class="line">  --subfile-name element_data --output BBH_Coords</div>
</div><!-- fragment --><p>The <code>--file-prefix</code> argument must be whatever is before the number <code>0</code> in the name of your <code>Volume</code> file. We output volume data per node so we append the node number to each volume file we have. Since you're most likely running on a laptop, you'll only be running on one node so you should only get one output file for the volume. The <code>--subfile-name</code> argument is the group name inside the <code>H5</code> file where the data is stored (groups can be checked by <code>h5ls -r FILE_NAME</code>). <code>GenerateXdmf</code> will generate a file called <code>BBH_Coords.xmf</code>. Make sure to keep this <code>.xmf</code> file next to the volume file it was generated from. It uses relative paths to find the volume file which means if you move it, you won't be able to visualize anything.</p>
<p>Now you can open a Paraview window outside of the Docker container. We don't have Paraview in the container and even if we did, it would be difficult to open a GUI via a container. Open the <code>BBH_Coords.xmf</code> file you just generated inside Paraview. You may be prompted to choose which XDMF reader to use. Choose the <code>XDMF Reader</code> option. The <code>Xdmf3</code> options won't work. Once you choose a reader, on the left, you'll see</p>
<div class="image">
<img src="beginners_paraview_left.png" alt=""/>
<div class="caption">
Paraview side-bar</div></div>
<p>You can uncheck all the boxes in the <code>Point Arrays</code> section as they aren't necessary for visualizing the coordinates. Then hit <code>Apply</code>. Now you should see a solid sphere. This isn't super helpful. In the top bar you should see a dropdown to change the style that the points are plotted in. Select <code>Surface With Edges</code> like so. (Note: Your top bar may look slightly different from this depending on what version of <code>Paraview</code> you have.)</p>
<div class="image">
<img src="beginners_paraview_top.png" alt=""/>
<div class="caption">
Paraview top-bar</div></div>
<p>Now you'll have a solid sphere with highlighted lines. To view the interior of the domain, you'll need to add a filter. Probably the two most helpful filters for viewing the domain are the <code>Slice</code> and <code>Clip</code> filters. (Note that you'll have to choose the <code>Surface With Edges</code> option for each filter separately.)</p>
<p><code>Slice</code> is fairly self explanatory in that it will show you a single plane through the domain. Experiment with different planes to see our whole domain structure!</p>
<p>The <code>Clip</code> filter will remove all points "above" a certain plane, where "above" is in the direction of the normal of that plane. If you combine two orthogonal <code>Clip</code>s, you can actually view a 3D wedge of our domain. Try moving the centers of the planes to view the domain around our excision surfaces! They have a lot of cool structure.</p>
<p>If you'd like to read more about our BBH domain, you can look at the documentation for <code><a class="el" href="classdomain_1_1creators_1_1BinaryCompactObject.html" title="A general domain for two compact objects.">domain::creators::BinaryCompactObject</a></code>.</p>
<h1><a class="anchor" id="autotoc_md32"></a>
Make a Movie of BBH Coordinates</h1>
<p>Now that you are able to export and visualize our BBH domain coordinates at a single time, let's make a small movie of the coordinates as they evolve! To do this, we'll need to edit the input file <code>InputTimeDependent3D.yaml</code>. If you aren't familiar with YAML, it's a file type that uses key-value pairs to create actual objects in our C++ code. Feel free to experiment with keys and values in our input files. If you're unsure about what a key or value should be, we offer an easy way to check the options in the input file without running a whole simulation. If you run</p>
<div class="fragment"><div class="line">../bin/ExportTimeDependentCoordinates3D \</div>
<div class="line">  --input-file InputTimeDependent3D.yaml --check-options</div>
</div><!-- fragment --><p>the <code>--check-options</code> will tell the executable to parse the input file and exit immediately after. If you made a typo, or added an incorrect key/value, a list of the available keys and their associated values will be printed.</p>
<p>To change the number of times we output the coordinates, we'll need to go to the <code>EventsAndTriggers:</code> block of the input file. This block is mainly where we specify which quantities we want to observe in a simulation or where we "Trigger" a specific "Event" to happen. (For more info on <code>EventsAndTriggers</code>, see the <a class="el" href="tutorial_events_and_triggers.html">Events and triggers</a> tutorial.) Currently in this input file we only have one Trigger/Event pair. The Trigger is <code>TimeCompares:</code> and the Event is <code>Completion</code>. To have the simulation run longer, change the <code>Value:</code> under <code>TimeCompares:</code> to something larger. If you look at the <code>Evolution:</code> block above the <code>EventsAndTriggers:</code> block, you'll see that the initial time step is <code>0.5</code>. The way this executable is set up, the coordinates will be exported every time step. So set the final time <code>Value:</code> under <code>TimeCompares:</code> to some larger multiple of <code>0.5</code> so that you'll have the coordinates at a bunch of different times (a final time of <code>20</code> is reasonable. Depending on how many cores you run on this should take a couple minutes).</p>
<p>Then, run the executable just like you did above (remember to move or delete the existing <code>H5</code> files), run <code>GenerateXdmf</code>, and open it in Paraview and apply some filters of your choice. Now, in the top bar of Paraview, you should see a "Play" button that looks like a sideways triangle (see the second image above). If you click this, Paraview will step through all the timesteps in the output files and you'll be able to see the domain rotate a bit!</p>
<p>Next, we encourage you to play with the other inputs that control how the domain evolves over time. These options are housed in the</p>
<div class="fragment"><div class="line">DomainCreator:</div>
<div class="line">  BinaryCompactObject:</div>
<div class="line">    ...</div>
<div class="line">    TimeDependentMaps:</div>
<div class="line">      ExpansionMap:</div>
<div class="line">        ...</div>
<div class="line">      RotationMap:</div>
<div class="line">        ...</div>
<div class="line">      SizeMap:</div>
<div class="line">        ...</div>
</div><!-- fragment --><p>block of the input file. Since this tutorial is more about running the code, we won't go into too much detail about each option. However, in general:</p>
<ol type="1">
<li><code>ExpansionMap</code> is a global map (all parts of the domain) that controls the separation between the excision surfaces</li>
<li><code>RotationMap</code> is a global map that controls how the excision spheres rotate about each other</li>
<li><code>SizeMap</code> is a local map only around the excision spheres (not in the wave zone) that control the compression of grid points.</li>
</ol>
<p>Play around with these values! You may get an error if you put something that's too unphysical, but this is a fairly consequence-free playground for you to explore so just try a different value.</p>
<p>Once you are happy with the parameters you've chosen you can go to the <code>File &gt; Save Animation</code> menu and export your movie! There are a lot of options you can choose here, so if you aren't familiar with Paraview just use the defaults. Otherwise you can speed up the movie or slow it down.</p>
<p>Now you have a movie of how BBH coordinates evolve in a SpECTRE simulation!</p>
<h1><a class="anchor" id="autotoc_md33"></a>
Exploring DG+FD</h1>
<p>Now that you are able to build, run, and visualize SpECTRE, let's explore a feature that is fairly unique to SpECTRE and is really powerful for handling discontinuities and shocks in our simulations. We call this feature <code>DG+FD</code> (it's also sometimes referred to as just <code>subcell</code>).</p>
<h2><a class="anchor" id="autotoc_md34"></a>
Description of DG+FD</h2>
<p><code>FD</code> is the usual finite difference you are used to. All of the BSSN codes use finite difference for solving Einstein's equations. FD is very good at capturing shocks and discontinuities and is a very robust method, making it well suited for hydro problems and other systems that have shocks and discontinuities.</p>
<p><code>DG</code> stands for Discontinuous Galerkin. DG is a spectral method for representing a solution on a grid, meaning that instead of taking the difference between the function value at two points to get the derivative, it uses known basis functions to represent the solution. Then the derivative can be known analytically and you only need to supply the coefficients for the basis. DG works best for representing smooth solutions; ones with very few shocks and discontinuities (like GR in vacuum). This makes DG much faster than FD for smooth solutions.</p>
<p>In SpECTRE, we combine these two different methods into one system to take advantage of the strengths of each. When we have a solution that is smooth in some parts of the domain, but has shocks in other parts, using only one of these methods has disadvantages. If we only used DG, we wouldn't be able to resolve the shocks very well driving the errors up a lot. If we only used FD, we'd be able to represent the solution well, but it would be computationally inefficient. So we combine DG+FD so that we only do DG in the parts of the domain where the solution is smooth, and switch to FD in parts where there may be a shock or discontinuity. The algorithm for switching between DG and FD is explained in this image.</p>
<div class="image">
<img src="dg_fd_schematic.png" alt=""/>
<div class="caption">
Scheme for switching between DG and FD (credit: Nils Deppe)</div></div>
<p>If you'd like to learn more about how SpECTRE implements its DG+FD scheme, you can read <a href="https://arxiv.org/abs/2109.11645">the paper</a> on the ArXiv.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
Running the Kuzmin Problem</h2>
<p>To demonstrate DG+FD, we will be evolving the <a class="el" href="classScalarAdvection_1_1Solutions_1_1Kuzmin.html">Kuzmin </a> problem using the <code>EvolveScalarAdvectionKuzmin2D</code> executable. This is a simple test problem that rotates a set of geometric shapes with uniform angular velocity, which can be used to evaluate how well a numerical code can handle discontinuities stably over time. Inside the container build this executable and make a new directory <code>runs2</code> where you will run it. Also copy the default input file in <code>tests/InputFiles/ScalarAdvection/Kuzmin2D.yaml</code> to this new <code>runs2</code> directory.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Changing the Default Input File</h2>
<p>The default input file has very low resolution so we'll need to crank that up a bit. The way to do this is to change the initial refinement levels and initial number of grid points which are located in</p>
<div class="fragment"><div class="line">DomainCreator:</div>
<div class="line">  Rectangle:</div>
<div class="line">    ...</div>
<div class="line">    InitialRefinement: [x, y]</div>
<div class="line">    InitialGridPoints: [x, y]</div>
</div><!-- fragment --><p><code>InitialRefinement:</code> represents how many times we split a <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code> in half in order to create <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s, which are the fundamental units of our domain. So an initial refinement of <code>[1, 1]</code> means we split a single <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> into 4 elements (split in half once in each direction). For an initial refinement of <code>[2, 2]</code> we first do 1 refinement like before, and then split each of the resulting 4 elements in half again in each direction, resulting in 16 total Elements. To determine the total number of Elements for a given refinement (same in all directions), just do \(2^{\mathrm{Dim * Refinement}}\). If you're confused by the terminology we use to describe the domain, we have a <a class="el" href="domain_concepts.html">Domain Concepts</a> guide that explains all terms related to our domain.</p>
<p><code>InitialGridPoints</code> represents the number of grid points per dimension in each <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> after the final refinement has been applied. So if we had an initial refinement of <code>[2, 2]</code> like above and then initial grid points <code>[3, 3]</code> in each <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>, we'd have a total of 9x16=144 grid points.</p>
<p>As for actual numbers to use, you can experiment to see what gives good, well-resolved results. You'll definitely need more refinement than the default input file, but since refinement scales exponentially, this can become very expensive very quickly. On a laptop, you probably shouldn't go higher than refinement <code>[6, 6]</code>. As for grid points, this will depend on how much refinement you have. If you have a ton of small elements, you won't need too many grid points to resolve the solution; something like <code>[4, 4]</code> would work. If you don't have a lot of refinement, you may want more grid points if you still want to resolve your solution. For a DG scheme, increasing the number of grid points (p refinement) reduces the numerical error exponentially where the solution is smooth, so computational resources are used more effectively. However, to resolve shocks and discontinuities we have to refine the domain into more and smaller elements instead (h refinement). Striking the most effective balance between h and p refinement in different parts of the domain is the job of an adaptive mesh refinement (AMR) algorithm.</p>
<p>The default input file only runs for a few time steps so we'll want to make this run longer so we can actually see some evolution. From the documentation of the <a class="el" href="classScalarAdvection_1_1Solutions_1_1Kuzmin.html">Kuzmin </a> system, the solution will rotate with an angular velocity of <code>1.0</code> (in code units). Thus, to do a full orbit, it will take <code>6.28</code> code units of time. In the <code>EventsAndTriggers:</code> block of the input file, we see that the <code>Completion</code> event is triggered by the <code>Slabs</code> trigger. We could, in theory, calculate out how many slabs <code>6.28</code> code units is using the time step, but that's super tedious. Instead let's trigger completion using the <code>TimeCompares</code> trigger instead. We used this before when exporting the BBH coordinates, so just copy over the yaml block and change the <code>Value:</code>.</p>
<p>Your final <code>EventsAndTriggers:</code> block should look something like this:</p>
<div class="fragment"><div class="line">EventsAndTriggers:</div>
<div class="line">  ? TimeCompares:</div>
<div class="line">      Comparison: GreaterThanOrEqualTo</div>
<div class="line">      Value: 6.28</div>
<div class="line">  : - Completion</div>
<div class="line">  ...</div>
</div><!-- fragment --><p>Now you should be ready to run the executable and get some output. Here, you will almost definitely benefit by running this on many cores by adding the <code>++ppn N</code> flag to the command you use to run the executable. Since we use lots of smaller elements, we distribute these over the available resources via a <a class="el" href="structdomain_1_1BlockZCurveProcDistribution.html">space filling curve </a> to speed things up.</p>
<div class="fragment"><div class="line">./EvolveScalarAdvectionKuzmin2D --input-file Kuzmin2D.yaml ++ppn 4</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md37"></a>
Visualizing the Kuzmin Problem</h2>
<p>Once your run finishes, extract the volume data with <code>GenerateXdmf</code> using</p>
<div class="fragment"><div class="line">../bin/GenerateXdmf \</div>
<div class="line">  --file-prefix ScalarAdvectionKuzmin2DVolume \</div>
<div class="line">  --subfile-name VolumeData --output kuzmin_problem</div>
</div><!-- fragment --><p>(Note that the <code>subfile-name</code> is different than before because it was different in the input file) and load it into Paraview once again. We are only interested in the quantity <code>U</code> which is the scalar field we were evolving. You can uncheck any other boxes. So now, instead of coordinates on your screen, you should see a large square colored by the solution profile described in the <a class="el" href="classScalarAdvection_1_1Solutions_1_1Kuzmin.html">Kuzmin </a> system. You should also notice that there are smaller squares that don't touch each other in the middle of the domain and on the edges there are large sections that are continuous. These are the FD and DG grids, respectively. If you go to the top bar in Paraview and change how you view the grid to <code>Surface With Edges</code>, this will become even more apparent.</p>
<p>You will notice that the FD grid is mostly around where the interesting features are in the solution profile; the cylinder with a wedge cut out, the cone, and the hump. And then the DG grid is mostly where the solution should be zero towards the boundary of the domain (i.e. the very smooth part). So right from the start, you can see that we are saving computational effort by only doing the expensive, yet robust, method (FD) where it is necessary and the efficient method (DG) everywhere else where the solution is smooth.</p>
<p>Now hit the "Play" button in the top bar of Paraview and watch the solution evolve. You'll notice that the elements in the domain switch back and forth between FD and DG. They do so in such a way that the elements will switch to FD when an interesting feature enters the element and then switch back to DG once the feature leaves. In this way, we are able to actually track shocks and discontinuities in real time in our solution by where the code switches to using FD instead of DG. This is extremely useful for expensive GRMHD simulations where we only want to do FD at a shock boundary, yet that shock boundary is moving through the domain. We are able to dynamically track this shock and resolve it well with FD, then switch back to DG after the shock passes through and the solution has settled down again.</p>
<p>A pretty cool filter you can add is <code>Warp By Scalar</code>. In the left panel, choose the solution variable <code>U</code> as the scalar to use and hit <code>Apply</code>. In the viewing panel there should be a <code>2D</code> or <code>3D</code> button that you can toggle to make the view 3D. Once you do that you should be able to see that the height of the feature is your solution <code>U</code>. If you change the grid to <code>Surface With Edges</code> you can see the FD or DG grids warp with the solution. And if you hit "Play" it'll rotate around and you'll see the features moving in 3D! (Don't worry if you can't find this filter. Not all versions of Paraview may have it.)</p>
<p>We encourage you to play around with the refinement and grid points before the next section to get a feel for how each changes the runtime and accuracy of solution.</p>
<h1><a class="anchor" id="autotoc_md38"></a>
Editing the Kuzmin System</h1>
<p>Hopefully now you feel comfortable enough building and running SpECTRE that you can find an executable, build it, get the default input file and run it. Now we are going to try our hand at actually editing some code in SpECTRE. We're going to stick with the <a class="el" href="classScalarAdvection_1_1Solutions_1_1Kuzmin.html">Kuzmin </a> system and add a new feature to the solution profile!</p>
<p>You can find the files for the Kuzmin system at <code>src/PointwiseFunctions/AnalyticSolutions/ScalarAdvection/Kuzmin.?pp</code>. In the <code>hpp</code> file, you'll see a lot of Doxygen documentation and then the actual Kuzmin class. The only function that you will need to care about is</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</div>
<div class="line"><a class="code" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt;ScalarAdvection::Tags::U&gt;</a> variables(</div>
<div class="line">    <span class="keyword">const</span> tnsr::I&lt;DataType, 2&gt;&amp; x, <span class="keywordtype">double</span> t,</div>
<div class="line">    tmpl::list&lt;ScalarAdvection::Tags::U&gt; <span class="comment">/*meta*/</span>) <span class="keyword">const</span>;</div>
<div class="ttc" id="aclasstuples_1_1TaggedTuple_html"><div class="ttname"><a href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a></div><div class="ttdoc">An associative container that is indexed by structs.</div><div class="ttdef"><b>Definition:</b> TaggedTuple.hpp:259</div></div>
</div><!-- fragment --><p>All of our analytic solutions have a function similar to this that will set the value corresponding to the tag in the return type. If you're unfamiliar with tags in SpECTRE, you can look at these sections for an explanation, <a class="el" href="databox_foundations.html#databox_a_taggedtuple_databox">A TaggedTuple DataBox</a> and <a class="el" href="databox_foundations.html#databox_a_proper_databox">SpECTRE's DataBox</a>. However, it's basically just a fancy way of doing a compile-time key/value pair. The tag is the key, and the value is whatever you want it to be. In our case, the value is a tensor, representing the solution.</p>
<p>The definition of this function in the <code>cpp</code> file is where you will be editing the actual Kuzmin solution. Towards the bottom of this function, there is a <code>for</code> loop that sets the solution at every grid point. This is where you will add in a new feature to the solution.</p>
<p>You can pick any feature you want to add, so long as it's inside the domain bounds of <code>[0,1]x[0,1]</code> and centered around <code>(0.75, 0.5)</code>. This is because of how the kuzmin solution is set up with existing features at <code>(0.25, 0.5); (0.5, 0.25); (0.5, 0.75)</code>. If you're having trouble thinking of a feature to add try one of the following features:</p>
<ul>
<li>Square centered at <code>(0.75, 0.5)</code> with solution value <code>1.0</code><ul>
<li>Side length <code>0.1</code> (any larger and it might interfere with the other features)</li>
<li>Circle of radius <code>0.045</code> centered on the square with value <code>0.0</code></li>
</ul>
</li>
<li>Triangle centered at <code>(0.75, 0.5)</code> with one corner facing in the <code>+x</code> direction with solution value <code>1.0</code></li>
<li>Square centered at <code>(0.75, 0.5)</code><ul>
<li>Side length <code>0.1</code> (any larger and it might interfere with the other features)</li>
<li>Left half of the square has value <code>1.0</code> and right half of the square has value <code>0.5</code></li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The more detailed you make your feature, the more resolution you will need to resolve it.</dd></dl>
<p>Once you have your feature coded up, go ahead and save your changes (and commit them!), rebuild the Kuzmin executable, and run it! Hopefully everything works and you get some output. When you plot it in Paraview, it should look almost the same as before except your feature will be there too rotating with the others! How cool! You can also see if your feature needs FD or DG more by how much it switches back and forth.</p>
<p>Experiment some more with either different features or different resolution!</p>
<h1><a class="anchor" id="autotoc_md39"></a>
Conclusions</h1>
<p>Congrats! You've made it through the tutorial! If you only want to run our executables, you have all the tools necessary to build, run, and visualize whatever you want. If you want a full list of our executables, do <code>make list</code> in the build directory. This will also include our <code>Test_</code> executables which you can just ignore. Running an executable with the <code>--help</code> flag will give a description of what system is being evolved and the input options necessary. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">User Tutorials</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
