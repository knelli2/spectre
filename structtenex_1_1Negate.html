<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.1"/>
  <title>SpECTRE: tenex::Negate&lt; T &gt; Struct Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.08.01</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structtenex_1_1Negate.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structtenex_1_1Negate-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tenex::Negate&lt; T &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__TensorExpressionsGroup.html">Tensor Expressions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines the tensor expression representing the negation of a tensor expression.  
 <a href="structtenex_1_1Negate.html#details">More...</a></p>

<p><code>#include &lt;Negate.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac9e51af702d0fd62f68b4c37bb8ca008"><td class="memItemLeft" align="right" valign="top"><a id="ac9e51af702d0fd62f68b4c37bb8ca008"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#ac9e51af702d0fd62f68b4c37bb8ca008">type</a> = typename T::type</td></tr>
<tr class="memdesc:ac9e51af702d0fd62f68b4c37bb8ca008"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the data being stored in the result of the expression. <br /></td></tr>
<tr class="separator:ac9e51af702d0fd62f68b4c37bb8ca008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a03c5480b3dbccc4e6a63cb48d5212"><td class="memItemLeft" align="right" valign="top"><a id="ab1a03c5480b3dbccc4e6a63cb48d5212"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#ab1a03c5480b3dbccc4e6a63cb48d5212">symmetry</a> = typename T::symmetry</td></tr>
<tr class="memdesc:ab1a03c5480b3dbccc4e6a63cb48d5212"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the result of the expression. <br /></td></tr>
<tr class="separator:ab1a03c5480b3dbccc4e6a63cb48d5212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d5503d6dff095987c5ddcd53ec329e"><td class="memItemLeft" align="right" valign="top"><a id="ab3d5503d6dff095987c5ddcd53ec329e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#ab3d5503d6dff095987c5ddcd53ec329e">index_list</a> = typename T::index_list</td></tr>
<tr class="memdesc:ab3d5503d6dff095987c5ddcd53ec329e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s of the result of the expression. <br /></td></tr>
<tr class="separator:ab3d5503d6dff095987c5ddcd53ec329e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd1311392c8353b9c6ddf6e8acadfff"><td class="memItemLeft" align="right" valign="top"><a id="a9bd1311392c8353b9c6ddf6e8acadfff"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#a9bd1311392c8353b9c6ddf6e8acadfff">args_list</a> = typename T::args_list</td></tr>
<tr class="memdesc:a9bd1311392c8353b9c6ddf6e8acadfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of generic <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s of the result of the expression. <br /></td></tr>
<tr class="separator:a9bd1311392c8353b9c6ddf6e8acadfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a01107a553dc5eb73452811543845aeb9"><td class="memItemLeft" align="right" valign="top"><a id="a01107a553dc5eb73452811543845aeb9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Negate</b> (T t)</td></tr>
<tr class="separator:a01107a553dc5eb73452811543845aeb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3772db62f5d9d08ffb634e04db41dee0"><td class="memTemplParams" colspan="2"><a id="a3772db62f5d9d08ffb634e04db41dee0"></a>
template&lt;typename LhsTensor &gt; </td></tr>
<tr class="memitem:a3772db62f5d9d08ffb634e04db41dee0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#a3772db62f5d9d08ffb634e04db41dee0">assert_lhs_tensor_not_in_rhs_expression</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; LhsTensor * &gt; lhs_tensor) const</td></tr>
<tr class="memdesc:a3772db62f5d9d08ffb634e04db41dee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that the LHS tensor of the equation does not also appear in this expression's subtree. <br /></td></tr>
<tr class="separator:a3772db62f5d9d08ffb634e04db41dee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76c2076b2a4b011245ea48983aaebdb"><td class="memTemplParams" colspan="2">template&lt;typename LhsTensorIndices , typename LhsTensor &gt; </td></tr>
<tr class="memitem:ae76c2076b2a4b011245ea48983aaebdb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#ae76c2076b2a4b011245ea48983aaebdb">assert_lhs_tensorindices_same_in_rhs</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; LhsTensor * &gt; lhs_tensor) const</td></tr>
<tr class="memdesc:ae76c2076b2a4b011245ea48983aaebdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that each instance of the LHS tensor in the RHS tensor expression uses the same generic index order that the LHS uses.  <a href="structtenex_1_1Negate.html#ae76c2076b2a4b011245ea48983aaebdb">More...</a><br /></td></tr>
<tr class="separator:ae76c2076b2a4b011245ea48983aaebdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1f542f711c23de63a23a2da2d187f4"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#a2c1f542f711c23de63a23a2da2d187f4">get</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1Negate.html#ab8a3247005dc59d59acf353c54752660">num_tensor_indices</a> &gt; &amp;multi_index) const</td></tr>
<tr class="memdesc:a2c1f542f711c23de63a23a2da2d187f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the component of the negated tensor expression at a given multi-index.  <a href="structtenex_1_1Negate.html#a2c1f542f711c23de63a23a2da2d187f4">More...</a><br /></td></tr>
<tr class="separator:a2c1f542f711c23de63a23a2da2d187f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cd2a852dc1f8c56c46733bd86e4cea"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#a67cd2a852dc1f8c56c46733bd86e4cea">get_primary</a> (const <a class="el" href="structtenex_1_1Negate.html#ac9e51af702d0fd62f68b4c37bb8ca008">type</a> &amp;result_component, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1Negate.html#ab8a3247005dc59d59acf353c54752660">num_tensor_indices</a> &gt; &amp;multi_index) const</td></tr>
<tr class="memdesc:a67cd2a852dc1f8c56c46733bd86e4cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the component of the negated tensor expression at a given multi-index.  <a href="structtenex_1_1Negate.html#a67cd2a852dc1f8c56c46733bd86e4cea">More...</a><br /></td></tr>
<tr class="separator:a67cd2a852dc1f8c56c46733bd86e4cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28688bac4145097e6f296973f2974168"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#a28688bac4145097e6f296973f2974168">evaluate_primary_subtree</a> (<a class="el" href="structtenex_1_1Negate.html#ac9e51af702d0fd62f68b4c37bb8ca008">type</a> &amp;result_component, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1Negate.html#ab8a3247005dc59d59acf353c54752660">num_tensor_indices</a> &gt; &amp;multi_index) const</td></tr>
<tr class="memdesc:a28688bac4145097e6f296973f2974168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successively evaluate the LHS Tensor's result component at each leg in this expression's subtree.  <a href="structtenex_1_1Negate.html#a28688bac4145097e6f296973f2974168">More...</a><br /></td></tr>
<tr class="separator:a28688bac4145097e6f296973f2974168"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab8a3247005dc59d59acf353c54752660"><td class="memItemLeft" align="right" valign="top"><a id="ab8a3247005dc59d59acf353c54752660"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#ab8a3247005dc59d59acf353c54752660">num_tensor_indices</a> = tmpl::size&lt;<a class="el" href="structtenex_1_1Negate.html#ab3d5503d6dff095987c5ddcd53ec329e">index_list</a>&gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a></td></tr>
<tr class="memdesc:ab8a3247005dc59d59acf353c54752660"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of tensor indices in the result of the expression. <br /></td></tr>
<tr class="separator:ab8a3247005dc59d59acf353c54752660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f9b9958e17f7d9cfc23401f49b39c6"><td class="memItemLeft" align="right" valign="top"><a id="a11f9b9958e17f7d9cfc23401f49b39c6"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#a11f9b9958e17f7d9cfc23401f49b39c6">num_ops_left_child</a> = T::num_ops_subtree</td></tr>
<tr class="memdesc:a11f9b9958e17f7d9cfc23401f49b39c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of arithmetic tensor operations done in the subtree for the left operand. <br /></td></tr>
<tr class="separator:a11f9b9958e17f7d9cfc23401f49b39c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a818026f352287b0f38012acdb18223"><td class="memItemLeft" align="right" valign="top"><a id="a7a818026f352287b0f38012acdb18223"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#a7a818026f352287b0f38012acdb18223">num_ops_right_child</a> = 0</td></tr>
<tr class="memdesc:a7a818026f352287b0f38012acdb18223"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of arithmetic tensor operations done in the subtree for the right operand. This is 0 because this expression represents a unary operation. <br /></td></tr>
<tr class="separator:a7a818026f352287b0f38012acdb18223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01da336500afe94519c58ec760614f8"><td class="memItemLeft" align="right" valign="top"><a id="ac01da336500afe94519c58ec760614f8"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#ac01da336500afe94519c58ec760614f8">num_ops_subtree</a> = <a class="el" href="structtenex_1_1Negate.html#a11f9b9958e17f7d9cfc23401f49b39c6">num_ops_left_child</a> + 1</td></tr>
<tr class="memdesc:ac01da336500afe94519c58ec760614f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of arithmetic tensor operations done in this expression's whole subtree. <br /></td></tr>
<tr class="separator:ac01da336500afe94519c58ec760614f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6b306d23b4b7f2c6ab62ba0be3f14c"><td class="memItemLeft" align="right" valign="top"><a id="a4e6b306d23b4b7f2c6ab62ba0be3f14c"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#a4e6b306d23b4b7f2c6ab62ba0be3f14c">is_primary_end</a> = T::is_primary_start</td></tr>
<tr class="memdesc:a4e6b306d23b4b7f2c6ab62ba0be3f14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, whether or not the expression is an ending point of a leg. <br /></td></tr>
<tr class="separator:a4e6b306d23b4b7f2c6ab62ba0be3f14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44c5921a17a37327a1504a610584866"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#ac44c5921a17a37327a1504a610584866">num_ops_to_evaluate_primary_left_child</a></td></tr>
<tr class="memdesc:ac44c5921a17a37327a1504a610584866"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done in the subtree of the child along the primary path, given that we will have already computed the whole subtree at the next lowest leg's starting point.  <a href="structtenex_1_1Negate.html#ac44c5921a17a37327a1504a610584866">More...</a><br /></td></tr>
<tr class="separator:ac44c5921a17a37327a1504a610584866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa792bbd8191953464618cdda48dea0a"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#aaa792bbd8191953464618cdda48dea0a">num_ops_to_evaluate_primary_right_child</a></td></tr>
<tr class="memdesc:aaa792bbd8191953464618cdda48dea0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done in the right operand's subtree. No splitting is currently done, so this is just <code>num_ops_right_child</code>.  <a href="structtenex_1_1Negate.html#aaa792bbd8191953464618cdda48dea0a">More...</a><br /></td></tr>
<tr class="separator:aaa792bbd8191953464618cdda48dea0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada79337149c97d0e421f33fdfd5ffa94"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#ada79337149c97d0e421f33fdfd5ffa94">num_ops_to_evaluate_primary_subtree</a></td></tr>
<tr class="memdesc:ada79337149c97d0e421f33fdfd5ffa94"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done for this expression's subtree, given that we will have already computed the subtree at the next lowest leg's starting point.  <a href="structtenex_1_1Negate.html#ada79337149c97d0e421f33fdfd5ffa94">More...</a><br /></td></tr>
<tr class="separator:ada79337149c97d0e421f33fdfd5ffa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c14453d477afef0a5077973d159be8b"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#a5c14453d477afef0a5077973d159be8b">is_primary_start</a></td></tr>
<tr class="memdesc:a5c14453d477afef0a5077973d159be8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, whether or not the expression is a starting point of a leg.  <a href="structtenex_1_1Negate.html#a5c14453d477afef0a5077973d159be8b">More...</a><br /></td></tr>
<tr class="separator:a5c14453d477afef0a5077973d159be8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44e351ba804285a5c0446fcd7f304da"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#aa44e351ba804285a5c0446fcd7f304da">primary_child_subtree_contains_primary_start</a></td></tr>
<tr class="memdesc:aa44e351ba804285a5c0446fcd7f304da"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, whether or not the expression's child along the primary path is a subtree that contains a starting point of a leg along the primary path.  <a href="structtenex_1_1Negate.html#aa44e351ba804285a5c0446fcd7f304da">More...</a><br /></td></tr>
<tr class="separator:aa44e351ba804285a5c0446fcd7f304da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ad5726b6723941411a3904d04da32f"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtenex_1_1Negate.html#a94ad5726b6723941411a3904d04da32f">primary_subtree_contains_primary_start</a></td></tr>
<tr class="memdesc:a94ad5726b6723941411a3904d04da32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If on the primary path, whether or not this subtree contains a starting point of a leg along the primary path.  <a href="structtenex_1_1Negate.html#a94ad5726b6723941411a3904d04da32f">More...</a><br /></td></tr>
<tr class="separator:a94ad5726b6723941411a3904d04da32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct tenex::Negate&lt; T &gt;</h3>

<p>Defines the tensor expression representing the negation of a tensor expression. </p>
<h3>Details</h3>
<p>For details on aliases and members defined in this class, as well as general <code>TensorExpression</code> terminology used in its members' documentation, see documentation for <code>TensorExpression</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of tensor expression being negated </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae76c2076b2a4b011245ea48983aaebdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76c2076b2a4b011245ea48983aaebdb">&#9670;&nbsp;</a></span>assert_lhs_tensorindices_same_in_rhs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename LhsTensorIndices , typename LhsTensor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structtenex_1_1Negate.html">tenex::Negate</a>&lt; T &gt;::assert_lhs_tensorindices_same_in_rhs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; LhsTensor * &gt;&#160;</td>
          <td class="paramname"><em>lhs_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assert that each instance of the LHS tensor in the RHS tensor expression uses the same generic index order that the LHS uses. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsTensorIndices</td><td>the list of generic <code><a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a></code>s of the LHS result <code>Tensor</code> being computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs_tensor</td><td>the LHS result <code>Tensor</code> being computed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28688bac4145097e6f296973f2974168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28688bac4145097e6f296973f2974168">&#9670;&nbsp;</a></span>evaluate_primary_subtree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structtenex_1_1Negate.html">tenex::Negate</a>&lt; T &gt;::evaluate_primary_subtree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtenex_1_1Negate.html#ac9e51af702d0fd62f68b4c37bb8ca008">type</a> &amp;&#160;</td>
          <td class="paramname"><em>result_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1Negate.html#ab8a3247005dc59d59acf353c54752660">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multi_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Successively evaluate the LHS Tensor's result component at each leg in this expression's subtree. </p>
<h3>Details</h3>
<p>This function takes into account whether we have already computed part of the result component at a lower subtree. In recursively computing this negation, the current result component will be substituted in for the most recent (highest) subtree below it that has already been evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result_component</td><td>the LHS tensor component to evaluate </td></tr>
    <tr><td class="paramname">multi_index</td><td>the multi-index of the component of the result tensor to evaluate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c1f542f711c23de63a23a2da2d187f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1f542f711c23de63a23a2da2d187f4">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="structtenex_1_1Negate.html">tenex::Negate</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1Negate.html#ab8a3247005dc59d59acf353c54752660">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multi_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the component of the negated tensor expression at a given multi-index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multi_index</td><td>the multi-index of the component to retrieve from the negated tensor expression </td></tr>
  </table>
  </dd>
</dl>
<p><em>Returns:</em> the value of the component at <code>multi_index</code> in the negated tensor expression </p>

</div>
</div>
<a id="a67cd2a852dc1f8c56c46733bd86e4cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cd2a852dc1f8c56c46733bd86e4cea">&#9670;&nbsp;</a></span>get_primary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="structtenex_1_1Negate.html">tenex::Negate</a>&lt; T &gt;::get_primary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtenex_1_1Negate.html#ac9e51af702d0fd62f68b4c37bb8ca008">type</a> &amp;&#160;</td>
          <td class="paramname"><em>result_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="structtenex_1_1Negate.html#ab8a3247005dc59d59acf353c54752660">num_tensor_indices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multi_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the component of the negated tensor expression at a given multi-index. </p>
<h3>Details</h3>
<p>This function differs from <code>get</code> in that it takes into account whether we have already computed part of the result component at a lower subtree. In recursively computing this negation, the current result component will be substituted in for the most recent (highest) subtree below it that has already been evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result_component</td><td>the LHS tensor component to evaluate </td></tr>
    <tr><td class="paramname">multi_index</td><td>the multi-index of the component to retrieve from the negated tensor expression </td></tr>
  </table>
  </dd>
</dl>
<p><em>Returns:</em> the value of the component at <code>multi_index</code> in the negated tensor expression </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5c14453d477afef0a5077973d159be8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c14453d477afef0a5077973d159be8b">&#9670;&nbsp;</a></span>is_primary_start</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structtenex_1_1Negate.html">tenex::Negate</a>&lt; T &gt;::is_primary_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code" href="structtenex_1_1Negate.html#ada79337149c97d0e421f33fdfd5ffa94">num_ops_to_evaluate_primary_subtree</a> &gt;=</div>
<div class="line">      detail::max_num_ops_in_sub_expression&lt;type&gt;</div>
<div class="ttc" id="astructtenex_1_1Negate_html_ada79337149c97d0e421f33fdfd5ffa94"><div class="ttname"><a href="structtenex_1_1Negate.html#ada79337149c97d0e421f33fdfd5ffa94">tenex::Negate::num_ops_to_evaluate_primary_subtree</a></div><div class="ttdeci">static constexpr size_t num_ops_to_evaluate_primary_subtree</div><div class="ttdoc">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be ...</div><div class="ttdef"><b>Definition:</b> Negate.hpp:80</div></div>
</div><!-- fragment -->
<p>If on the primary path, whether or not the expression is a starting point of a leg. </p>

</div>
</div>
<a id="ac44c5921a17a37327a1504a610584866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44c5921a17a37327a1504a610584866">&#9670;&nbsp;</a></span>num_ops_to_evaluate_primary_left_child</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1Negate.html">tenex::Negate</a>&lt; T &gt;::num_ops_to_evaluate_primary_left_child</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code" href="structtenex_1_1Negate.html#a4e6b306d23b4b7f2c6ab62ba0be3f14c">is_primary_end</a> ? 0 : T::num_ops_to_evaluate_primary_subtree</div>
<div class="ttc" id="astructtenex_1_1Negate_html_a4e6b306d23b4b7f2c6ab62ba0be3f14c"><div class="ttname"><a href="structtenex_1_1Negate.html#a4e6b306d23b4b7f2c6ab62ba0be3f14c">tenex::Negate::is_primary_end</a></div><div class="ttdeci">static constexpr bool is_primary_end</div><div class="ttdoc">If on the primary path, whether or not the expression is an ending point of a leg.</div><div class="ttdef"><b>Definition:</b> Negate.hpp:64</div></div>
</div><!-- fragment -->
<p>If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done in the subtree of the child along the primary path, given that we will have already computed the whole subtree at the next lowest leg's starting point. </p>

</div>
</div>
<a id="aaa792bbd8191953464618cdda48dea0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa792bbd8191953464618cdda48dea0a">&#9670;&nbsp;</a></span>num_ops_to_evaluate_primary_right_child</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1Negate.html">tenex::Negate</a>&lt; T &gt;::num_ops_to_evaluate_primary_right_child</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code" href="structtenex_1_1Negate.html#a7a818026f352287b0f38012acdb18223">num_ops_right_child</a></div>
<div class="ttc" id="astructtenex_1_1Negate_html_a7a818026f352287b0f38012acdb18223"><div class="ttname"><a href="structtenex_1_1Negate.html#a7a818026f352287b0f38012acdb18223">tenex::Negate::num_ops_right_child</a></div><div class="ttdeci">static constexpr size_t num_ops_right_child</div><div class="ttdoc">The number of arithmetic tensor operations done in the subtree for the right operand....</div><div class="ttdef"><b>Definition:</b> Negate.hpp:53</div></div>
</div><!-- fragment -->
<p>If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done in the right operand's subtree. No splitting is currently done, so this is just <code>num_ops_right_child</code>. </p>

</div>
</div>
<a id="ada79337149c97d0e421f33fdfd5ffa94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada79337149c97d0e421f33fdfd5ffa94">&#9670;&nbsp;</a></span>num_ops_to_evaluate_primary_subtree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structtenex_1_1Negate.html">tenex::Negate</a>&lt; T &gt;::num_ops_to_evaluate_primary_subtree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code" href="structtenex_1_1Negate.html#ac44c5921a17a37327a1504a610584866">num_ops_to_evaluate_primary_left_child</a> +</div>
<div class="line">      <a class="code" href="structtenex_1_1Negate.html#aaa792bbd8191953464618cdda48dea0a">num_ops_to_evaluate_primary_right_child</a> + 1</div>
<div class="ttc" id="astructtenex_1_1Negate_html_aaa792bbd8191953464618cdda48dea0a"><div class="ttname"><a href="structtenex_1_1Negate.html#aaa792bbd8191953464618cdda48dea0a">tenex::Negate::num_ops_to_evaluate_primary_right_child</a></div><div class="ttdeci">static constexpr size_t num_ops_to_evaluate_primary_right_child</div><div class="ttdoc">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be ...</div><div class="ttdef"><b>Definition:</b> Negate.hpp:74</div></div>
<div class="ttc" id="astructtenex_1_1Negate_html_ac44c5921a17a37327a1504a610584866"><div class="ttname"><a href="structtenex_1_1Negate.html#ac44c5921a17a37327a1504a610584866">tenex::Negate::num_ops_to_evaluate_primary_left_child</a></div><div class="ttdeci">static constexpr size_t num_ops_to_evaluate_primary_left_child</div><div class="ttdoc">If on the primary path, this is the remaining number of arithmetic tensor operations that need to be ...</div><div class="ttdef"><b>Definition:</b> Negate.hpp:69</div></div>
</div><!-- fragment -->
<p>If on the primary path, this is the remaining number of arithmetic tensor operations that need to be done for this expression's subtree, given that we will have already computed the subtree at the next lowest leg's starting point. </p>

</div>
</div>
<a id="aa44e351ba804285a5c0446fcd7f304da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44e351ba804285a5c0446fcd7f304da">&#9670;&nbsp;</a></span>primary_child_subtree_contains_primary_start</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structtenex_1_1Negate.html">tenex::Negate</a>&lt; T &gt;::primary_child_subtree_contains_primary_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      T::primary_subtree_contains_primary_start</div>
</div><!-- fragment -->
<p>If on the primary path, whether or not the expression's child along the primary path is a subtree that contains a starting point of a leg along the primary path. </p>

</div>
</div>
<a id="a94ad5726b6723941411a3904d04da32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ad5726b6723941411a3904d04da32f">&#9670;&nbsp;</a></span>primary_subtree_contains_primary_start</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structtenex_1_1Negate.html">tenex::Negate</a>&lt; T &gt;::primary_subtree_contains_primary_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <a class="code" href="structtenex_1_1Negate.html#a5c14453d477afef0a5077973d159be8b">is_primary_start</a> or <a class="code" href="structtenex_1_1Negate.html#aa44e351ba804285a5c0446fcd7f304da">primary_child_subtree_contains_primary_start</a></div>
<div class="ttc" id="astructtenex_1_1Negate_html_a5c14453d477afef0a5077973d159be8b"><div class="ttname"><a href="structtenex_1_1Negate.html#a5c14453d477afef0a5077973d159be8b">tenex::Negate::is_primary_start</a></div><div class="ttdeci">static constexpr bool is_primary_start</div><div class="ttdoc">If on the primary path, whether or not the expression is a starting point of a leg.</div><div class="ttdef"><b>Definition:</b> Negate.hpp:85</div></div>
<div class="ttc" id="astructtenex_1_1Negate_html_aa44e351ba804285a5c0446fcd7f304da"><div class="ttname"><a href="structtenex_1_1Negate.html#aa44e351ba804285a5c0446fcd7f304da">tenex::Negate::primary_child_subtree_contains_primary_start</a></div><div class="ttdeci">static constexpr bool primary_child_subtree_contains_primary_start</div><div class="ttdoc">If on the primary path, whether or not the expression's child along the primary path is a subtree tha...</div><div class="ttdef"><b>Definition:</b> Negate.hpp:91</div></div>
</div><!-- fragment -->
<p>If on the primary path, whether or not this subtree contains a starting point of a leg along the primary path. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/DataStructures/Tensor/Expressions/Negate.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetenex.html">tenex</a></li><li class="navelem"><a class="el" href="structtenex_1_1Negate.html">Negate</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
