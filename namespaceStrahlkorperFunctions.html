<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.1"/>
  <title>SpECTRE: StrahlkorperFunctions Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.08.01</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceStrahlkorperFunctions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">StrahlkorperFunctions Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains functions that depend on a <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> but not on a metric.  
<a href="namespaceStrahlkorperFunctions.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:addfdd91170d447b2486a66058af4cdb1"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:addfdd91170d447b2486a66058af4cdb1"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#addfdd91170d447b2486a66058af4cdb1">theta_phi</a> (const ::<a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;strahlkorper)</td></tr>
<tr class="separator:addfdd91170d447b2486a66058af4cdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc9cbe34698cc65b28fecabb79d5aab"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:abbc9cbe34698cc65b28fecabb79d5aab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#abbc9cbe34698cc65b28fecabb79d5aab">theta_phi</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; * &gt; theta_phi, const ::<a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;strahlkorper)</td></tr>
<tr class="separator:abbc9cbe34698cc65b28fecabb79d5aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa3af2842c8ccf53550cb7bc5479ed915"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:aa3af2842c8ccf53550cb7bc5479ed915"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#aa3af2842c8ccf53550cb7bc5479ed915">rhat</a> (const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;<a class="el" href="namespaceStrahlkorperFunctions.html#addfdd91170d447b2486a66058af4cdb1">theta_phi</a>)</td></tr>
<tr class="separator:aa3af2842c8ccf53550cb7bc5479ed915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a8108d0671418def7086f6a80310d6"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:ad4a8108d0671418def7086f6a80310d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#ad4a8108d0671418def7086f6a80310d6">rhat</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; * &gt; r_hat, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;<a class="el" href="namespaceStrahlkorperFunctions.html#addfdd91170d447b2486a66058af4cdb1">theta_phi</a>)</td></tr>
<tr class="separator:ad4a8108d0671418def7086f6a80310d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4b7e539fc4801e4c1bbf51e9bfe3775b"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a4b7e539fc4801e4c1bbf51e9bfe3775b"><td class="memTemplItemLeft" align="right" valign="top">StrahlkorperTags::aliases::Jacobian&lt; Fr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a4b7e539fc4801e4c1bbf51e9bfe3775b">jacobian</a> (const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;<a class="el" href="namespaceStrahlkorperFunctions.html#addfdd91170d447b2486a66058af4cdb1">theta_phi</a>)</td></tr>
<tr class="separator:a4b7e539fc4801e4c1bbf51e9bfe3775b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eae1f2c2e6f35e9c4439b1de8261116"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a7eae1f2c2e6f35e9c4439b1de8261116"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a7eae1f2c2e6f35e9c4439b1de8261116">jacobian</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; StrahlkorperTags::aliases::Jacobian&lt; Fr &gt; * &gt; jac, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;<a class="el" href="namespaceStrahlkorperFunctions.html#addfdd91170d447b2486a66058af4cdb1">theta_phi</a>)</td></tr>
<tr class="separator:a7eae1f2c2e6f35e9c4439b1de8261116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5931c3db1b9e23d998e08c39044ff7b9"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a5931c3db1b9e23d998e08c39044ff7b9"><td class="memTemplItemLeft" align="right" valign="top">StrahlkorperTags::aliases::InvJacobian&lt; Fr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a5931c3db1b9e23d998e08c39044ff7b9">inv_jacobian</a> (const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;<a class="el" href="namespaceStrahlkorperFunctions.html#addfdd91170d447b2486a66058af4cdb1">theta_phi</a>)</td></tr>
<tr class="separator:a5931c3db1b9e23d998e08c39044ff7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8aa86433e067aa4a4f0d3c8f1ba4cad"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:ac8aa86433e067aa4a4f0d3c8f1ba4cad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#ac8aa86433e067aa4a4f0d3c8f1ba4cad">inv_jacobian</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; StrahlkorperTags::aliases::InvJacobian&lt; Fr &gt; * &gt; inv_jac, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;<a class="el" href="namespaceStrahlkorperFunctions.html#addfdd91170d447b2486a66058af4cdb1">theta_phi</a>)</td></tr>
<tr class="separator:ac8aa86433e067aa4a4f0d3c8f1ba4cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab015e044c55d033dc8fc3139d8d8bbc6"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:ab015e044c55d033dc8fc3139d8d8bbc6"><td class="memTemplItemLeft" align="right" valign="top">StrahlkorperTags::aliases::InvHessian&lt; Fr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#ab015e044c55d033dc8fc3139d8d8bbc6">inv_hessian</a> (const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;<a class="el" href="namespaceStrahlkorperFunctions.html#addfdd91170d447b2486a66058af4cdb1">theta_phi</a>)</td></tr>
<tr class="separator:ab015e044c55d033dc8fc3139d8d8bbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fea3cfcbaa0a5c169dcd124453deaf1"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a6fea3cfcbaa0a5c169dcd124453deaf1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a6fea3cfcbaa0a5c169dcd124453deaf1">inv_hessian</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; StrahlkorperTags::aliases::InvHessian&lt; Fr &gt; * &gt; inv_hess, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;<a class="el" href="namespaceStrahlkorperFunctions.html#addfdd91170d447b2486a66058af4cdb1">theta_phi</a>)</td></tr>
<tr class="separator:a6fea3cfcbaa0a5c169dcd124453deaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a11acf67db4c6b89d0c933902a957734b"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a11acf67db4c6b89d0c933902a957734b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">radius</a> (const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;strahlkorper)</td></tr>
<tr class="separator:a11acf67db4c6b89d0c933902a957734b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d372beb8c693b900b7b8d5d1b42737"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a56d372beb8c693b900b7b8d5d1b42737"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a56d372beb8c693b900b7b8d5d1b42737">radius</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; result, const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;strahlkorper)</td></tr>
<tr class="separator:a56d372beb8c693b900b7b8d5d1b42737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3a1fb502b60c5111bdf70f8592d28c59"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a3a1fb502b60c5111bdf70f8592d28c59"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a3a1fb502b60c5111bdf70f8592d28c59">cartesian_coords</a> (const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;strahlkorper, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;<a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">radius</a>, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;r_hat)</td></tr>
<tr class="separator:a3a1fb502b60c5111bdf70f8592d28c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c92b194eb045c89b7fb7a41556e11aa"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a8c92b194eb045c89b7fb7a41556e11aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a8c92b194eb045c89b7fb7a41556e11aa">cartesian_coords</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; * &gt; coords, const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;strahlkorper, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;<a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">radius</a>, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;r_hat)</td></tr>
<tr class="separator:a8c92b194eb045c89b7fb7a41556e11aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1f80e7c3a9ef39a93ede037544e08a33"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a1f80e7c3a9ef39a93ede037544e08a33"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a1f80e7c3a9ef39a93ede037544e08a33">cartesian_derivs_of_scalar</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;scalar, const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;strahlkorper, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;radius_of_strahlkorper, const StrahlkorperTags::aliases::InvJacobian&lt; Fr &gt; &amp;inv_jac)</td></tr>
<tr class="separator:a1f80e7c3a9ef39a93ede037544e08a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a1011459dd7a783c786d96abeb87fb"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:ad7a1011459dd7a783c786d96abeb87fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#ad7a1011459dd7a783c786d96abeb87fb">cartesian_derivs_of_scalar</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; * &gt; dx_scalar, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;scalar, const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;strahlkorper, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;radius_of_strahlkorper, const StrahlkorperTags::aliases::InvJacobian&lt; Fr &gt; &amp;inv_jac)</td></tr>
<tr class="separator:ad7a1011459dd7a783c786d96abeb87fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a314f7f332ca7ac0dbfd1ec148d16b373"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a314f7f332ca7ac0dbfd1ec148d16b373"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a314f7f332ca7ac0dbfd1ec148d16b373">cartesian_second_derivs_of_scalar</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;scalar, const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;strahlkorper, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;radius_of_strahlkorper, const StrahlkorperTags::aliases::InvJacobian&lt; Fr &gt; &amp;inv_jac, const StrahlkorperTags::aliases::InvHessian&lt; Fr &gt; &amp;inv_hess)</td></tr>
<tr class="separator:a314f7f332ca7ac0dbfd1ec148d16b373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa215dc04daf13fc68eca3310683fa9"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a4aa215dc04daf13fc68eca3310683fa9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a4aa215dc04daf13fc68eca3310683fa9">cartesian_second_derivs_of_scalar</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; * &gt; d2x_scalar, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;scalar, const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;strahlkorper, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;radius_of_strahlkorper, const StrahlkorperTags::aliases::InvJacobian&lt; Fr &gt; &amp;inv_jac, const StrahlkorperTags::aliases::InvHessian&lt; Fr &gt; &amp;inv_hess)</td></tr>
<tr class="separator:a4aa215dc04daf13fc68eca3310683fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a57463aa3d253547b7b7938a83a54ec7c"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a57463aa3d253547b7b7938a83a54ec7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a57463aa3d253547b7b7938a83a54ec7c">laplacian_of_scalar</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;scalar, const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;strahlkorper, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;<a class="el" href="namespaceStrahlkorperFunctions.html#addfdd91170d447b2486a66058af4cdb1">theta_phi</a>)</td></tr>
<tr class="separator:a57463aa3d253547b7b7938a83a54ec7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd56f75bd726dbf975bfc3febf7e8fa"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:aabd56f75bd726dbf975bfc3febf7e8fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#aabd56f75bd726dbf975bfc3febf7e8fa">laplacian_of_scalar</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; laplacian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;scalar, const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;strahlkorper, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;<a class="el" href="namespaceStrahlkorperFunctions.html#addfdd91170d447b2486a66058af4cdb1">theta_phi</a>)</td></tr>
<tr class="separator:aabd56f75bd726dbf975bfc3febf7e8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a98d107941ccba2bedeec2a146d5c1aa1"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a98d107941ccba2bedeec2a146d5c1aa1"><td class="memTemplItemLeft" align="right" valign="top">StrahlkorperTags::aliases::Jacobian&lt; Fr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a98d107941ccba2bedeec2a146d5c1aa1">tangents</a> (const ::<a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;strahlkorper, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;<a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">radius</a>, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;r_hat, const StrahlkorperTags::aliases::Jacobian&lt; Fr &gt; &amp;jac)</td></tr>
<tr class="separator:a98d107941ccba2bedeec2a146d5c1aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01bf973fc96da80177664de7579e080"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:ad01bf973fc96da80177664de7579e080"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#ad01bf973fc96da80177664de7579e080">tangents</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; StrahlkorperTags::aliases::Jacobian&lt; Fr &gt; * &gt; result, const ::<a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;strahlkorper, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;<a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">radius</a>, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;r_hat, const StrahlkorperTags::aliases::Jacobian&lt; Fr &gt; &amp;jac)</td></tr>
<tr class="separator:ad01bf973fc96da80177664de7579e080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a39a6733f4645ad74a54445b3ec4a8f40"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a39a6733f4645ad74a54445b3ec4a8f40"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a39a6733f4645ad74a54445b3ec4a8f40">normal_one_form</a> (const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;dx_radius, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;r_hat)</td></tr>
<tr class="separator:a39a6733f4645ad74a54445b3ec4a8f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d87bb35dedd8273f5a18e23ed223e0"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:a94d87bb35dedd8273f5a18e23ed223e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceStrahlkorperFunctions.html#a94d87bb35dedd8273f5a18e23ed223e0">normal_one_form</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; * &gt; one_form, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;dx_radius, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;r_hat)</td></tr>
<tr class="separator:a94d87bb35dedd8273f5a18e23ed223e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains functions that depend on a <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> but not on a metric. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8c92b194eb045c89b7fb7a41556e11aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c92b194eb045c89b7fb7a41556e11aa">&#9670;&nbsp;</a></span>cartesian_coords() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StrahlkorperFunctions::cartesian_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; * &gt;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>strahlkorper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_hat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>The returned Cartesian coordinates. </td></tr>
    <tr><td class="paramname">strahlkorper</td><td>The <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface. </td></tr>
    <tr><td class="paramname">radius</td><td>The radius as a function of angle, as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">StrahlkorperFunctions::radius</a></code>. </td></tr>
    <tr><td class="paramname">r_hat</td><td>The Euclidean radial unit vector as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#aa3af2842c8ccf53550cb7bc5479ed915">StrahlkorperFunctions::rhat</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a1fb502b60c5111bdf70f8592d28c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1fb502b60c5111bdf70f8592d28c59">&#9670;&nbsp;</a></span>cartesian_coords() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::I&lt;<a class="el" href="classDataVector.html">DataVector</a>, 3, Fr&gt; StrahlkorperFunctions::cartesian_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>strahlkorper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_hat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>cartesian_coords(i)</code> is \(x_{\rm surf}^i\), the vector of \((x,y,z)\) coordinates of each point on the <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strahlkorper</td><td>The <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface. </td></tr>
    <tr><td class="paramname">radius</td><td>The radius as a function of angle, as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">StrahlkorperFunctions::radius</a></code>. </td></tr>
    <tr><td class="paramname">r_hat</td><td>The Euclidean radial unit vector as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#aa3af2842c8ccf53550cb7bc5479ed915">StrahlkorperFunctions::rhat</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7a1011459dd7a783c786d96abeb87fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a1011459dd7a783c786d96abeb87fb">&#9670;&nbsp;</a></span>cartesian_derivs_of_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StrahlkorperFunctions::cartesian_derivs_of_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dx_scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>strahlkorper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radius_of_strahlkorper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StrahlkorperTags::aliases::InvJacobian&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_jac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx_scalar</td><td>The returned derivatives of the scalar. </td></tr>
    <tr><td class="paramname">scalar</td><td>The scalar to be differentiated. </td></tr>
    <tr><td class="paramname">strahlkorper</td><td>The <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface. </td></tr>
    <tr><td class="paramname">radius_of_strahlkorper</td><td>The radius of the <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> at each point, as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">StrahlkorperFunctions::radius</a></code>. </td></tr>
    <tr><td class="paramname">inv_jac</td><td>The inverse Jacobian as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#a5931c3db1b9e23d998e08c39044ff7b9">StrahlkorperFunctions::inv_jacobian</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f80e7c3a9ef39a93ede037544e08a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f80e7c3a9ef39a93ede037544e08a33">&#9670;&nbsp;</a></span>cartesian_derivs_of_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt;<a class="el" href="classDataVector.html">DataVector</a>, 3, Fr&gt; StrahlkorperFunctions::cartesian_derivs_of_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>strahlkorper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radius_of_strahlkorper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StrahlkorperTags::aliases::InvJacobian&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_jac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>dx_scalar(i)</code> is \(\partial f/\partial x^i\) evaluated on the surface. Here \(f=f(r,\theta,\phi)=f(\theta,\phi)\) is some scalar function independent of the radial coordinate. \(f\) is considered a function of Cartesian coordinates \(f=f(\theta(x,y,z),\phi(x,y,z))\) for this operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar to be differentiated. </td></tr>
    <tr><td class="paramname">strahlkorper</td><td>The <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface. </td></tr>
    <tr><td class="paramname">radius_of_strahlkorper</td><td>The radius of the <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> at each point, as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">StrahlkorperFunctions::radius</a></code>. </td></tr>
    <tr><td class="paramname">inv_jac</td><td>The inverse Jacobian as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#a5931c3db1b9e23d998e08c39044ff7b9">StrahlkorperFunctions::inv_jacobian</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4aa215dc04daf13fc68eca3310683fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa215dc04daf13fc68eca3310683fa9">&#9670;&nbsp;</a></span>cartesian_second_derivs_of_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StrahlkorperFunctions::cartesian_second_derivs_of_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; * &gt;&#160;</td>
          <td class="paramname"><em>d2x_scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>strahlkorper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radius_of_strahlkorper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StrahlkorperTags::aliases::InvJacobian&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StrahlkorperTags::aliases::InvHessian&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_hess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d2x_scalar</td><td>The returned 2nd derivatives of the scalar. </td></tr>
    <tr><td class="paramname">scalar</td><td>The scalar to be differentiated. </td></tr>
    <tr><td class="paramname">strahlkorper</td><td>The <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface. </td></tr>
    <tr><td class="paramname">radius_of_strahlkorper</td><td>The radius of the <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> at each point, as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">StrahlkorperFunctions::radius</a></code>. </td></tr>
    <tr><td class="paramname">inv_jac</td><td>The inverse Jacobian as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#a5931c3db1b9e23d998e08c39044ff7b9">StrahlkorperFunctions::inv_jacobian</a></code> </td></tr>
    <tr><td class="paramname">inv_hess</td><td>The inverse Hessian as returned by `StrahlkorperFunctions<a class="el" href="namespaceStrahlkorperFunctions.html#ab015e044c55d033dc8fc3139d8d8bbc6">inv_hessian</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a314f7f332ca7ac0dbfd1ec148d16b373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314f7f332ca7ac0dbfd1ec148d16b373">&#9670;&nbsp;</a></span>cartesian_second_derivs_of_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt;<a class="el" href="classDataVector.html">DataVector</a>, 3, Fr&gt; StrahlkorperFunctions::cartesian_second_derivs_of_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>strahlkorper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radius_of_strahlkorper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StrahlkorperTags::aliases::InvJacobian&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StrahlkorperTags::aliases::InvHessian&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_hess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>d2x_scalar(i,j)</code> is \(\partial^2 f/\partial x^i\partial x^j\) evaluated on the surface. Here \(f=f(r,\theta,\phi)=f(\theta,\phi)\) is some scalar function independent of the radial coordinate. \(f\) is considered a function of Cartesian coordinates \(f=f(\theta(x,y,z),\phi(x,y,z))\) for this operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar to be differentiated. </td></tr>
    <tr><td class="paramname">strahlkorper</td><td>The <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface. </td></tr>
    <tr><td class="paramname">radius_of_strahlkorper</td><td>The radius of the <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> at each point, as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">StrahlkorperFunctions::radius</a></code>. </td></tr>
    <tr><td class="paramname">inv_jac</td><td>The inverse Jacobian as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#a5931c3db1b9e23d998e08c39044ff7b9">StrahlkorperFunctions::inv_jacobian</a></code> </td></tr>
    <tr><td class="paramname">inv_hess</td><td>The inverse Hessian as returned by `StrahlkorperFunctions<a class="el" href="namespaceStrahlkorperFunctions.html#ab015e044c55d033dc8fc3139d8d8bbc6">inv_hessian</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fea3cfcbaa0a5c169dcd124453deaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fea3cfcbaa0a5c169dcd124453deaf1">&#9670;&nbsp;</a></span>inv_hessian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StrahlkorperFunctions::inv_hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; StrahlkorperTags::aliases::InvHessian&lt; Fr &gt; * &gt;&#160;</td>
          <td class="paramname"><em>inv_hess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>theta_phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>InvHessian(k,i,j)</code> is \(r\partial (J^{-1}){}^k_j/\partial x^i\), where \((J^{-1}){}^k_j\) is the inverse Jacobian. Here \(r\) means \(\sqrt{x^2+y^2+z^2}\). <code>InvHessian</code> is not symmetric because the Jacobians are Pfaffian. <code>InvHessian</code> doesn't depend on the shape of the surface. </p>

</div>
</div>
<a id="ab015e044c55d033dc8fc3139d8d8bbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab015e044c55d033dc8fc3139d8d8bbc6">&#9670;&nbsp;</a></span>inv_hessian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">StrahlkorperTags::aliases::InvHessian&lt;Fr&gt; StrahlkorperFunctions::inv_hessian </td>
          <td>(</td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>theta_phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>InvHessian(k,i,j)</code> is \(r\partial (J^{-1}){}^k_j/\partial x^i\), where \((J^{-1}){}^k_j\) is the inverse Jacobian. Here \(r\) means \(\sqrt{x^2+y^2+z^2}\). <code>InvHessian</code> is not symmetric because the Jacobians are Pfaffian. <code>InvHessian</code> doesn't depend on the shape of the surface. </p>

</div>
</div>
<a id="ac8aa86433e067aa4a4f0d3c8f1ba4cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8aa86433e067aa4a4f0d3c8f1ba4cad">&#9670;&nbsp;</a></span>inv_jacobian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StrahlkorperFunctions::inv_jacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; StrahlkorperTags::aliases::InvJacobian&lt; Fr &gt; * &gt;&#160;</td>
          <td class="paramname"><em>inv_jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>theta_phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>InvJacobian(0,i)</code> is \(r\partial\theta/\partial x^i\), and <code>InvJacobian(1,i)</code> is \(r\sin\theta\partial\phi/\partial x^i\). Here \(r\) means \(\sqrt{x^2+y^2+z^2}\). <code>InvJacobian</code> doesn't depend on the shape of the surface. </p>

</div>
</div>
<a id="a5931c3db1b9e23d998e08c39044ff7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5931c3db1b9e23d998e08c39044ff7b9">&#9670;&nbsp;</a></span>inv_jacobian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">StrahlkorperTags::aliases::InvJacobian&lt;Fr&gt; StrahlkorperFunctions::inv_jacobian </td>
          <td>(</td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>theta_phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>InvJacobian(0,i)</code> is \(r\partial\theta/\partial x^i\), and <code>InvJacobian(1,i)</code> is \(r\sin\theta\partial\phi/\partial x^i\). Here \(r\) means \(\sqrt{x^2+y^2+z^2}\). <code>InvJacobian</code> doesn't depend on the shape of the surface. </p>

</div>
</div>
<a id="a7eae1f2c2e6f35e9c4439b1de8261116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eae1f2c2e6f35e9c4439b1de8261116">&#9670;&nbsp;</a></span>jacobian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StrahlkorperFunctions::jacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; StrahlkorperTags::aliases::Jacobian&lt; Fr &gt; * &gt;&#160;</td>
          <td class="paramname"><em>jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>theta_phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>Jacobian(i,0)</code> is \(\frac{1}{r}\partial x^i/\partial\theta\), and <code>Jacobian(i,1)</code> is \(\frac{1}{r\sin\theta}\partial x^i/\partial\phi\). Here \(r\) means \(\sqrt{x^2+y^2+z^2}\). <code>Jacobian</code> doesn't depend on the shape of the surface. </p>

</div>
</div>
<a id="a4b7e539fc4801e4c1bbf51e9bfe3775b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7e539fc4801e4c1bbf51e9bfe3775b">&#9670;&nbsp;</a></span>jacobian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">StrahlkorperTags::aliases::Jacobian&lt;Fr&gt; StrahlkorperFunctions::jacobian </td>
          <td>(</td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>theta_phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>Jacobian(i,0)</code> is \(\frac{1}{r}\partial x^i/\partial\theta\), and <code>Jacobian(i,1)</code> is \(\frac{1}{r\sin\theta}\partial x^i/\partial\phi\). Here \(r\) means \(\sqrt{x^2+y^2+z^2}\). <code>Jacobian</code> doesn't depend on the shape of the surface. </p>

</div>
</div>
<a id="aabd56f75bd726dbf975bfc3febf7e8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd56f75bd726dbf975bfc3febf7e8fa">&#9670;&nbsp;</a></span>laplacian_of_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StrahlkorperFunctions::laplacian_of_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>laplacian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>strahlkorper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>theta_phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(\nabla^2 f\), the flat Laplacian of a scalar \(f\) on the surface. This is \(\eta^{ij}\partial^2 f/\partial x^i\partial x^j\), where \(f=f(r,\theta,\phi)=f(\theta,\phi)\) is some scalar function independent of the radial coordinate. \(f\) is considered a function of Cartesian coordinates \(f=f(\theta(x,y,z),\phi(x,y,z))\) for this operation. </p>

</div>
</div>
<a id="a57463aa3d253547b7b7938a83a54ec7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57463aa3d253547b7b7938a83a54ec7c">&#9670;&nbsp;</a></span>laplacian_of_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;<a class="el" href="classDataVector.html">DataVector</a>&gt; StrahlkorperFunctions::laplacian_of_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>strahlkorper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>theta_phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(\nabla^2 f\), the flat Laplacian of a scalar \(f\) on the surface. This is \(\eta^{ij}\partial^2 f/\partial x^i\partial x^j\), where \(f=f(r,\theta,\phi)=f(\theta,\phi)\) is some scalar function independent of the radial coordinate. \(f\) is considered a function of Cartesian coordinates \(f=f(\theta(x,y,z),\phi(x,y,z))\) for this operation. </p>

</div>
</div>
<a id="a94d87bb35dedd8273f5a18e23ed223e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d87bb35dedd8273f5a18e23ed223e0">&#9670;&nbsp;</a></span>normal_one_form() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StrahlkorperFunctions::normal_one_form </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; * &gt;&#160;</td>
          <td class="paramname"><em>one_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>dx_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_hat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">one_form</td><td>The returned normal one form. </td></tr>
    <tr><td class="paramname">dx_radius</td><td>The Cartesian derivatives of the radius, as returned by <a class="el" href="namespaceStrahlkorperFunctions.html#a1f80e7c3a9ef39a93ede037544e08a33">StrahlkorperFunctions::cartesian_derivs_of_scalar</a> with <code><a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">StrahlkorperFunctions::radius</a></code> passed in as the scalar. </td></tr>
    <tr><td class="paramname">r_hat</td><td>The radial unit vector as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#aa3af2842c8ccf53550cb7bc5479ed915">StrahlkorperFunctions::rhat</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39a6733f4645ad74a54445b3ec4a8f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a6733f4645ad74a54445b3ec4a8f40">&#9670;&nbsp;</a></span>normal_one_form() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt;<a class="el" href="classDataVector.html">DataVector</a>, 3, Fr&gt; StrahlkorperFunctions::normal_one_form </td>
          <td>(</td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>dx_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_hat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>normal_one_form(i)</code> is \(s_i\), the (unnormalized) normal one-form to the surface, expressed in Cartesian components. This is computed by \(x_i/r-\partial r_{\rm surf}/\partial x^i\), where \(x_i/r\) is <code>Rhat</code> and \(\partial r_{\rm surf}/\partial x^i\) is <code>DxRadius</code>. See Eq. (8) of <b>[Baumgarte1996hh]</b>. Note on the word "normal": \(s_i\) points in the correct direction (it is "normal" to the surface), but it does not have unit length (it is not "normalized"; normalization requires a metric).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx_radius</td><td>The Cartesian derivatives of the radius, as returned by <a class="el" href="namespaceStrahlkorperFunctions.html#a1f80e7c3a9ef39a93ede037544e08a33">StrahlkorperFunctions::cartesian_derivs_of_scalar</a> with <code><a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">StrahlkorperFunctions::radius</a></code> passed in as the scalar. </td></tr>
    <tr><td class="paramname">r_hat</td><td>The radial unit vector as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#aa3af2842c8ccf53550cb7bc5479ed915">StrahlkorperFunctions::rhat</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56d372beb8c693b900b7b8d5d1b42737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d372beb8c693b900b7b8d5d1b42737">&#9670;&nbsp;</a></span>radius() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StrahlkorperFunctions::radius </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>strahlkorper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Euclidean) distance \(r_{\rm surf}(\theta,\phi)\) from the expansion center to each point of the <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface. </p>

</div>
</div>
<a id="a11acf67db4c6b89d0c933902a957734b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11acf67db4c6b89d0c933902a957734b">&#9670;&nbsp;</a></span>radius() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;<a class="el" href="classDataVector.html">DataVector</a>&gt; StrahlkorperFunctions::radius </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>strahlkorper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Euclidean) distance \(r_{\rm surf}(\theta,\phi)\) from the expansion center to each point of the <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface. </p>

</div>
</div>
<a id="ad4a8108d0671418def7086f6a80310d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a8108d0671418def7086f6a80310d6">&#9670;&nbsp;</a></span>rhat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StrahlkorperFunctions::rhat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; * &gt;&#160;</td>
          <td class="paramname"><em>r_hat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>theta_phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>r_hat(i)</code> is \(\hat{r}_i = x_i/\sqrt{x^2+y^2+z^2}\) on the <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface. Doesn't depend on the shape of the surface.</p>
<p>We need to choose upper vs lower indices for rhat; it doesn't matter because rhat is a quantity defined with a Euclidean metric, so we choose the lower index arbitrarily. </p>

</div>
</div>
<a id="aa3af2842c8ccf53550cb7bc5479ed915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3af2842c8ccf53550cb7bc5479ed915">&#9670;&nbsp;</a></span>rhat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt;<a class="el" href="classDataVector.html">DataVector</a>, 3, Fr&gt; StrahlkorperFunctions::rhat </td>
          <td>(</td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>theta_phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>r_hat(i)</code> is \(\hat{r}_i = x_i/\sqrt{x^2+y^2+z^2}\) on the <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface. Doesn't depend on the shape of the surface.</p>
<p>We need to choose upper vs lower indices for rhat; it doesn't matter because rhat is a quantity defined with a Euclidean metric, so we choose the lower index arbitrarily. </p>

</div>
</div>
<a id="a98d107941ccba2bedeec2a146d5c1aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d107941ccba2bedeec2a146d5c1aa1">&#9670;&nbsp;</a></span>tangents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">StrahlkorperTags::aliases::Jacobian&lt;Fr&gt; StrahlkorperFunctions::tangents </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>strahlkorper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_hat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StrahlkorperTags::aliases::Jacobian&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>jac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>tangents(i,j)</code> is \(\partial x_{\rm surf}^i/\partial q^j\), where \(x_{\rm surf}^i\) are the Cartesian coordinates of the surface (i.e. <code>cartesian_coords</code>) and are considered functions of \((\theta,\phi)\).</p>
<p>\(\partial/\partial q^0\) means \(\partial/\partial\theta\); and \(\partial/\partial q^1\) means \(\csc\theta\,\,\partial/\partial\phi\). Note that the vectors <code>tangents(i,0)</code> and <code>tangents(i,1)</code> are orthogonal to the <code>normal_one_form</code> \(s_i\), i.e. \(s_i \partial x_{\rm surf}^i/\partial q^j = 0\); this statement is independent of a metric. Also, <code>tangents(i,0)</code> and <code>tangents(i,1)</code> are not necessarily orthogonal to each other, since orthogonality between 2 vectors (as opposed to a vector and a one-form) is metric-dependent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strahlkorper</td><td>The <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface. </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> at each point, as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">StrahlkorperFunctions::radius</a></code>. </td></tr>
    <tr><td class="paramname">r_hat</td><td>The radial unit vector as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#aa3af2842c8ccf53550cb7bc5479ed915">StrahlkorperFunctions::rhat</a></code>. </td></tr>
    <tr><td class="paramname">jac</td><td>The jacobian as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#a4b7e539fc4801e4c1bbf51e9bfe3775b">StrahlkorperFunctions::jacobian</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad01bf973fc96da80177664de7579e080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01bf973fc96da80177664de7579e080">&#9670;&nbsp;</a></span>tangents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StrahlkorperFunctions::tangents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; StrahlkorperTags::aliases::Jacobian&lt; Fr &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>strahlkorper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_hat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StrahlkorperTags::aliases::Jacobian&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>jac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The computed tangent vectors. </td></tr>
    <tr><td class="paramname">strahlkorper</td><td>The <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface. </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> at each point, as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#a11acf67db4c6b89d0c933902a957734b">StrahlkorperFunctions::radius</a></code>. </td></tr>
    <tr><td class="paramname">r_hat</td><td>The radial unit vector as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#aa3af2842c8ccf53550cb7bc5479ed915">StrahlkorperFunctions::rhat</a></code>. </td></tr>
    <tr><td class="paramname">jac</td><td>The jacobian as returned by <code><a class="el" href="namespaceStrahlkorperFunctions.html#a4b7e539fc4801e4c1bbf51e9bfe3775b">StrahlkorperFunctions::jacobian</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addfdd91170d447b2486a66058af4cdb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfdd91170d447b2486a66058af4cdb1">&#9670;&nbsp;</a></span>theta_phi() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt;<a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt;Fr&gt; &gt; StrahlkorperFunctions::theta_phi </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>strahlkorper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\((\theta,\phi)\) on the <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface. Doesn't depend on the shape of the surface.</p>
<p>We need to choose upper vs lower indices for theta_phi; it doesn't matter because these are coordinates and not geometric objects, so we choose lower indices arbitrarily. </p>

</div>
</div>
<a id="abbc9cbe34698cc65b28fecabb79d5aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc9cbe34698cc65b28fecabb79d5aab">&#9670;&nbsp;</a></span>theta_phi() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StrahlkorperFunctions::theta_phi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt; Fr &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>theta_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classStrahlkorper.html">Strahlkorper</a>&lt; Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>strahlkorper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\((\theta,\phi)\) on the <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a> surface. Doesn't depend on the shape of the surface.</p>
<p>We need to choose upper vs lower indices for theta_phi; it doesn't matter because these are coordinates and not geometric objects, so we choose lower indices arbitrarily. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceStrahlkorperFunctions.html">StrahlkorperFunctions</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
