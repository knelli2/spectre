<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.1"/>
  <title>SpECTRE: General Relativity</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.08.01</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__GeneralRelativityGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">General Relativity</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains functions used in General Relativistic simulations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab5d66e2b74cff67d1fd5e1f29a82b5b3"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gab5d66e2b74cff67d1fd5e1f29a82b5b3"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ijj&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gab5d66e2b74cff67d1fd5e1f29a82b5b3">GeneralizedHarmonic::covariant_deriv_of_extrinsic_curvature</a> (const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga45959454a026dbf844e15cdd93bc3a8d">extrinsic_curvature</a>, const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_unit_normal_vector, const tnsr::Ijj&lt; DataType, SpatialDim, Frame &gt; &amp;spatial_christoffel_second_kind, const tnsr::AA&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spacetime_metric, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;d_pi, const tnsr::ijaa&lt; DataType, SpatialDim, Frame &gt; &amp;d_phi)</td></tr>
<tr class="memdesc:gab5d66e2b74cff67d1fd5e1f29a82b5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the covariant derivative of extrinsic curvature from generalized harmonic variables and the spacetime normal vector.  <a href="group__GeneralRelativityGroup.html#gab5d66e2b74cff67d1fd5e1f29a82b5b3">More...</a><br /></td></tr>
<tr class="separator:gab5d66e2b74cff67d1fd5e1f29a82b5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae95d24eeb4d9fee18e49622938e00d4f"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gae95d24eeb4d9fee18e49622938e00d4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gae95d24eeb4d9fee18e49622938e00d4f">GeneralizedHarmonic::spacetime_derivative_of_spacetime_metric</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::abb&lt; DataType, SpatialDim, Frame &gt; * &gt; da_spacetime_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:gae95d24eeb4d9fee18e49622938e00d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spacetime derivative of the spacetime metric, \(\partial_a g_{bc}\).  <a href="group__GeneralRelativityGroup.html#gae95d24eeb4d9fee18e49622938e00d4f">More...</a><br /></td></tr>
<tr class="separator:gae95d24eeb4d9fee18e49622938e00d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga199511bfbac9c5fcf9f7623e0282b7ce"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga199511bfbac9c5fcf9f7623e0282b7ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga199511bfbac9c5fcf9f7623e0282b7ce">Ccz4::divergence_lapse</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; result, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;conformal_factor_squared, const tnsr::II&lt; DataType, Dim, Frame &gt; &amp;inverse_conformal_metric, const tnsr::ij&lt; DataType, Dim, Frame &gt; &amp;<a class="el" href="namespaceCcz4.html#a87978e9fd134cba34867098a1276b28a">grad_grad_lapse</a>)</td></tr>
<tr class="memdesc:ga199511bfbac9c5fcf9f7623e0282b7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the divergence of the lapse.  <a href="group__GeneralRelativityGroup.html#ga199511bfbac9c5fcf9f7623e0282b7ce">More...</a><br /></td></tr>
<tr class="separator:ga199511bfbac9c5fcf9f7623e0282b7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb75d874f73bc5c5fff40feef6dfd26f"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gacb75d874f73bc5c5fff40feef6dfd26f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gacb75d874f73bc5c5fff40feef6dfd26f">Ccz4::divergence_lapse</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;conformal_factor_squared, const tnsr::II&lt; DataType, Dim, Frame &gt; &amp;inverse_conformal_metric, const tnsr::ij&lt; DataType, Dim, Frame &gt; &amp;<a class="el" href="namespaceCcz4.html#a87978e9fd134cba34867098a1276b28a">grad_grad_lapse</a>)</td></tr>
<tr class="memdesc:gacb75d874f73bc5c5fff40feef6dfd26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the divergence of the lapse.  <a href="group__GeneralRelativityGroup.html#gacb75d874f73bc5c5fff40feef6dfd26f">More...</a><br /></td></tr>
<tr class="separator:gacb75d874f73bc5c5fff40feef6dfd26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a3c0b734b2c1ccaed28ad19e625521c"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </td></tr>
<tr class="memitem:ga7a3c0b734b2c1ccaed28ad19e625521c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga7a3c0b734b2c1ccaed28ad19e625521c">gr::christoffel_first_kind</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; * &gt; christoffel, const tnsr::abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;d_metric)</td></tr>
<tr class="memdesc:ga7a3c0b734b2c1ccaed28ad19e625521c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Christoffel symbol of the first kind from derivative of metric.  <a href="group__GeneralRelativityGroup.html#ga7a3c0b734b2c1ccaed28ad19e625521c">More...</a><br /></td></tr>
<tr class="separator:ga7a3c0b734b2c1ccaed28ad19e625521c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae077e6edabfd3953880c9ff6e1339cad"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </td></tr>
<tr class="memitem:gae077e6edabfd3953880c9ff6e1339cad"><td class="memTemplItemLeft" align="right" valign="top">tnsr::abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gae077e6edabfd3953880c9ff6e1339cad">gr::christoffel_first_kind</a> (const tnsr::abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;d_metric)</td></tr>
<tr class="memdesc:gae077e6edabfd3953880c9ff6e1339cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Christoffel symbol of the first kind from derivative of metric.  <a href="group__GeneralRelativityGroup.html#gae077e6edabfd3953880c9ff6e1339cad">More...</a><br /></td></tr>
<tr class="separator:gae077e6edabfd3953880c9ff6e1339cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0338cd790d56504c9727bcd8b73b7c3"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </td></tr>
<tr class="memitem:gac0338cd790d56504c9727bcd8b73b7c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gac0338cd790d56504c9727bcd8b73b7c3">gr::christoffel_second_kind</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::Abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; * &gt; christoffel, const tnsr::abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;d_metric, const tnsr::AA&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;inverse_metric)</td></tr>
<tr class="memdesc:gac0338cd790d56504c9727bcd8b73b7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Christoffel symbol of the second kind from derivative of metric and the inverse metric.  <a href="group__GeneralRelativityGroup.html#gac0338cd790d56504c9727bcd8b73b7c3">More...</a><br /></td></tr>
<tr class="separator:gac0338cd790d56504c9727bcd8b73b7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf19664f25e3ca9689059194515d1cb"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </td></tr>
<tr class="memitem:ga6bf19664f25e3ca9689059194515d1cb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga6bf19664f25e3ca9689059194515d1cb">gr::christoffel_second_kind</a> (const tnsr::abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;d_metric, const tnsr::AA&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;inverse_metric) -&gt; tnsr::Abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt;</td></tr>
<tr class="memdesc:ga6bf19664f25e3ca9689059194515d1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Christoffel symbol of the second kind from derivative of metric and the inverse metric.  <a href="group__GeneralRelativityGroup.html#ga6bf19664f25e3ca9689059194515d1cb">More...</a><br /></td></tr>
<tr class="separator:ga6bf19664f25e3ca9689059194515d1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e11263157960500c32f1a7dfe804c4"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga17e11263157960500c32f1a7dfe804c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga17e11263157960500c32f1a7dfe804c4">gr::derivatives_of_spacetime_metric</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::abb&lt; DataType, SpatialDim, Frame &gt; * &gt; spacetime_deriv_spacetime_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">lapse</a>, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;dt_lapse, const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;dt_shift, const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">spatial_metric</a>, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;dt_spatial_metric, const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_spatial_metric)</td></tr>
<tr class="memdesc:ga17e11263157960500c32f1a7dfe804c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spacetime derivative of spacetime metric from spatial metric, lapse, shift, and their space and time derivatives.  <a href="group__GeneralRelativityGroup.html#ga17e11263157960500c32f1a7dfe804c4">More...</a><br /></td></tr>
<tr class="separator:ga17e11263157960500c32f1a7dfe804c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c67523b5f824e0ba85f0c177ba9d487"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga5c67523b5f824e0ba85f0c177ba9d487"><td class="memTemplItemLeft" align="right" valign="top">tnsr::abb&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga5c67523b5f824e0ba85f0c177ba9d487">gr::derivatives_of_spacetime_metric</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">lapse</a>, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;dt_lapse, const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;dt_shift, const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">spatial_metric</a>, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;dt_spatial_metric, const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_spatial_metric)</td></tr>
<tr class="memdesc:ga5c67523b5f824e0ba85f0c177ba9d487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spacetime derivative of spacetime metric from spatial metric, lapse, shift, and their space and time derivatives.  <a href="group__GeneralRelativityGroup.html#ga5c67523b5f824e0ba85f0c177ba9d487">More...</a><br /></td></tr>
<tr class="separator:ga5c67523b5f824e0ba85f0c177ba9d487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fc9e348d45cf3973d46b915fd6985d3"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga8fc9e348d45cf3973d46b915fd6985d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga8fc9e348d45cf3973d46b915fd6985d3">gr::deriv_inverse_spatial_metric</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJJ&lt; DataType, Dim, Frame &gt; * &gt; result, const tnsr::II&lt; DataType, Dim, Frame &gt; &amp;inverse_spatial_metric, const tnsr::ijj&lt; DataType, Dim, Frame &gt; &amp;d_spatial_metric)</td></tr>
<tr class="memdesc:ga8fc9e348d45cf3973d46b915fd6985d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spatial derivative of the inverse spatial metric from the inverse spatial metric and the spatial derivative of the spatial metric.  <a href="group__GeneralRelativityGroup.html#ga8fc9e348d45cf3973d46b915fd6985d3">More...</a><br /></td></tr>
<tr class="separator:ga8fc9e348d45cf3973d46b915fd6985d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad95d8093d219ce2004d7c050d1652b9e"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gad95d8093d219ce2004d7c050d1652b9e"><td class="memTemplItemLeft" align="right" valign="top">tnsr::iJJ&lt; DataType, Dim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gad95d8093d219ce2004d7c050d1652b9e">gr::deriv_inverse_spatial_metric</a> (const tnsr::II&lt; DataType, Dim, Frame &gt; &amp;inverse_spatial_metric, const tnsr::ijj&lt; DataType, Dim, Frame &gt; &amp;d_spatial_metric)</td></tr>
<tr class="memdesc:gad95d8093d219ce2004d7c050d1652b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spatial derivative of the inverse spatial metric from the inverse spatial metric and the spatial derivative of the spatial metric.  <a href="group__GeneralRelativityGroup.html#gad95d8093d219ce2004d7c050d1652b9e">More...</a><br /></td></tr>
<tr class="separator:gad95d8093d219ce2004d7c050d1652b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e85f342b2cd915e8d75675277df689"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gaf8e85f342b2cd915e8d75675277df689"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gaf8e85f342b2cd915e8d75675277df689">gr::extrinsic_curvature</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">lapse</a>, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>, const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">spatial_metric</a>, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;dt_spatial_metric, const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_spatial_metric)</td></tr>
<tr class="memdesc:gaf8e85f342b2cd915e8d75675277df689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes extrinsic curvature from metric and derivatives.  <a href="group__GeneralRelativityGroup.html#gaf8e85f342b2cd915e8d75675277df689">More...</a><br /></td></tr>
<tr class="separator:gaf8e85f342b2cd915e8d75675277df689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267fa53f28f49e280846c84df552cbb0"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga267fa53f28f49e280846c84df552cbb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga267fa53f28f49e280846c84df552cbb0">gr::extrinsic_curvature</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, SpatialDim, Frame &gt; * &gt; ex_curvature, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">lapse</a>, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>, const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">spatial_metric</a>, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;dt_spatial_metric, const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_spatial_metric)</td></tr>
<tr class="memdesc:ga267fa53f28f49e280846c84df552cbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes extrinsic curvature from metric and derivatives.  <a href="group__GeneralRelativityGroup.html#ga267fa53f28f49e280846c84df552cbb0">More...</a><br /></td></tr>
<tr class="separator:ga267fa53f28f49e280846c84df552cbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96f20e1c2caf499f4a38e86f3a815ae8"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga96f20e1c2caf499f4a38e86f3a815ae8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga96f20e1c2caf499f4a38e86f3a815ae8">GeneralizedHarmonic::christoffel_second_kind</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::Ijj&lt; DataType, SpatialDim, Frame &gt; * &gt; christoffel, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inv_metric)</td></tr>
<tr class="memdesc:ga96f20e1c2caf499f4a38e86f3a815ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spatial Christoffel symbol of the 2nd kind from the the generalized harmonic spatial derivative variable and the inverse spatial metric.  <a href="group__GeneralRelativityGroup.html#ga96f20e1c2caf499f4a38e86f3a815ae8">More...</a><br /></td></tr>
<tr class="separator:ga96f20e1c2caf499f4a38e86f3a815ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203a5bd4ab96b6343791c3f05e43c099"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga203a5bd4ab96b6343791c3f05e43c099"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga203a5bd4ab96b6343791c3f05e43c099">GeneralizedHarmonic::christoffel_second_kind</a> (const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inv_metric) -&gt; tnsr::Ijj&lt; DataType, SpatialDim, Frame &gt;</td></tr>
<tr class="memdesc:ga203a5bd4ab96b6343791c3f05e43c099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spatial Christoffel symbol of the 2nd kind from the the generalized harmonic spatial derivative variable and the inverse spatial metric.  <a href="group__GeneralRelativityGroup.html#ga203a5bd4ab96b6343791c3f05e43c099">More...</a><br /></td></tr>
<tr class="separator:ga203a5bd4ab96b6343791c3f05e43c099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7c5b2e62ebc5c027b2a435ab145375b"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gaf7c5b2e62ebc5c027b2a435ab145375b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gaf7c5b2e62ebc5c027b2a435ab145375b">GeneralizedHarmonic::deriv_spatial_metric</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; * &gt; d_spatial_metric, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:gaf7c5b2e62ebc5c027b2a435ab145375b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spatial derivatives of the spatial metric from the generalized harmonic spatial derivative variable.  <a href="group__GeneralRelativityGroup.html#gaf7c5b2e62ebc5c027b2a435ab145375b">More...</a><br /></td></tr>
<tr class="separator:gaf7c5b2e62ebc5c027b2a435ab145375b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c7a1ec6b2b2a174328daddf74ca8fa0"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga9c7a1ec6b2b2a174328daddf74ca8fa0"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ijj&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga9c7a1ec6b2b2a174328daddf74ca8fa0">GeneralizedHarmonic::deriv_spatial_metric</a> (const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:ga9c7a1ec6b2b2a174328daddf74ca8fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spatial derivatives of the spatial metric from the generalized harmonic spatial derivative variable.  <a href="group__GeneralRelativityGroup.html#ga9c7a1ec6b2b2a174328daddf74ca8fa0">More...</a><br /></td></tr>
<tr class="separator:ga9c7a1ec6b2b2a174328daddf74ca8fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45959454a026dbf844e15cdd93bc3a8d"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga45959454a026dbf844e15cdd93bc3a8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga45959454a026dbf844e15cdd93bc3a8d">GeneralizedHarmonic::extrinsic_curvature</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, SpatialDim, Frame &gt; * &gt; ex_curv, const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_normal_vector, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:ga45959454a026dbf844e15cdd93bc3a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes extrinsic curvature from generalized harmonic variables and the spacetime normal vector.  <a href="group__GeneralRelativityGroup.html#ga45959454a026dbf844e15cdd93bc3a8d">More...</a><br /></td></tr>
<tr class="separator:ga45959454a026dbf844e15cdd93bc3a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7204c20e97d784ae634c3976f69d427"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gae7204c20e97d784ae634c3976f69d427"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gae7204c20e97d784ae634c3976f69d427">GeneralizedHarmonic::extrinsic_curvature</a> (const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_normal_vector, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:gae7204c20e97d784ae634c3976f69d427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes extrinsic curvature from generalized harmonic variables and the spacetime normal vector.  <a href="group__GeneralRelativityGroup.html#gae7204c20e97d784ae634c3976f69d427">More...</a><br /></td></tr>
<tr class="separator:gae7204c20e97d784ae634c3976f69d427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f83b458def10ba14e20e6b935bcc7c3"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga8f83b458def10ba14e20e6b935bcc7c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga8f83b458def10ba14e20e6b935bcc7c3">GeneralizedHarmonic::gauge_source</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; DataType, SpatialDim, Frame &gt; * &gt; gauge_source_h, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;dt_lapse, const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;dt_shift, const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;spatial_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;trace_extrinsic_curvature, const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;trace_christoffel_last_indices)</td></tr>
<tr class="memdesc:ga8f83b458def10ba14e20e6b935bcc7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes generalized harmonic gauge source function.  <a href="group__GeneralRelativityGroup.html#ga8f83b458def10ba14e20e6b935bcc7c3">More...</a><br /></td></tr>
<tr class="separator:ga8f83b458def10ba14e20e6b935bcc7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8f2808408986378437dfdbe07989271"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gac8f2808408986378437dfdbe07989271"><td class="memTemplItemLeft" align="right" valign="top">tnsr::a&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gac8f2808408986378437dfdbe07989271">GeneralizedHarmonic::gauge_source</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;dt_lapse, const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;dt_shift, const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;spatial_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;trace_extrinsic_curvature, const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;trace_christoffel_last_indices)</td></tr>
<tr class="memdesc:gac8f2808408986378437dfdbe07989271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes generalized harmonic gauge source function.  <a href="group__GeneralRelativityGroup.html#gac8f2808408986378437dfdbe07989271">More...</a><br /></td></tr>
<tr class="separator:gac8f2808408986378437dfdbe07989271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf4f3abab8ab7a0033fe999140b72ffc"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gaaf4f3abab8ab7a0033fe999140b72ffc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">GeneralizedHarmonic::phi</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; * &gt; phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;spatial_metric, const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaf7c5b2e62ebc5c027b2a435ab145375b">deriv_spatial_metric</a>)</td></tr>
<tr class="memdesc:gaaf4f3abab8ab7a0033fe999140b72ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the auxiliary variable \(\Phi_{iab}\) used by the generalized harmonic formulation of Einstein's equations.  <a href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">More...</a><br /></td></tr>
<tr class="separator:gaaf4f3abab8ab7a0033fe999140b72ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a6ef24ec982c3afa3e1f573a937c858"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga3a6ef24ec982c3afa3e1f573a937c858"><td class="memTemplItemLeft" align="right" valign="top">tnsr::iaa&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga3a6ef24ec982c3afa3e1f573a937c858">GeneralizedHarmonic::phi</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;spatial_metric, const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaf7c5b2e62ebc5c027b2a435ab145375b">deriv_spatial_metric</a>)</td></tr>
<tr class="memdesc:ga3a6ef24ec982c3afa3e1f573a937c858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the auxiliary variable \(\Phi_{iab}\) used by the generalized harmonic formulation of Einstein's equations.  <a href="group__GeneralRelativityGroup.html#ga3a6ef24ec982c3afa3e1f573a937c858">More...</a><br /></td></tr>
<tr class="separator:ga3a6ef24ec982c3afa3e1f573a937c858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ad74fcd422729821afb270c95800b83"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga5ad74fcd422729821afb270c95800b83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">GeneralizedHarmonic::pi</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; DataType, SpatialDim, Frame &gt; * &gt; pi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;dt_lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;dt_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;spatial_metric, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;dt_spatial_metric, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:ga5ad74fcd422729821afb270c95800b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the conjugate momentum \(\Pi_{ab}\) of the spacetime metric \( g_{ab} \).  <a href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">More...</a><br /></td></tr>
<tr class="separator:ga5ad74fcd422729821afb270c95800b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga024fe82a266a3c29a0a5c2abb58da963"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga024fe82a266a3c29a0a5c2abb58da963"><td class="memTemplItemLeft" align="right" valign="top">tnsr::aa&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga024fe82a266a3c29a0a5c2abb58da963">GeneralizedHarmonic::pi</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;dt_lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;dt_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;spatial_metric, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;dt_spatial_metric, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:ga024fe82a266a3c29a0a5c2abb58da963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the conjugate momentum \(\Pi_{ab}\) of the spacetime metric \( g_{ab} \).  <a href="group__GeneralRelativityGroup.html#ga024fe82a266a3c29a0a5c2abb58da963">More...</a><br /></td></tr>
<tr class="separator:ga024fe82a266a3c29a0a5c2abb58da963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga582aa60e616b2257b6d28808f704c64f"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga582aa60e616b2257b6d28808f704c64f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga582aa60e616b2257b6d28808f704c64f">GeneralizedHarmonic::spatial_ricci_tensor</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, VolumeDim, Frame &gt; * &gt; ricci, const tnsr::iaa&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::ijaa&lt; DataType, VolumeDim, Frame &gt; &amp;deriv_phi, const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;inverse_spatial_metric)</td></tr>
<tr class="memdesc:ga582aa60e616b2257b6d28808f704c64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute spatial Ricci tensor using evolved variables and their first derivatives.  <a href="group__GeneralRelativityGroup.html#ga582aa60e616b2257b6d28808f704c64f">More...</a><br /></td></tr>
<tr class="separator:ga582aa60e616b2257b6d28808f704c64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaad08e9714e4c6f4f4b2697b5eefb31e"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gaaad08e9714e4c6f4f4b2697b5eefb31e"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; DataType, VolumeDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gaaad08e9714e4c6f4f4b2697b5eefb31e">GeneralizedHarmonic::spatial_ricci_tensor</a> (const tnsr::iaa&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::ijaa&lt; DataType, VolumeDim, Frame &gt; &amp;deriv_phi, const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;inverse_spatial_metric)</td></tr>
<tr class="memdesc:gaaad08e9714e4c6f4f4b2697b5eefb31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute spatial Ricci tensor using evolved variables and their first derivatives.  <a href="group__GeneralRelativityGroup.html#gaaad08e9714e4c6f4f4b2697b5eefb31e">More...</a><br /></td></tr>
<tr class="separator:gaaad08e9714e4c6f4f4b2697b5eefb31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0426f2b24c3f088deaef7a4e5ff6160a"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga0426f2b24c3f088deaef7a4e5ff6160a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga0426f2b24c3f088deaef7a4e5ff6160a">GeneralizedHarmonic::spacetime_deriv_of_det_spatial_metric</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; DataType, SpatialDim, Frame &gt; * &gt; d4_det_spatial_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;sqrt_det_spatial_metric, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;dt_spatial_metric, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:ga0426f2b24c3f088deaef7a4e5ff6160a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spacetime derivatives of the determinant of spatial metric, using the generalized harmonic variables, spatial metric, and its time derivative.  <a href="group__GeneralRelativityGroup.html#ga0426f2b24c3f088deaef7a4e5ff6160a">More...</a><br /></td></tr>
<tr class="separator:ga0426f2b24c3f088deaef7a4e5ff6160a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab701aaed6bb5036b97891f439cc292a1"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gab701aaed6bb5036b97891f439cc292a1"><td class="memTemplItemLeft" align="right" valign="top">tnsr::a&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gab701aaed6bb5036b97891f439cc292a1">GeneralizedHarmonic::spacetime_deriv_of_det_spatial_metric</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;sqrt_det_spatial_metric, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;dt_spatial_metric, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:gab701aaed6bb5036b97891f439cc292a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spacetime derivatives of the determinant of spatial metric, using the generalized harmonic variables, spatial metric, and its time derivative.  <a href="group__GeneralRelativityGroup.html#gab701aaed6bb5036b97891f439cc292a1">More...</a><br /></td></tr>
<tr class="separator:gab701aaed6bb5036b97891f439cc292a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade8698a459687d11bbf191c8e95c4df3"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gade8698a459687d11bbf191c8e95c4df3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gade8698a459687d11bbf191c8e95c4df3">GeneralizedHarmonic::spacetime_deriv_of_norm_of_shift</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; DataType, SpatialDim, Frame &gt; * &gt; d4_norm_of_shift, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;spatial_metric, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric, const tnsr::AA&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spacetime_metric, const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_unit_normal, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>)</td></tr>
<tr class="memdesc:gade8698a459687d11bbf191c8e95c4df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spacetime derivatives of the norm of the shift vector.  <a href="group__GeneralRelativityGroup.html#gade8698a459687d11bbf191c8e95c4df3">More...</a><br /></td></tr>
<tr class="separator:gade8698a459687d11bbf191c8e95c4df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ca7b33f2c45ddd2eb2dc4f88cb1bcd0"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga6ca7b33f2c45ddd2eb2dc4f88cb1bcd0"><td class="memTemplItemLeft" align="right" valign="top">tnsr::a&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga6ca7b33f2c45ddd2eb2dc4f88cb1bcd0">GeneralizedHarmonic::spacetime_deriv_of_norm_of_shift</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;spatial_metric, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric, const tnsr::AA&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spacetime_metric, const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_unit_normal, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>)</td></tr>
<tr class="memdesc:ga6ca7b33f2c45ddd2eb2dc4f88cb1bcd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spacetime derivatives of the norm of the shift vector.  <a href="group__GeneralRelativityGroup.html#ga6ca7b33f2c45ddd2eb2dc4f88cb1bcd0">More...</a><br /></td></tr>
<tr class="separator:ga6ca7b33f2c45ddd2eb2dc4f88cb1bcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4628cbcc3f9df0954efbbfada626806"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gaa4628cbcc3f9df0954efbbfada626806"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gaa4628cbcc3f9df0954efbbfada626806">GeneralizedHarmonic::spatial_deriv_of_lapse</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; DataType, SpatialDim, Frame &gt; * &gt; deriv_lapse, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_unit_normal, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:gaa4628cbcc3f9df0954efbbfada626806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spatial derivatives of lapse ( \(\alpha\)) from the generalized harmonic variables and spacetime unit normal 1-form.  <a href="group__GeneralRelativityGroup.html#gaa4628cbcc3f9df0954efbbfada626806">More...</a><br /></td></tr>
<tr class="separator:gaa4628cbcc3f9df0954efbbfada626806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga564c6ea734855ce31aad41bf68b11401"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga564c6ea734855ce31aad41bf68b11401"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga564c6ea734855ce31aad41bf68b11401">GeneralizedHarmonic::spatial_deriv_of_lapse</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_unit_normal, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:ga564c6ea734855ce31aad41bf68b11401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spatial derivatives of lapse ( \(\alpha\)) from the generalized harmonic variables and spacetime unit normal 1-form.  <a href="group__GeneralRelativityGroup.html#ga564c6ea734855ce31aad41bf68b11401">More...</a><br /></td></tr>
<tr class="separator:ga564c6ea734855ce31aad41bf68b11401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e61f81f9d1dc3de00e9d246ca338b01"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga7e61f81f9d1dc3de00e9d246ca338b01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga7e61f81f9d1dc3de00e9d246ca338b01">GeneralizedHarmonic::spatial_deriv_of_shift</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; * &gt; deriv_shift, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::AA&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spacetime_metric, const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_unit_normal, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:ga7e61f81f9d1dc3de00e9d246ca338b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spatial derivatives of the shift vector from the generalized harmonic and geometric variables.  <a href="group__GeneralRelativityGroup.html#ga7e61f81f9d1dc3de00e9d246ca338b01">More...</a><br /></td></tr>
<tr class="separator:ga7e61f81f9d1dc3de00e9d246ca338b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa24aa403627d7091a89a41e91b78fd7e"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gaa24aa403627d7091a89a41e91b78fd7e"><td class="memTemplItemLeft" align="right" valign="top">tnsr::iJ&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gaa24aa403627d7091a89a41e91b78fd7e">GeneralizedHarmonic::spatial_deriv_of_shift</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::AA&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spacetime_metric, const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_unit_normal, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:gaa24aa403627d7091a89a41e91b78fd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spatial derivatives of the shift vector from the generalized harmonic and geometric variables.  <a href="group__GeneralRelativityGroup.html#gaa24aa403627d7091a89a41e91b78fd7e">More...</a><br /></td></tr>
<tr class="separator:gaa24aa403627d7091a89a41e91b78fd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga689776209c34d7872caca3559f4c29e8"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga689776209c34d7872caca3559f4c29e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga689776209c34d7872caca3559f4c29e8">GeneralizedHarmonic::time_derivative_of_spacetime_metric</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; DataType, SpatialDim, Frame &gt; * &gt; dt_spacetime_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:ga689776209c34d7872caca3559f4c29e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the time derivative of the spacetime metric from the generalized harmonic quantities \(\Pi_{a b}\), \(\Phi_{i a b}\), and the lapse \(\alpha\) and shift \(\beta^i\).  <a href="group__GeneralRelativityGroup.html#ga689776209c34d7872caca3559f4c29e8">More...</a><br /></td></tr>
<tr class="separator:ga689776209c34d7872caca3559f4c29e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5cd5d5792a2bec008e77dddc7784d4"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gacb5cd5d5792a2bec008e77dddc7784d4"><td class="memTemplItemLeft" align="right" valign="top">tnsr::aa&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gacb5cd5d5792a2bec008e77dddc7784d4">GeneralizedHarmonic::time_derivative_of_spacetime_metric</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>)</td></tr>
<tr class="memdesc:gacb5cd5d5792a2bec008e77dddc7784d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the time derivative of the spacetime metric from the generalized harmonic quantities \(\Pi_{a b}\), \(\Phi_{i a b}\), and the lapse \(\alpha\) and shift \(\beta^i\).  <a href="group__GeneralRelativityGroup.html#gacb5cd5d5792a2bec008e77dddc7784d4">More...</a><br /></td></tr>
<tr class="separator:gacb5cd5d5792a2bec008e77dddc7784d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf315d2a3e0a2cf5765805cf7a680e768"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gaf315d2a3e0a2cf5765805cf7a680e768"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gaf315d2a3e0a2cf5765805cf7a680e768">GeneralizedHarmonic::time_deriv_of_lapse</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; dt_lapse, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_unit_normal, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>)</td></tr>
<tr class="memdesc:gaf315d2a3e0a2cf5765805cf7a680e768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes time derivative of lapse ( \(\alpha\)) from the generalized harmonic variables, lapse, shift and the spacetime unit normal 1-form.  <a href="group__GeneralRelativityGroup.html#gaf315d2a3e0a2cf5765805cf7a680e768">More...</a><br /></td></tr>
<tr class="separator:gaf315d2a3e0a2cf5765805cf7a680e768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31ad1bd676bbcbcb472568c55efe27a1"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga31ad1bd676bbcbcb472568c55efe27a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga31ad1bd676bbcbcb472568c55efe27a1">GeneralizedHarmonic::time_deriv_of_lapse</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_unit_normal, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>)</td></tr>
<tr class="memdesc:ga31ad1bd676bbcbcb472568c55efe27a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes time derivative of lapse ( \(\alpha\)) from the generalized harmonic variables, lapse, shift and the spacetime unit normal 1-form.  <a href="group__GeneralRelativityGroup.html#ga31ad1bd676bbcbcb472568c55efe27a1">More...</a><br /></td></tr>
<tr class="separator:ga31ad1bd676bbcbcb472568c55efe27a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f445c797aa9bd1437c872b8f84a2f19"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga9f445c797aa9bd1437c872b8f84a2f19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga9f445c797aa9bd1437c872b8f84a2f19">GeneralizedHarmonic::time_deriv_of_lower_shift</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; DataType, SpatialDim, Frame &gt; * &gt; dt_lower_shift, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;spatial_metric, const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_unit_normal, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>)</td></tr>
<tr class="memdesc:ga9f445c797aa9bd1437c872b8f84a2f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes time derivative of index lowered shift from generalized harmonic variables, spatial metric and its time derivative.  <a href="group__GeneralRelativityGroup.html#ga9f445c797aa9bd1437c872b8f84a2f19">More...</a><br /></td></tr>
<tr class="separator:ga9f445c797aa9bd1437c872b8f84a2f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fb28da7e5755e0daa515e5c48839c3c"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga1fb28da7e5755e0daa515e5c48839c3c"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga1fb28da7e5755e0daa515e5c48839c3c">GeneralizedHarmonic::time_deriv_of_lower_shift</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;spatial_metric, const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_unit_normal, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>)</td></tr>
<tr class="memdesc:ga1fb28da7e5755e0daa515e5c48839c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes time derivative of index lowered shift from generalized harmonic variables, spatial metric and its time derivative.  <a href="group__GeneralRelativityGroup.html#ga1fb28da7e5755e0daa515e5c48839c3c">More...</a><br /></td></tr>
<tr class="separator:ga1fb28da7e5755e0daa515e5c48839c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad224b9ff081393614b12f4c246d5a194"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gad224b9ff081393614b12f4c246d5a194"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gad224b9ff081393614b12f4c246d5a194">GeneralizedHarmonic::time_deriv_of_shift</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; DataType, SpatialDim, Frame &gt; * &gt; dt_shift, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric, const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_unit_normal, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>)</td></tr>
<tr class="memdesc:gad224b9ff081393614b12f4c246d5a194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes time derivative of the shift vector from the generalized harmonic and geometric variables.  <a href="group__GeneralRelativityGroup.html#gad224b9ff081393614b12f4c246d5a194">More...</a><br /></td></tr>
<tr class="separator:gad224b9ff081393614b12f4c246d5a194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad04becb36b2aba46f0ed0bc0ba804b"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga3ad04becb36b2aba46f0ed0bc0ba804b"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga3ad04becb36b2aba46f0ed0bc0ba804b">GeneralizedHarmonic::time_deriv_of_shift</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric, const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;spacetime_unit_normal, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>)</td></tr>
<tr class="memdesc:ga3ad04becb36b2aba46f0ed0bc0ba804b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes time derivative of the shift vector from the generalized harmonic and geometric variables.  <a href="group__GeneralRelativityGroup.html#ga3ad04becb36b2aba46f0ed0bc0ba804b">More...</a><br /></td></tr>
<tr class="separator:ga3ad04becb36b2aba46f0ed0bc0ba804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06fe45b0ce075b1a6e4439455bfa9cf4"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga06fe45b0ce075b1a6e4439455bfa9cf4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga06fe45b0ce075b1a6e4439455bfa9cf4">GeneralizedHarmonic::time_deriv_of_spatial_metric</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, SpatialDim, Frame &gt; * &gt; dt_spatial_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>)</td></tr>
<tr class="memdesc:ga06fe45b0ce075b1a6e4439455bfa9cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes time derivative of the spatial metric.  <a href="group__GeneralRelativityGroup.html#ga06fe45b0ce075b1a6e4439455bfa9cf4">More...</a><br /></td></tr>
<tr class="separator:ga06fe45b0ce075b1a6e4439455bfa9cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32556fbd094f862e1f8d413c5f57e9da"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga32556fbd094f862e1f8d413c5f57e9da"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga32556fbd094f862e1f8d413c5f57e9da">GeneralizedHarmonic::time_deriv_of_spatial_metric</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;shift, const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaaf4f3abab8ab7a0033fe999140b72ffc">phi</a>, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga5ad74fcd422729821afb270c95800b83">pi</a>)</td></tr>
<tr class="memdesc:ga32556fbd094f862e1f8d413c5f57e9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes time derivative of the spatial metric.  <a href="group__GeneralRelativityGroup.html#ga32556fbd094f862e1f8d413c5f57e9da">More...</a><br /></td></tr>
<tr class="separator:ga32556fbd094f862e1f8d413c5f57e9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga877184239a3161ef2bbafd1c71fec9ae"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:ga877184239a3161ef2bbafd1c71fec9ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga877184239a3161ef2bbafd1c71fec9ae">raise_or_lower_first_index</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 2, 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, Index1, Index1 &gt;&gt; * &gt; result, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 2, 1, 1 &gt;, index_list&lt; Index0, Index1, Index1 &gt;&gt; &amp;tensor, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; &amp;metric)</td></tr>
<tr class="memdesc:ga877184239a3161ef2bbafd1c71fec9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or lowers the first index of a rank 3 tensor which is symmetric in the last two indices.  <a href="group__GeneralRelativityGroup.html#ga877184239a3161ef2bbafd1c71fec9ae">More...</a><br /></td></tr>
<tr class="separator:ga877184239a3161ef2bbafd1c71fec9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65bb6dfde399d573ecb051af9de78aea"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:ga65bb6dfde399d573ecb051af9de78aea"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 2, 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, Index1, Index1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga65bb6dfde399d573ecb051af9de78aea">raise_or_lower_first_index</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 2, 1, 1 &gt;, index_list&lt; Index0, Index1, Index1 &gt;&gt; &amp;tensor, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; &amp;metric)</td></tr>
<tr class="memdesc:ga65bb6dfde399d573ecb051af9de78aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or lowers the first index of a rank 3 tensor which is symmetric in the last two indices.  <a href="group__GeneralRelativityGroup.html#ga65bb6dfde399d573ecb051af9de78aea">More...</a><br /></td></tr>
<tr class="separator:ga65bb6dfde399d573ecb051af9de78aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ea873346936b497401378441ed609da"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index0 &gt; </td></tr>
<tr class="memitem:ga2ea873346936b497401378441ed609da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga2ea873346936b497401378441ed609da">raise_or_lower_index</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; * &gt; result, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; Index0 &gt;&gt; &amp;tensor, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; &amp;metric)</td></tr>
<tr class="memdesc:ga2ea873346936b497401378441ed609da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or lowers the index of a rank 1 tensor.  <a href="group__GeneralRelativityGroup.html#ga2ea873346936b497401378441ed609da">More...</a><br /></td></tr>
<tr class="separator:ga2ea873346936b497401378441ed609da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b541787ca9055248e7e427293956f9b"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index0 &gt; </td></tr>
<tr class="memitem:ga3b541787ca9055248e7e427293956f9b"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga3b541787ca9055248e7e427293956f9b">raise_or_lower_index</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; Index0 &gt;&gt; &amp;tensor, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; &amp;metric)</td></tr>
<tr class="memdesc:ga3b541787ca9055248e7e427293956f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or lowers the index of a rank 1 tensor.  <a href="group__GeneralRelativityGroup.html#ga3b541787ca9055248e7e427293956f9b">More...</a><br /></td></tr>
<tr class="separator:ga3b541787ca9055248e7e427293956f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd55449cbc431fe342054f29d312a6f1"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:gabd55449cbc431fe342054f29d312a6f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gabd55449cbc431fe342054f29d312a6f1">trace_last_indices</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; Index0 &gt;&gt; * &gt; trace_of_tensor, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 2, 1, 1 &gt;, index_list&lt; Index0, Index1, Index1 &gt;&gt; &amp;tensor, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index1 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index1 &gt;&gt;&gt; &amp;metric)</td></tr>
<tr class="memdesc:gabd55449cbc431fe342054f29d312a6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes trace of a rank 3 tensor, which is symmetric in its last two indices, tracing the symmetric indices.  <a href="group__GeneralRelativityGroup.html#gabd55449cbc431fe342054f29d312a6f1">More...</a><br /></td></tr>
<tr class="separator:gabd55449cbc431fe342054f29d312a6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e822981a2abfd63cc4218a36bae08e4"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:ga3e822981a2abfd63cc4218a36bae08e4"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; Index0 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga3e822981a2abfd63cc4218a36bae08e4">trace_last_indices</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 2, 1, 1 &gt;, index_list&lt; Index0, Index1, Index1 &gt;&gt; &amp;tensor, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index1 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index1 &gt;&gt;&gt; &amp;metric)</td></tr>
<tr class="memdesc:ga3e822981a2abfd63cc4218a36bae08e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes trace of a rank 3 tensor, which is symmetric in its last two indices, tracing the symmetric indices.  <a href="group__GeneralRelativityGroup.html#ga3e822981a2abfd63cc4218a36bae08e4">More...</a><br /></td></tr>
<tr class="separator:ga3e822981a2abfd63cc4218a36bae08e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc6a7bfb2bc92b95ce132a274312d94f"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index0 &gt; </td></tr>
<tr class="memitem:gacc6a7bfb2bc92b95ce132a274312d94f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gacc6a7bfb2bc92b95ce132a274312d94f">trace</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; trace, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; Index0, Index0 &gt;&gt; &amp;tensor, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; &amp;metric)</td></tr>
<tr class="memdesc:gacc6a7bfb2bc92b95ce132a274312d94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes trace of a rank-2 symmetric tensor.  <a href="group__GeneralRelativityGroup.html#gacc6a7bfb2bc92b95ce132a274312d94f">More...</a><br /></td></tr>
<tr class="separator:gacc6a7bfb2bc92b95ce132a274312d94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac987c0a854c67954e427277beccbced4"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index0 &gt; </td></tr>
<tr class="memitem:gac987c0a854c67954e427277beccbced4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gac987c0a854c67954e427277beccbced4">trace</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; Index0, Index0 &gt;&gt; &amp;tensor, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; &amp;metric)</td></tr>
<tr class="memdesc:gac987c0a854c67954e427277beccbced4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes trace of a rank-2 symmetric tensor.  <a href="group__GeneralRelativityGroup.html#gac987c0a854c67954e427277beccbced4">More...</a><br /></td></tr>
<tr class="separator:gac987c0a854c67954e427277beccbced4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32c048728ce86e985cfe9316939899e3"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga32c048728ce86e985cfe9316939899e3"><td class="memTemplItemLeft" align="right" valign="top">tnsr::a&lt; DataType, VolumeDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga32c048728ce86e985cfe9316939899e3">gr::interface_null_normal</a> (const tnsr::a&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="namespacegr.html#a9bd0748d415551a9435525d016e2fb19">spacetime_normal_one_form</a>, const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;interface_unit_normal_one_form, const double sign)</td></tr>
<tr class="memdesc:ga32c048728ce86e985cfe9316939899e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute null normal one-form to the boundary of a closed region in a spatial slice of spacetime.  <a href="group__GeneralRelativityGroup.html#ga32c048728ce86e985cfe9316939899e3">More...</a><br /></td></tr>
<tr class="separator:ga32c048728ce86e985cfe9316939899e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2f3d69a00e0f3d573dd5645f3ff1197"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gae2f3d69a00e0f3d573dd5645f3ff1197"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gae2f3d69a00e0f3d573dd5645f3ff1197">gr::interface_null_normal</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; DataType, VolumeDim, Frame &gt; * &gt; null_one_form, const tnsr::a&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="namespacegr.html#a9bd0748d415551a9435525d016e2fb19">spacetime_normal_one_form</a>, const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;interface_unit_normal_one_form, const double sign)</td></tr>
<tr class="memdesc:gae2f3d69a00e0f3d573dd5645f3ff1197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute null normal one-form to the boundary of a closed region in a spatial slice of spacetime.  <a href="group__GeneralRelativityGroup.html#gae2f3d69a00e0f3d573dd5645f3ff1197">More...</a><br /></td></tr>
<tr class="separator:gae2f3d69a00e0f3d573dd5645f3ff1197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f732806d7a8024a76fdd3f355c48b92"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga9f732806d7a8024a76fdd3f355c48b92"><td class="memTemplItemLeft" align="right" valign="top">tnsr::A&lt; DataType, VolumeDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga9f732806d7a8024a76fdd3f355c48b92">gr::interface_null_normal</a> (const tnsr::A&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga6b0dfbe004db0edf33e7e7d4e126e77b">spacetime_normal_vector</a>, const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;interface_unit_normal_vector, const double sign)</td></tr>
<tr class="memdesc:ga9f732806d7a8024a76fdd3f355c48b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute null normal vector to the boundary of a closed region in a spatial slice of spacetime.  <a href="group__GeneralRelativityGroup.html#ga9f732806d7a8024a76fdd3f355c48b92">More...</a><br /></td></tr>
<tr class="separator:ga9f732806d7a8024a76fdd3f355c48b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad51b34d6b5c2c1cef5555b6030de0695"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gad51b34d6b5c2c1cef5555b6030de0695"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gad51b34d6b5c2c1cef5555b6030de0695">gr::interface_null_normal</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; DataType, VolumeDim, Frame &gt; * &gt; null_vector, const tnsr::A&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga6b0dfbe004db0edf33e7e7d4e126e77b">spacetime_normal_vector</a>, const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;interface_unit_normal_vector, const double sign)</td></tr>
<tr class="memdesc:gad51b34d6b5c2c1cef5555b6030de0695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute null normal vector to the boundary of a closed region in a spatial slice of spacetime.  <a href="group__GeneralRelativityGroup.html#gad51b34d6b5c2c1cef5555b6030de0695">More...</a><br /></td></tr>
<tr class="separator:gad51b34d6b5c2c1cef5555b6030de0695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacde5276e7ed4b8095b4a153a46476acf"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gacde5276e7ed4b8095b4a153a46476acf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gacde5276e7ed4b8095b4a153a46476acf">gr::inverse_spacetime_metric</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::AA&lt; DataType, SpatialDim, Frame &gt; * &gt; inverse_spacetime_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">lapse</a>, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric)</td></tr>
<tr class="memdesc:gacde5276e7ed4b8095b4a153a46476acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute inverse spacetime metric from inverse spatial metric, lapse and shift.  <a href="group__GeneralRelativityGroup.html#gacde5276e7ed4b8095b4a153a46476acf">More...</a><br /></td></tr>
<tr class="separator:gacde5276e7ed4b8095b4a153a46476acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0806dc5b6f0a4f85a7c862a605886a4c"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga0806dc5b6f0a4f85a7c862a605886a4c"><td class="memTemplItemLeft" align="right" valign="top">tnsr::AA&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga0806dc5b6f0a4f85a7c862a605886a4c">gr::inverse_spacetime_metric</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">lapse</a>, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric)</td></tr>
<tr class="memdesc:ga0806dc5b6f0a4f85a7c862a605886a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute inverse spacetime metric from inverse spatial metric, lapse and shift.  <a href="group__GeneralRelativityGroup.html#ga0806dc5b6f0a4f85a7c862a605886a4c">More...</a><br /></td></tr>
<tr class="separator:ga0806dc5b6f0a4f85a7c862a605886a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e8e9380f2cb257aaa9ca008d6c95bf"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga81e8e9380f2cb257aaa9ca008d6c95bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">gr::lapse</a> (const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga30b4e9ea5a0b87eb9422ad9a975041b9">spacetime_metric</a>)</td></tr>
<tr class="memdesc:ga81e8e9380f2cb257aaa9ca008d6c95bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute lapse from shift and spacetime metric.  <a href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">More...</a><br /></td></tr>
<tr class="separator:ga81e8e9380f2cb257aaa9ca008d6c95bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e4bd55a479b296ffce232442dcf6b4d"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga0e4bd55a479b296ffce232442dcf6b4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga0e4bd55a479b296ffce232442dcf6b4d">gr::lapse</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga30b4e9ea5a0b87eb9422ad9a975041b9">spacetime_metric</a>)</td></tr>
<tr class="memdesc:ga0e4bd55a479b296ffce232442dcf6b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute lapse from shift and spacetime metric.  <a href="group__GeneralRelativityGroup.html#ga0e4bd55a479b296ffce232442dcf6b4d">More...</a><br /></td></tr>
<tr class="separator:ga0e4bd55a479b296ffce232442dcf6b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6471e406bac1d636e2c41f22559fdd0"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gad6471e406bac1d636e2c41f22559fdd0"><td class="memTemplItemLeft" align="right" valign="top">tnsr::II&lt; DataType, VolumeDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gad6471e406bac1d636e2c41f22559fdd0">gr::transverse_projection_operator</a> (const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;inverse_spatial_metric, const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;normal_vector)</td></tr>
<tr class="memdesc:gad6471e406bac1d636e2c41f22559fdd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute projection operator onto an interface.  <a href="group__GeneralRelativityGroup.html#gad6471e406bac1d636e2c41f22559fdd0">More...</a><br /></td></tr>
<tr class="separator:gad6471e406bac1d636e2c41f22559fdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5036a2fa712fa3c111f73e85457383fc"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga5036a2fa712fa3c111f73e85457383fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga5036a2fa712fa3c111f73e85457383fc">gr::transverse_projection_operator</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::II&lt; DataType, VolumeDim, Frame &gt; * &gt; projection_tensor, const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;inverse_spatial_metric, const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;normal_vector)</td></tr>
<tr class="memdesc:ga5036a2fa712fa3c111f73e85457383fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute projection operator onto an interface.  <a href="group__GeneralRelativityGroup.html#ga5036a2fa712fa3c111f73e85457383fc">More...</a><br /></td></tr>
<tr class="separator:ga5036a2fa712fa3c111f73e85457383fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ba489799f45a4cf45306d5376778da"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga51ba489799f45a4cf45306d5376778da"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; DataType, VolumeDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga51ba489799f45a4cf45306d5376778da">gr::transverse_projection_operator</a> (const tnsr::ii&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">spatial_metric</a>, const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;normal_one_form)</td></tr>
<tr class="memdesc:ga51ba489799f45a4cf45306d5376778da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute projection operator onto an interface.  <a href="group__GeneralRelativityGroup.html#ga51ba489799f45a4cf45306d5376778da">More...</a><br /></td></tr>
<tr class="separator:ga51ba489799f45a4cf45306d5376778da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga670675792d7b770c0834813669f77a82"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga670675792d7b770c0834813669f77a82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga670675792d7b770c0834813669f77a82">gr::transverse_projection_operator</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, VolumeDim, Frame &gt; * &gt; projection_tensor, const tnsr::ii&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">spatial_metric</a>, const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;normal_one_form)</td></tr>
<tr class="memdesc:ga670675792d7b770c0834813669f77a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute projection operator onto an interface.  <a href="group__GeneralRelativityGroup.html#ga670675792d7b770c0834813669f77a82">More...</a><br /></td></tr>
<tr class="separator:ga670675792d7b770c0834813669f77a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga700fa05b6a7985e7dd2616eaf7850bb2"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga700fa05b6a7985e7dd2616eaf7850bb2"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; DataType, VolumeDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga700fa05b6a7985e7dd2616eaf7850bb2">gr::transverse_projection_operator</a> (const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;normal_vector, const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;normal_one_form)</td></tr>
<tr class="memdesc:ga700fa05b6a7985e7dd2616eaf7850bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute projection operator onto an interface.  <a href="group__GeneralRelativityGroup.html#ga700fa05b6a7985e7dd2616eaf7850bb2">More...</a><br /></td></tr>
<tr class="separator:ga700fa05b6a7985e7dd2616eaf7850bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf55c99456de6de100b7169597aff2723"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gaf55c99456de6de100b7169597aff2723"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gaf55c99456de6de100b7169597aff2723">gr::transverse_projection_operator</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::Ij&lt; DataType, VolumeDim, Frame &gt; * &gt; projection_tensor, const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;normal_vector, const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;normal_one_form)</td></tr>
<tr class="memdesc:gaf55c99456de6de100b7169597aff2723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute projection operator onto an interface.  <a href="group__GeneralRelativityGroup.html#gaf55c99456de6de100b7169597aff2723">More...</a><br /></td></tr>
<tr class="separator:gaf55c99456de6de100b7169597aff2723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a9149328dbeb565834619b8d10f1eae"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga5a9149328dbeb565834619b8d10f1eae"><td class="memTemplItemLeft" align="right" valign="top">tnsr::aa&lt; DataType, VolumeDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga5a9149328dbeb565834619b8d10f1eae">gr::transverse_projection_operator</a> (const tnsr::aa&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga30b4e9ea5a0b87eb9422ad9a975041b9">spacetime_metric</a>, const tnsr::a&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="namespacegr.html#a9bd0748d415551a9435525d016e2fb19">spacetime_normal_one_form</a>, const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;interface_unit_normal_one_form)</td></tr>
<tr class="memdesc:ga5a9149328dbeb565834619b8d10f1eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute spacetime projection operator onto an interface.  <a href="group__GeneralRelativityGroup.html#ga5a9149328dbeb565834619b8d10f1eae">More...</a><br /></td></tr>
<tr class="separator:ga5a9149328dbeb565834619b8d10f1eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeda525bdfde12746a8794e1c17e0cd84"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gaeda525bdfde12746a8794e1c17e0cd84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gaeda525bdfde12746a8794e1c17e0cd84">gr::transverse_projection_operator</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; DataType, VolumeDim, Frame &gt; * &gt; projection_tensor, const tnsr::aa&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga30b4e9ea5a0b87eb9422ad9a975041b9">spacetime_metric</a>, const tnsr::a&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="namespacegr.html#a9bd0748d415551a9435525d016e2fb19">spacetime_normal_one_form</a>, const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;interface_unit_normal_one_form)</td></tr>
<tr class="memdesc:gaeda525bdfde12746a8794e1c17e0cd84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute spacetime projection operator onto an interface.  <a href="group__GeneralRelativityGroup.html#gaeda525bdfde12746a8794e1c17e0cd84">More...</a><br /></td></tr>
<tr class="separator:gaeda525bdfde12746a8794e1c17e0cd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0b22f7c57d918868278ed0b1e4d0d4"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga8c0b22f7c57d918868278ed0b1e4d0d4"><td class="memTemplItemLeft" align="right" valign="top">tnsr::AA&lt; DataType, VolumeDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga8c0b22f7c57d918868278ed0b1e4d0d4">gr::transverse_projection_operator</a> (const tnsr::AA&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gacde5276e7ed4b8095b4a153a46476acf">inverse_spacetime_metric</a>, const tnsr::A&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga6b0dfbe004db0edf33e7e7d4e126e77b">spacetime_normal_vector</a>, const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;interface_unit_normal_vector)</td></tr>
<tr class="memdesc:ga8c0b22f7c57d918868278ed0b1e4d0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute spacetime projection operator onto an interface.  <a href="group__GeneralRelativityGroup.html#ga8c0b22f7c57d918868278ed0b1e4d0d4">More...</a><br /></td></tr>
<tr class="separator:ga8c0b22f7c57d918868278ed0b1e4d0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga622250f5d3b6cfd6d12844b5d3998d2d"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga622250f5d3b6cfd6d12844b5d3998d2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga622250f5d3b6cfd6d12844b5d3998d2d">gr::transverse_projection_operator</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::AA&lt; DataType, VolumeDim, Frame &gt; * &gt; projection_tensor, const tnsr::AA&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gacde5276e7ed4b8095b4a153a46476acf">inverse_spacetime_metric</a>, const tnsr::A&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga6b0dfbe004db0edf33e7e7d4e126e77b">spacetime_normal_vector</a>, const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;interface_unit_normal_vector)</td></tr>
<tr class="memdesc:ga622250f5d3b6cfd6d12844b5d3998d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute spacetime projection operator onto an interface.  <a href="group__GeneralRelativityGroup.html#ga622250f5d3b6cfd6d12844b5d3998d2d">More...</a><br /></td></tr>
<tr class="separator:ga622250f5d3b6cfd6d12844b5d3998d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada26975d50b5054c09b8476eb09d5daf"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gada26975d50b5054c09b8476eb09d5daf"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ab&lt; DataType, VolumeDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gada26975d50b5054c09b8476eb09d5daf">gr::transverse_projection_operator</a> (const tnsr::A&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga6b0dfbe004db0edf33e7e7d4e126e77b">spacetime_normal_vector</a>, const tnsr::a&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="namespacegr.html#a9bd0748d415551a9435525d016e2fb19">spacetime_normal_one_form</a>, const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;interface_unit_normal_vector, const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;interface_unit_normal_one_form)</td></tr>
<tr class="memdesc:gada26975d50b5054c09b8476eb09d5daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute spacetime projection operator onto an interface.  <a href="group__GeneralRelativityGroup.html#gada26975d50b5054c09b8476eb09d5daf">More...</a><br /></td></tr>
<tr class="separator:gada26975d50b5054c09b8476eb09d5daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d298c7ff2b19fccb9d7f3c7e15e4c5c"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga2d298c7ff2b19fccb9d7f3c7e15e4c5c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga2d298c7ff2b19fccb9d7f3c7e15e4c5c">gr::transverse_projection_operator</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::Ab&lt; DataType, VolumeDim, Frame &gt; * &gt; projection_tensor, const tnsr::A&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga6b0dfbe004db0edf33e7e7d4e126e77b">spacetime_normal_vector</a>, const tnsr::a&lt; DataType, VolumeDim, Frame &gt; &amp;<a class="el" href="namespacegr.html#a9bd0748d415551a9435525d016e2fb19">spacetime_normal_one_form</a>, const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;interface_unit_normal_vector, const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;interface_unit_normal_one_form)</td></tr>
<tr class="memdesc:ga2d298c7ff2b19fccb9d7f3c7e15e4c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute spacetime projection operator onto an interface.  <a href="group__GeneralRelativityGroup.html#ga2d298c7ff2b19fccb9d7f3c7e15e4c5c">More...</a><br /></td></tr>
<tr class="separator:ga2d298c7ff2b19fccb9d7f3c7e15e4c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c14854d87204ccf2c23f86d83ffbe7"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </td></tr>
<tr class="memitem:gad1c14854d87204ccf2c23f86d83ffbe7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gad1c14854d87204ccf2c23f86d83ffbe7">gr::ricci_tensor</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; * &gt; result, const tnsr::Abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;christoffel_2nd_kind, const tnsr::aBcc&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;d_christoffel_2nd_kind)</td></tr>
<tr class="memdesc:gad1c14854d87204ccf2c23f86d83ffbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Ricci tensor from the (spatial or spacetime) Christoffel symbol of the second kind and its derivative.  <a href="group__GeneralRelativityGroup.html#gad1c14854d87204ccf2c23f86d83ffbe7">More...</a><br /></td></tr>
<tr class="separator:gad1c14854d87204ccf2c23f86d83ffbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ffac4782003855a5228dbd8a0efe624"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </td></tr>
<tr class="memitem:ga8ffac4782003855a5228dbd8a0efe624"><td class="memTemplItemLeft" align="right" valign="top">tnsr::aa&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga8ffac4782003855a5228dbd8a0efe624">gr::ricci_tensor</a> (const tnsr::Abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;christoffel_2nd_kind, const tnsr::aBcc&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;d_christoffel_2nd_kind)</td></tr>
<tr class="memdesc:ga8ffac4782003855a5228dbd8a0efe624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Ricci tensor from the (spatial or spacetime) Christoffel symbol of the second kind and its derivative.  <a href="group__GeneralRelativityGroup.html#ga8ffac4782003855a5228dbd8a0efe624">More...</a><br /></td></tr>
<tr class="separator:ga8ffac4782003855a5228dbd8a0efe624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42e3e01038fdee8881b28dfe7183d88c"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </td></tr>
<tr class="memitem:ga42e3e01038fdee8881b28dfe7183d88c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga42e3e01038fdee8881b28dfe7183d88c">gr::ricci_scalar</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; ricci_scalar_result, const tnsr::aa&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gad1c14854d87204ccf2c23f86d83ffbe7">ricci_tensor</a>, const tnsr::AA&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;inverse_metric)</td></tr>
<tr class="memdesc:ga42e3e01038fdee8881b28dfe7183d88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Ricci Scalar from the (spatial or spacetime) Ricci Tensor and inverse metrics.  <a href="group__GeneralRelativityGroup.html#ga42e3e01038fdee8881b28dfe7183d88c">More...</a><br /></td></tr>
<tr class="separator:ga42e3e01038fdee8881b28dfe7183d88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ec90adc22e0707820bdc1c4dd8b11f"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </td></tr>
<tr class="memitem:gaf0ec90adc22e0707820bdc1c4dd8b11f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gaf0ec90adc22e0707820bdc1c4dd8b11f">gr::ricci_scalar</a> (const tnsr::aa&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gad1c14854d87204ccf2c23f86d83ffbe7">ricci_tensor</a>, const tnsr::AA&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;inverse_metric)</td></tr>
<tr class="memdesc:gaf0ec90adc22e0707820bdc1c4dd8b11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Ricci Scalar from the (spatial or spacetime) Ricci Tensor and inverse metrics.  <a href="group__GeneralRelativityGroup.html#gaf0ec90adc22e0707820bdc1c4dd8b11f">More...</a><br /></td></tr>
<tr class="separator:gaf0ec90adc22e0707820bdc1c4dd8b11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a9d8994cd4fee91a6d4971ac14a31f1"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga8a9d8994cd4fee91a6d4971ac14a31f1"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">gr::shift</a> (const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga30b4e9ea5a0b87eb9422ad9a975041b9">spacetime_metric</a>, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric)</td></tr>
<tr class="memdesc:ga8a9d8994cd4fee91a6d4971ac14a31f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute shift from spacetime metric and inverse spatial metric.  <a href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">More...</a><br /></td></tr>
<tr class="separator:ga8a9d8994cd4fee91a6d4971ac14a31f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25bc5f470d173570d5de82508ca793a4"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga25bc5f470d173570d5de82508ca793a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga25bc5f470d173570d5de82508ca793a4">gr::shift</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; DataType, SpatialDim, Frame &gt; * &gt; shift, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga30b4e9ea5a0b87eb9422ad9a975041b9">spacetime_metric</a>, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric)</td></tr>
<tr class="memdesc:ga25bc5f470d173570d5de82508ca793a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute shift from spacetime metric and inverse spatial metric.  <a href="group__GeneralRelativityGroup.html#ga25bc5f470d173570d5de82508ca793a4">More...</a><br /></td></tr>
<tr class="separator:ga25bc5f470d173570d5de82508ca793a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30b4e9ea5a0b87eb9422ad9a975041b9"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga30b4e9ea5a0b87eb9422ad9a975041b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga30b4e9ea5a0b87eb9422ad9a975041b9">gr::spacetime_metric</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; DataType, Dim, Frame &gt; * &gt; spacetime_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">lapse</a>, const tnsr::I&lt; DataType, Dim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>, const tnsr::ii&lt; DataType, Dim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">spatial_metric</a>)</td></tr>
<tr class="memdesc:ga30b4e9ea5a0b87eb9422ad9a975041b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spacetime metric from the spatial metric, lapse, and shift.  <a href="group__GeneralRelativityGroup.html#ga30b4e9ea5a0b87eb9422ad9a975041b9">More...</a><br /></td></tr>
<tr class="separator:ga30b4e9ea5a0b87eb9422ad9a975041b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dd05fc035883d0919a7b055460fa9a3"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga6dd05fc035883d0919a7b055460fa9a3"><td class="memTemplItemLeft" align="right" valign="top">tnsr::aa&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga6dd05fc035883d0919a7b055460fa9a3">gr::spacetime_metric</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">lapse</a>, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">spatial_metric</a>)</td></tr>
<tr class="memdesc:ga6dd05fc035883d0919a7b055460fa9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spacetime metric from the spatial metric, lapse, and shift.  <a href="group__GeneralRelativityGroup.html#ga6dd05fc035883d0919a7b055460fa9a3">More...</a><br /></td></tr>
<tr class="separator:ga6dd05fc035883d0919a7b055460fa9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b0dfbe004db0edf33e7e7d4e126e77b"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga6b0dfbe004db0edf33e7e7d4e126e77b"><td class="memTemplItemLeft" align="right" valign="top">tnsr::A&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga6b0dfbe004db0edf33e7e7d4e126e77b">gr::spacetime_normal_vector</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">lapse</a>, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>)</td></tr>
<tr class="memdesc:ga6b0dfbe004db0edf33e7e7d4e126e77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spacetime normal vector from lapse and shift.  <a href="group__GeneralRelativityGroup.html#ga6b0dfbe004db0edf33e7e7d4e126e77b">More...</a><br /></td></tr>
<tr class="separator:ga6b0dfbe004db0edf33e7e7d4e126e77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf34b7d587da726aca87ab2754dcbab94"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gaf34b7d587da726aca87ab2754dcbab94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gaf34b7d587da726aca87ab2754dcbab94">gr::spacetime_normal_vector</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; DataType, SpatialDim, Frame &gt; * &gt; spacetime_normal_vector, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">lapse</a>, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>)</td></tr>
<tr class="memdesc:gaf34b7d587da726aca87ab2754dcbab94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes spacetime normal vector from lapse and shift.  <a href="group__GeneralRelativityGroup.html#gaf34b7d587da726aca87ab2754dcbab94">More...</a><br /></td></tr>
<tr class="separator:gaf34b7d587da726aca87ab2754dcbab94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga629c4a81eec057b08972c870bac4319d"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga629c4a81eec057b08972c870bac4319d"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">gr::spatial_metric</a> (const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga30b4e9ea5a0b87eb9422ad9a975041b9">spacetime_metric</a>)</td></tr>
<tr class="memdesc:ga629c4a81eec057b08972c870bac4319d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute spatial metric from spacetime metric.  <a href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">More...</a><br /></td></tr>
<tr class="separator:ga629c4a81eec057b08972c870bac4319d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a6a6581e60141273cabb6c1fb29ed8b"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga6a6a6581e60141273cabb6c1fb29ed8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga6a6a6581e60141273cabb6c1fb29ed8b">gr::spatial_metric</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, SpatialDim, Frame &gt; * &gt; spatial_metric, const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga30b4e9ea5a0b87eb9422ad9a975041b9">spacetime_metric</a>)</td></tr>
<tr class="memdesc:ga6a6a6581e60141273cabb6c1fb29ed8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute spatial metric from spacetime metric.  <a href="group__GeneralRelativityGroup.html#ga6a6a6581e60141273cabb6c1fb29ed8b">More...</a><br /></td></tr>
<tr class="separator:ga6a6a6581e60141273cabb6c1fb29ed8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga726297e2de76748fc7349184eca75839"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga726297e2de76748fc7349184eca75839"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga726297e2de76748fc7349184eca75839">gr::time_derivative_of_spacetime_metric</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; DataType, SpatialDim, Frame &gt; * &gt; dt_spacetime_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">lapse</a>, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;dt_lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;dt_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">spatial_metric</a>, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;dt_spatial_metric)</td></tr>
<tr class="memdesc:ga726297e2de76748fc7349184eca75839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the time derivative of the spacetime metric from spatial metric, lapse, shift, and their time derivatives.  <a href="group__GeneralRelativityGroup.html#ga726297e2de76748fc7349184eca75839">More...</a><br /></td></tr>
<tr class="separator:ga726297e2de76748fc7349184eca75839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5b28f7c0048f1ce5d108496f47dadf4"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gab5b28f7c0048f1ce5d108496f47dadf4"><td class="memTemplItemLeft" align="right" valign="top">tnsr::aa&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gab5b28f7c0048f1ce5d108496f47dadf4">gr::time_derivative_of_spacetime_metric</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">lapse</a>, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;dt_lapse, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;dt_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">spatial_metric</a>, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;dt_spatial_metric)</td></tr>
<tr class="memdesc:gab5b28f7c0048f1ce5d108496f47dadf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the time derivative of the spacetime metric from spatial metric, lapse, shift, and their time derivatives.  <a href="group__GeneralRelativityGroup.html#gab5b28f7c0048f1ce5d108496f47dadf4">More...</a><br /></td></tr>
<tr class="separator:gab5b28f7c0048f1ce5d108496f47dadf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02abbd1da4fe227e9b79b0a1799647b4"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga02abbd1da4fe227e9b79b0a1799647b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga02abbd1da4fe227e9b79b0a1799647b4">gr::time_derivative_of_spatial_metric</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, SpatialDim, Frame &gt; * &gt; dt_spatial_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">lapse</a>, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>, const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">spatial_metric</a>, const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_spatial_metric, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaf8e85f342b2cd915e8d75675277df689">extrinsic_curvature</a>)</td></tr>
<tr class="memdesc:ga02abbd1da4fe227e9b79b0a1799647b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the time derivative of the spatial metric from extrinsic curvature, lapse, shift, and their time derivatives.  <a href="group__GeneralRelativityGroup.html#ga02abbd1da4fe227e9b79b0a1799647b4">More...</a><br /></td></tr>
<tr class="separator:ga02abbd1da4fe227e9b79b0a1799647b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ac9fe1029ccaaf32f8ed898708dbbc3"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga8ac9fe1029ccaaf32f8ed898708dbbc3"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga8ac9fe1029ccaaf32f8ed898708dbbc3">gr::time_derivative_of_spatial_metric</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga81e8e9380f2cb257aaa9ca008d6c95bf">lapse</a>, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga8a9d8994cd4fee91a6d4971ac14a31f1">shift</a>, const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_shift, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">spatial_metric</a>, const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;deriv_spatial_metric, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaf8e85f342b2cd915e8d75675277df689">extrinsic_curvature</a>)</td></tr>
<tr class="memdesc:ga8ac9fe1029ccaaf32f8ed898708dbbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the time derivative of the spatial metric from extrinsic curvature, lapse, shift, and their time derivatives.  <a href="group__GeneralRelativityGroup.html#ga8ac9fe1029ccaaf32f8ed898708dbbc3">More...</a><br /></td></tr>
<tr class="separator:ga8ac9fe1029ccaaf32f8ed898708dbbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f4b751ba525894f2ffb296607618cec"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename SrcFrame , typename DestFrame &gt; </td></tr>
<tr class="memitem:ga7f4b751ba525894f2ffb296607618cec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga7f4b751ba525894f2ffb296607618cec">transform::to_different_frame</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame &gt; * &gt; dest, const tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, SrcFrame &gt; &amp;src, const Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame, SrcFrame &gt; &amp;jacobian)</td></tr>
<tr class="separator:ga7f4b751ba525894f2ffb296607618cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga859a079f096cec1caa989e6c9d1fede7"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename SrcFrame , typename DestFrame &gt; </td></tr>
<tr class="memitem:ga859a079f096cec1caa989e6c9d1fede7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga859a079f096cec1caa989e6c9d1fede7">transform::to_different_frame</a> (const tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, SrcFrame &gt; &amp;src, const Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame, SrcFrame &gt; &amp;jacobian) -&gt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame &gt;</td></tr>
<tr class="separator:ga859a079f096cec1caa989e6c9d1fede7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a5680c46a3e16f25d4087e94d8c3804"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename SrcFrame , typename DestFrame &gt; </td></tr>
<tr class="memitem:ga8a5680c46a3e16f25d4087e94d8c3804"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga8a5680c46a3e16f25d4087e94d8c3804">transform::first_index_to_different_frame</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ijj&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame &gt; * &gt; dest, const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, tmpl::integral_list&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, 2, 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; VolumeDim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, SrcFrame &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; VolumeDim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, DestFrame &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; VolumeDim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, DestFrame &gt;&gt;&gt; &amp;src, const Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame, SrcFrame &gt; &amp;jacobian)</td></tr>
<tr class="separator:ga8a5680c46a3e16f25d4087e94d8c3804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac39514d667954de838416235250c431a"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename SrcFrame , typename DestFrame &gt; </td></tr>
<tr class="memitem:gac39514d667954de838416235250c431a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gac39514d667954de838416235250c431a">transform::first_index_to_different_frame</a> (const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, tmpl::integral_list&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, 2, 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; VolumeDim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, SrcFrame &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; VolumeDim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, DestFrame &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; VolumeDim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, DestFrame &gt;&gt;&gt; &amp;src, const Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame, SrcFrame &gt; &amp;jacobian) -&gt; tnsr::ijj&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame &gt;</td></tr>
<tr class="separator:gac39514d667954de838416235250c431a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58ecf9d4b12748cf43c16010f7e214d"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gae58ecf9d4b12748cf43c16010f7e214d"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gae58ecf9d4b12748cf43c16010f7e214d">gr::weyl_electric</a> (const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;spatial_ricci, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaf8e85f342b2cd915e8d75675277df689">extrinsic_curvature</a>, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric)</td></tr>
<tr class="memdesc:gae58ecf9d4b12748cf43c16010f7e214d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the electric part of the Weyl tensor in vacuum.  <a href="group__GeneralRelativityGroup.html#gae58ecf9d4b12748cf43c16010f7e214d">More...</a><br /></td></tr>
<tr class="separator:gae58ecf9d4b12748cf43c16010f7e214d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2c188cf0426776e831a65d8af1ab5b"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga2d2c188cf0426776e831a65d8af1ab5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga2d2c188cf0426776e831a65d8af1ab5b">gr::weyl_electric</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, SpatialDim, Frame &gt; * &gt; weyl_electric_part, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;spatial_ricci, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaf8e85f342b2cd915e8d75675277df689">extrinsic_curvature</a>, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric)</td></tr>
<tr class="memdesc:ga2d2c188cf0426776e831a65d8af1ab5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the electric part of the Weyl tensor in vacuum.  <a href="group__GeneralRelativityGroup.html#ga2d2c188cf0426776e831a65d8af1ab5b">More...</a><br /></td></tr>
<tr class="separator:ga2d2c188cf0426776e831a65d8af1ab5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7293171d21f1d5acd0305908034c75a9"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga7293171d21f1d5acd0305908034c75a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga7293171d21f1d5acd0305908034c75a9">gr::weyl_electric_scalar</a> (const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gae58ecf9d4b12748cf43c16010f7e214d">weyl_electric</a>, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric)</td></tr>
<tr class="memdesc:ga7293171d21f1d5acd0305908034c75a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar \(E_{ij} E^{ij}\) from the electric part of the Weyl tensor \(E_{ij}\).  <a href="group__GeneralRelativityGroup.html#ga7293171d21f1d5acd0305908034c75a9">More...</a><br /></td></tr>
<tr class="separator:ga7293171d21f1d5acd0305908034c75a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5e668ec48e7a29fdf364805dddde395"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gac5e668ec48e7a29fdf364805dddde395"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gac5e668ec48e7a29fdf364805dddde395">gr::weyl_electric_scalar</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; weyl_electric_scalar_result, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gae58ecf9d4b12748cf43c16010f7e214d">weyl_electric</a>, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric)</td></tr>
<tr class="memdesc:gac5e668ec48e7a29fdf364805dddde395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar \(E_{ij} E^{ij}\) from the electric part of the Weyl tensor \(E_{ij}\).  <a href="group__GeneralRelativityGroup.html#gac5e668ec48e7a29fdf364805dddde395">More...</a><br /></td></tr>
<tr class="separator:gac5e668ec48e7a29fdf364805dddde395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d9630ccce9b0b9ab6d4492446d8f751"><td class="memTemplParams" colspan="2">template&lt;typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga9d9630ccce9b0b9ab6d4492446d8f751"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; DataType, 3, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga9d9630ccce9b0b9ab6d4492446d8f751">gr::weyl_magnetic</a> (const tnsr::ijj&lt; DataType, 3, Frame &gt; &amp;grad_extrinsic_curvature, const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">spatial_metric</a>, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;sqrt_det_spatial_metric)</td></tr>
<tr class="memdesc:ga9d9630ccce9b0b9ab6d4492446d8f751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the magnetic part of the Weyl tensor.  <a href="group__GeneralRelativityGroup.html#ga9d9630ccce9b0b9ab6d4492446d8f751">More...</a><br /></td></tr>
<tr class="separator:ga9d9630ccce9b0b9ab6d4492446d8f751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c44307d13655ed62414c7377b33290"><td class="memTemplParams" colspan="2">template&lt;typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gab9c44307d13655ed62414c7377b33290"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gab9c44307d13655ed62414c7377b33290">gr::weyl_magnetic</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, 3, Frame &gt; * &gt; weyl_magnetic_part, const tnsr::ijj&lt; DataType, 3, Frame &gt; &amp;grad_extrinsic_curvature, const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga629c4a81eec057b08972c870bac4319d">spatial_metric</a>, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;sqrt_det_spatial_metric)</td></tr>
<tr class="memdesc:gab9c44307d13655ed62414c7377b33290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the magnetic part of the Weyl tensor.  <a href="group__GeneralRelativityGroup.html#gab9c44307d13655ed62414c7377b33290">More...</a><br /></td></tr>
<tr class="separator:gab9c44307d13655ed62414c7377b33290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe3afc42cb2db28524fb337c4b7ece55"><td class="memTemplParams" colspan="2">template&lt;typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gabe3afc42cb2db28524fb337c4b7ece55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gabe3afc42cb2db28524fb337c4b7ece55">gr::weyl_magnetic_scalar</a> (const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga9d9630ccce9b0b9ab6d4492446d8f751">weyl_magnetic</a>, const tnsr::II&lt; DataType, 3, Frame &gt; &amp;inverse_spatial_metric)</td></tr>
<tr class="memdesc:gabe3afc42cb2db28524fb337c4b7ece55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar \(B_{ij} B^{ij}\) from the magnetic part of the Weyl tensor \(B_{ij}\).  <a href="group__GeneralRelativityGroup.html#gabe3afc42cb2db28524fb337c4b7ece55">More...</a><br /></td></tr>
<tr class="separator:gabe3afc42cb2db28524fb337c4b7ece55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac43d0aded3ba8ae48e43c2ec79635390"><td class="memTemplParams" colspan="2">template&lt;typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gac43d0aded3ba8ae48e43c2ec79635390"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gac43d0aded3ba8ae48e43c2ec79635390">gr::weyl_magnetic_scalar</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; weyl_magnetic_scalar_result, const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#ga9d9630ccce9b0b9ab6d4492446d8f751">weyl_magnetic</a>, const tnsr::II&lt; DataType, 3, Frame &gt; &amp;inverse_spatial_metric)</td></tr>
<tr class="memdesc:gac43d0aded3ba8ae48e43c2ec79635390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar \(B_{ij} B^{ij}\) from the magnetic part of the Weyl tensor \(B_{ij}\).  <a href="group__GeneralRelativityGroup.html#gac43d0aded3ba8ae48e43c2ec79635390">More...</a><br /></td></tr>
<tr class="separator:gac43d0aded3ba8ae48e43c2ec79635390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57de98a26ae1837eb2b4c66ce6fcf43b"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga57de98a26ae1837eb2b4c66ce6fcf43b"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#ga57de98a26ae1837eb2b4c66ce6fcf43b">gr::weyl_propagating</a> (const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;ricci, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaf8e85f342b2cd915e8d75675277df689">extrinsic_curvature</a>, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric, const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;cov_deriv_extrinsic_curvature, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;unit_interface_normal_vector, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;projection_IJ, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;projection_ij, const tnsr::Ij&lt; DataType, SpatialDim, Frame &gt; &amp;projection_Ij, const double sign)</td></tr>
<tr class="memdesc:ga57de98a26ae1837eb2b4c66ce6fcf43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the propagating modes of the Weyl tensor.  <a href="group__GeneralRelativityGroup.html#ga57de98a26ae1837eb2b4c66ce6fcf43b">More...</a><br /></td></tr>
<tr class="separator:ga57de98a26ae1837eb2b4c66ce6fcf43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54931bb321adb90f721b48601711289"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gac54931bb321adb90f721b48601711289"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeneralRelativityGroup.html#gac54931bb321adb90f721b48601711289">gr::weyl_propagating</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, SpatialDim, Frame &gt; * &gt; weyl_prop_u8, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;ricci, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;<a class="el" href="group__GeneralRelativityGroup.html#gaf8e85f342b2cd915e8d75675277df689">extrinsic_curvature</a>, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;inverse_spatial_metric, const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;cov_deriv_extrinsic_curvature, const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;unit_interface_normal_vector, const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;projection_IJ, const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;projection_ij, const tnsr::Ij&lt; DataType, SpatialDim, Frame &gt; &amp;projection_Ij, const double sign)</td></tr>
<tr class="memdesc:gac54931bb321adb90f721b48601711289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the propagating modes of the Weyl tensor.  <a href="group__GeneralRelativityGroup.html#gac54931bb321adb90f721b48601711289">More...</a><br /></td></tr>
<tr class="separator:gac54931bb321adb90f721b48601711289"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Contains functions used in General Relativistic simulations. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae077e6edabfd3953880c9ff6e1339cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae077e6edabfd3953880c9ff6e1339cad">&#9670;&nbsp;</a></span>christoffel_first_kind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::abb&lt;DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a>&gt; gr::christoffel_first_kind </td>
          <td>(</td>
          <td class="paramtype">const tnsr::abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_metric</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Christoffel symbol of the first kind from derivative of metric. </p>
<h3>Details</h3>
<p>Computes Christoffel symbol \(\Gamma_{abc}\) as: \( \Gamma_{cab} = \frac{1}{2} ( \partial_a g_{bc} + \partial_b g_{ac} - \partial_c g_{ab}) \) where \(g_{bc}\) is either a spatial or spacetime metric </p>

</div>
</div>
<a id="ga7a3c0b734b2c1ccaed28ad19e625521c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a3c0b734b2c1ccaed28ad19e625521c">&#9670;&nbsp;</a></span>christoffel_first_kind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::christoffel_first_kind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>christoffel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Christoffel symbol of the first kind from derivative of metric. </p>
<h3>Details</h3>
<p>Computes Christoffel symbol \(\Gamma_{abc}\) as: \( \Gamma_{cab} = \frac{1}{2} ( \partial_a g_{bc} + \partial_b g_{ac} - \partial_c g_{ab}) \) where \(g_{bc}\) is either a spatial or spacetime metric </p>

</div>
</div>
<a id="gac0338cd790d56504c9727bcd8b73b7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0338cd790d56504c9727bcd8b73b7c3">&#9670;&nbsp;</a></span>christoffel_second_kind() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::christoffel_second_kind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::Abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>christoffel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Christoffel symbol of the second kind from derivative of metric and the inverse metric. </p>
<h3>Details</h3>
<p>Computes Christoffel symbol \(\Gamma^a_{bc}\) as: \( \Gamma^d_{ab} = \frac{1}{2} g^{cd} (\partial_a g_{bc} + \partial_b g_{ac} - \partial_c g_{ab}) \) where \(g_{bc}\) is either a spatial or spacetime metric.</p>
<p>Avoids the extra memory allocation that occurs by computing the Christoffel symbol of the first kind and then raising the index. </p>

</div>
</div>
<a id="ga96f20e1c2caf499f4a38e86f3a815ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96f20e1c2caf499f4a38e86f3a815ae8">&#9670;&nbsp;</a></span>christoffel_second_kind() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::christoffel_second_kind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::Ijj&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>christoffel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spatial Christoffel symbol of the 2nd kind from the the generalized harmonic spatial derivative variable and the inverse spatial metric. </p>
<h3>Details</h3>
<p>If \( \Phi_{kab} \) is the generalized harmonic spatial derivative variable \( \Phi_{kab} = \partial_k g_{ab}\) and \(\gamma^{ij}\) is the inverse spatial metric, the Christoffel symbols are </p><p class="formulaDsp">
\[ \Gamma^m_{ij} = \frac{1}{2}\gamma^{mk}(\Phi_{ijk}+\Phi_{jik}-\Phi_{kij}). \]
</p>
<p>In the not_null version, no memory allocations are performed if the output tensor already has the correct size. </p>

</div>
</div>
<a id="ga6bf19664f25e3ca9689059194515d1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bf19664f25e3ca9689059194515d1cb">&#9670;&nbsp;</a></span>christoffel_second_kind() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gr::christoffel_second_kind </td>
          <td>(</td>
          <td class="paramtype">const tnsr::abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  tnsr::Abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Christoffel symbol of the second kind from derivative of metric and the inverse metric. </p>
<h3>Details</h3>
<p>Computes Christoffel symbol \(\Gamma^a_{bc}\) as: \( \Gamma^d_{ab} = \frac{1}{2} g^{cd} (\partial_a g_{bc} + \partial_b g_{ac} - \partial_c g_{ab}) \) where \(g_{bc}\) is either a spatial or spacetime metric.</p>
<p>Avoids the extra memory allocation that occurs by computing the Christoffel symbol of the first kind and then raising the index. </p>

</div>
</div>
<a id="ga203a5bd4ab96b6343791c3f05e43c099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga203a5bd4ab96b6343791c3f05e43c099">&#9670;&nbsp;</a></span>christoffel_second_kind() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto GeneralizedHarmonic::christoffel_second_kind </td>
          <td>(</td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  tnsr::Ijj&lt; DataType, SpatialDim, Frame &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spatial Christoffel symbol of the 2nd kind from the the generalized harmonic spatial derivative variable and the inverse spatial metric. </p>
<h3>Details</h3>
<p>If \( \Phi_{kab} \) is the generalized harmonic spatial derivative variable \( \Phi_{kab} = \partial_k g_{ab}\) and \(\gamma^{ij}\) is the inverse spatial metric, the Christoffel symbols are </p><p class="formulaDsp">
\[ \Gamma^m_{ij} = \frac{1}{2}\gamma^{mk}(\Phi_{ijk}+\Phi_{jik}-\Phi_{kij}). \]
</p>
<p>In the not_null version, no memory allocations are performed if the output tensor already has the correct size. </p>

</div>
</div>
<a id="gab5d66e2b74cff67d1fd5e1f29a82b5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5d66e2b74cff67d1fd5e1f29a82b5b3">&#9670;&nbsp;</a></span>covariant_deriv_of_extrinsic_curvature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ijj&lt;DataType, SpatialDim, Frame&gt; GeneralizedHarmonic::covariant_deriv_of_extrinsic_curvature </td>
          <td>(</td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>extrinsic_curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_unit_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::Ijj&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_christoffel_second_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_pi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the covariant derivative of extrinsic curvature from generalized harmonic variables and the spacetime normal vector. </p>
<h3>Details</h3>
<p>If \( \Pi_{ab} \) and \( \Phi_{iab} \) are the generalized harmonic conjugate momentum and spatial derivative variables, and if \(n^a\) is the spacetime normal vector, then the extrinsic curvature can be written as </p><p class="formulaDsp">
\begin{equation}\label{eq:kij} K_{ij} = \frac{1}{2} \Pi_{ij} + \Phi_{(ij)a} n^a, \end{equation}
</p>
<p> and its covariant derivative as </p><p class="formulaDsp">
\begin{equation}\label{eq:covkij} \nabla_k K_{ij} = \partial_k K_{ij} - \Gamma^l{}_{ik} K_{lj} - \Gamma^l{}_{jk} K_{li}, \end{equation}
</p>
<p> where \(\Gamma^k{}_{ij}\) are Christoffel symbols of the second kind. The partial derivatives of extrinsic curvature can be computed as </p><p class="formulaDsp">
\begin{equation}\label{eq:pdkij} \partial_k K_{ij} = \frac{1}{2}\left(\partial_k \Pi_{ij} + \left(\partial_k \Phi_{ija} + \partial_k \Phi_{jia}\right) n^a + \left(\Phi_{ija} + \Phi_{jia}\right) \partial_k n^a \right), \end{equation}
</p>
<p> where we have access to all terms except the spatial derivatives of the spacetime unit normal vector \(\partial_k n^a\). Given that \(n^a=(1/\alpha, -\beta^i /\alpha)\), the temporal portion of \(\partial_k n^a\) can be computed as: </p><p class="formulaDsp">
\begin{align} \partial_k n^0 =&amp; -\frac{1}{\alpha^2} \partial_k \alpha, \nonumber \\ =&amp; -\frac{1}{\alpha^2} (-\alpha/2) n^a \Phi_{kab} n^b, \nonumber \\ =&amp; \frac{1}{2\alpha} n^a \Phi_{kab} n^b, \nonumber \\ =&amp; \frac{1}{2} n^0 n^a \Phi_{kab} n^b, \nonumber \\ =&amp; -\left(g^{0a} + \frac{1}{2}n^0 n^a\right) \Phi_{kab} n^b, \end{align}
</p>
<p> where we use the expression for \(\partial_k \alpha\) from <a class="el" href="group__GeneralRelativityGroup.html#gaa4628cbcc3f9df0954efbbfada626806">spatial_deriv_of_lapse</a>; while the spatial portion of the same can be computed as: </p><p class="formulaDsp">
\begin{align} \partial_k n^i =&amp; -\partial_k (\beta^i/\alpha) = -\frac{1}{\alpha}\partial_k \beta^i + \frac{\beta^i}{\alpha^2}\partial_k \alpha ,\nonumber \\ =&amp; -\frac{1}{2}\frac{\beta^i}{\alpha} n^a\Phi_{kab}n^b -\left(g^{ia} + n^i n^a\right) \Phi_{kab} n^b, \nonumber\\ =&amp; -\left(g^{ia} + \frac{1}{2}n^i n^a\right) \Phi_{kab}n^b, \end{align}
</p>
<p> where we use the expression for \(\partial_k \beta^i\) from <a class="el" href="group__GeneralRelativityGroup.html#ga7e61f81f9d1dc3de00e9d246ca338b01">spatial_deriv_of_shift</a>. Combining the last two equations, we find that </p><p class="formulaDsp">
\begin{equation} \partial_k n^a = -\left(g^{ab} + \frac{1}{2}n^a n^b\right)\Phi_{kbc}n^c, \end{equation}
</p>
<p> and using Eq.( \(\ref{eq:covkij}\)) and Eq.( \(\ref{eq:pdkij}\)) with this, we can compute the covariant derivative of the extrinsic curvature as: </p><p class="formulaDsp">
\begin{equation} \nabla_k K_{ij} = \frac{1}{2}\left(\partial_k \Pi_{ij} + \left(\partial_k \Phi_{ija} + \partial_k \Phi_{jia}\right) n^a - \left(\Phi_{ija} + \Phi_{jia}\right) \left(g^{ab} + \frac{1}{2}n^a n^b\right) \Phi_{kbc}n^c \right) - \Gamma^l{}_{ik} K_{lj} - \Gamma^l{}_{jk} K_{li} \end{equation}
</p>
<p>. </p>

</div>
</div>
<a id="ga8fc9e348d45cf3973d46b915fd6985d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fc9e348d45cf3973d46b915fd6985d3">&#9670;&nbsp;</a></span>deriv_inverse_spatial_metric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::deriv_inverse_spatial_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJJ&lt; DataType, Dim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijj&lt; DataType, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the spatial derivative of the inverse spatial metric from the inverse spatial metric and the spatial derivative of the spatial metric. </p>
<h3>Details</h3>
<p>Computes the derivative as: </p><p class="formulaDsp">
\begin{align} \partial_k \gamma^{ij} &amp;= -\gamma^{in} \gamma^{mj} \partial_k \gamma_{nm} \end{align}
</p>
<p> where \(\gamma^{ij}\) and \(\partial_k \gamma_{ij}\) are the inverse spatial metric and spatial derivative of the spatial metric, respectively. </p>

</div>
</div>
<a id="gad95d8093d219ce2004d7c050d1652b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad95d8093d219ce2004d7c050d1652b9e">&#9670;&nbsp;</a></span>deriv_inverse_spatial_metric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::iJJ&lt;DataType, Dim, Frame&gt; gr::deriv_inverse_spatial_metric </td>
          <td>(</td>
          <td class="paramtype">const tnsr::II&lt; DataType, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijj&lt; DataType, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the spatial derivative of the inverse spatial metric from the inverse spatial metric and the spatial derivative of the spatial metric. </p>
<h3>Details</h3>
<p>Computes the derivative as: </p><p class="formulaDsp">
\begin{align} \partial_k \gamma^{ij} &amp;= -\gamma^{in} \gamma^{mj} \partial_k \gamma_{nm} \end{align}
</p>
<p> where \(\gamma^{ij}\) and \(\partial_k \gamma_{ij}\) are the inverse spatial metric and spatial derivative of the spatial metric, respectively. </p>

</div>
</div>
<a id="ga9c7a1ec6b2b2a174328daddf74ca8fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c7a1ec6b2b2a174328daddf74ca8fa0">&#9670;&nbsp;</a></span>deriv_spatial_metric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ijj&lt;DataType, SpatialDim, Frame&gt; GeneralizedHarmonic::deriv_spatial_metric </td>
          <td>(</td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spatial derivatives of the spatial metric from the generalized harmonic spatial derivative variable. </p>
<h3>Details</h3>
<p>If \( \Phi_{kab} \) is the generalized harmonic spatial derivative variable, then the derivatives of the spatial metric are </p><p class="formulaDsp">
\[ \partial_k \gamma_{ij} = \Phi_{kij} \]
</p>
<p>This quantity is needed for computing spatial Christoffel symbols. </p>

</div>
</div>
<a id="gaf7c5b2e62ebc5c027b2a435ab145375b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7c5b2e62ebc5c027b2a435ab145375b">&#9670;&nbsp;</a></span>deriv_spatial_metric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::deriv_spatial_metric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>d_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spatial derivatives of the spatial metric from the generalized harmonic spatial derivative variable. </p>
<h3>Details</h3>
<p>If \( \Phi_{kab} \) is the generalized harmonic spatial derivative variable, then the derivatives of the spatial metric are </p><p class="formulaDsp">
\[ \partial_k \gamma_{ij} = \Phi_{kij} \]
</p>
<p>This quantity is needed for computing spatial Christoffel symbols. </p>

</div>
</div>
<a id="ga5c67523b5f824e0ba85f0c177ba9d487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c67523b5f824e0ba85f0c177ba9d487">&#9670;&nbsp;</a></span>derivatives_of_spacetime_metric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::abb&lt;DataType, SpatialDim, Frame&gt; gr::derivatives_of_spacetime_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spacetime derivative of spacetime metric from spatial metric, lapse, shift, and their space and time derivatives. </p>
<h3>Details</h3>
<p>Computes the derivatives as: </p><p class="formulaDsp">
\begin{align} \partial_\mu g_{tt} &amp;= - 2 \alpha \partial_\mu \alpha + 2 \gamma_{mn} \beta^m \partial_\mu \beta^n + \beta^m \beta^n \partial_\mu \gamma_{mn} \\ \partial_\mu g_{ti} &amp;= \gamma_{mi} \partial_\mu \beta^m + \beta^m \partial_\mu \gamma_{mi} \\ \partial_\mu g_{ij} &amp;= \partial_\mu \gamma_{ij} \end{align}
</p>
<p> where \( \alpha, \beta^i, \gamma_{ij} \) are the lapse, shift, and spatial metric respectively. </p>

</div>
</div>
<a id="ga17e11263157960500c32f1a7dfe804c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17e11263157960500c32f1a7dfe804c4">&#9670;&nbsp;</a></span>derivatives_of_spacetime_metric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::derivatives_of_spacetime_metric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::abb&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>spacetime_deriv_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spacetime derivative of spacetime metric from spatial metric, lapse, shift, and their space and time derivatives. </p>
<h3>Details</h3>
<p>Computes the derivatives as: </p><p class="formulaDsp">
\begin{align} \partial_\mu g_{tt} &amp;= - 2 \alpha \partial_\mu \alpha + 2 \gamma_{mn} \beta^m \partial_\mu \beta^n + \beta^m \beta^n \partial_\mu \gamma_{mn} \\ \partial_\mu g_{ti} &amp;= \gamma_{mi} \partial_\mu \beta^m + \beta^m \partial_\mu \gamma_{mi} \\ \partial_\mu g_{ij} &amp;= \partial_\mu \gamma_{ij} \end{align}
</p>
<p> where \( \alpha, \beta^i, \gamma_{ij} \) are the lapse, shift, and spatial metric respectively. </p>

</div>
</div>
<a id="ga199511bfbac9c5fcf9f7623e0282b7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga199511bfbac9c5fcf9f7623e0282b7ce">&#9670;&nbsp;</a></span>divergence_lapse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Ccz4::divergence_lapse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>conformal_factor_squared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_conformal_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ij&lt; DataType, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_grad_lapse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the divergence of the lapse. </p>
<h3>Details</h3>
<p>Computes the divergence as: </p><p class="formulaDsp">
\begin{align} \nabla^i \nabla_i \alpha &amp;= \phi^2 \tilde{\gamma}^{ij} (\nabla_i \nabla_j \alpha) \end{align}
</p>
<p> where \(\phi\), \(\tilde{\gamma}^{ij}\), and \(\nabla_i \nabla_j \alpha\) are the conformal factor, inverse conformal spatial metric, and the gradient of the gradient of the lapse defined by <code><a class="el" href="structCcz4_1_1Tags_1_1ConformalFactor.html" title="The conformal factor that rescales the spatial metric.">Ccz4::Tags::ConformalFactor</a></code>, <code><a class="el" href="namespaceCcz4_1_1Tags.html#a5e67024f6ce3acd05c6e75d53bd62007" title="The conformally scaled inverse spatial metric.">Ccz4::Tags::InverseConformalMetric</a></code>, and <code><a class="el" href="structCcz4_1_1Tags_1_1GradGradLapse.html" title="The gradient of the gradient of the lapse.">Ccz4::Tags::GradGradLapse</a></code>, respectively. </p>

</div>
</div>
<a id="gacb75d874f73bc5c5fff40feef6dfd26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb75d874f73bc5c5fff40feef6dfd26f">&#9670;&nbsp;</a></span>divergence_lapse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; Ccz4::divergence_lapse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>conformal_factor_squared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_conformal_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ij&lt; DataType, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_grad_lapse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the divergence of the lapse. </p>
<h3>Details</h3>
<p>Computes the divergence as: </p><p class="formulaDsp">
\begin{align} \nabla^i \nabla_i \alpha &amp;= \phi^2 \tilde{\gamma}^{ij} (\nabla_i \nabla_j \alpha) \end{align}
</p>
<p> where \(\phi\), \(\tilde{\gamma}^{ij}\), and \(\nabla_i \nabla_j \alpha\) are the conformal factor, inverse conformal spatial metric, and the gradient of the gradient of the lapse defined by <code><a class="el" href="structCcz4_1_1Tags_1_1ConformalFactor.html" title="The conformal factor that rescales the spatial metric.">Ccz4::Tags::ConformalFactor</a></code>, <code><a class="el" href="namespaceCcz4_1_1Tags.html#a5e67024f6ce3acd05c6e75d53bd62007" title="The conformally scaled inverse spatial metric.">Ccz4::Tags::InverseConformalMetric</a></code>, and <code><a class="el" href="structCcz4_1_1Tags_1_1GradGradLapse.html" title="The gradient of the gradient of the lapse.">Ccz4::Tags::GradGradLapse</a></code>, respectively. </p>

</div>
</div>
<a id="gaf8e85f342b2cd915e8d75675277df689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8e85f342b2cd915e8d75675277df689">&#9670;&nbsp;</a></span>extrinsic_curvature() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt;DataType, SpatialDim, Frame&gt; gr::extrinsic_curvature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes extrinsic curvature from metric and derivatives. </p>
<h3>Details</h3>
<p>Uses the ADM evolution equation for the spatial metric, </p><p class="formulaDsp">
\[ K_{ij} = \frac{1}{2 \alpha} \left ( -\partial_0 \gamma_{ij} + \beta^k \partial_k \gamma_{ij} + \gamma_{ki} \partial_j \beta^k + \gamma_{kj} \partial_i \beta^k \right ) \]
</p>
<p> where \(K_{ij}\) is the extrinsic curvature, \(\alpha\) is the lapse, \(\beta^i\) is the shift, and \(\gamma_{ij}\) is the spatial metric. In terms of the Lie derivative of the spatial metric with respect to a unit timelike vector \(n^a\) normal to the spatial slice, this corresponds to the sign convention </p><p class="formulaDsp">
\[ K_{ab} = - \frac{1}{2} \mathcal{L}_{\mathbf{n}} \gamma_{ab} \]
</p>
<p> where \(\gamma_{ab}\) is the spatial metric. See Eq. (2.53) in <b>[BaumgarteShapiro]</b>. </p>

</div>
</div>
<a id="gae7204c20e97d784ae634c3976f69d427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7204c20e97d784ae634c3976f69d427">&#9670;&nbsp;</a></span>extrinsic_curvature() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt;DataType, SpatialDim, Frame&gt; GeneralizedHarmonic::extrinsic_curvature </td>
          <td>(</td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes extrinsic curvature from generalized harmonic variables and the spacetime normal vector. </p>
<h3>Details</h3>
<p>If \( \Pi_{ab} \) and \( \Phi_{iab} \) are the generalized harmonic conjugate momentum and spatial derivative variables, and if \(n^a\) is the spacetime normal vector, then the extrinsic curvature is computed as </p><p class="formulaDsp">
\begin{align} K_{ij} &amp;= \frac{1}{2} \Pi_{ij} + \Phi_{(ij)a} n^a \end{align}
</p>
 
</div>
</div>
<a id="ga45959454a026dbf844e15cdd93bc3a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45959454a026dbf844e15cdd93bc3a8d">&#9670;&nbsp;</a></span>extrinsic_curvature() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::extrinsic_curvature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>ex_curv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes extrinsic curvature from generalized harmonic variables and the spacetime normal vector. </p>
<h3>Details</h3>
<p>If \( \Pi_{ab} \) and \( \Phi_{iab} \) are the generalized harmonic conjugate momentum and spatial derivative variables, and if \(n^a\) is the spacetime normal vector, then the extrinsic curvature is computed as </p><p class="formulaDsp">
\begin{align} K_{ij} &amp;= \frac{1}{2} \Pi_{ij} + \Phi_{(ij)a} n^a \end{align}
</p>
 
</div>
</div>
<a id="ga267fa53f28f49e280846c84df552cbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga267fa53f28f49e280846c84df552cbb0">&#9670;&nbsp;</a></span>extrinsic_curvature() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::extrinsic_curvature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>ex_curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes extrinsic curvature from metric and derivatives. </p>
<h3>Details</h3>
<p>Uses the ADM evolution equation for the spatial metric, </p><p class="formulaDsp">
\[ K_{ij} = \frac{1}{2 \alpha} \left ( -\partial_0 \gamma_{ij} + \beta^k \partial_k \gamma_{ij} + \gamma_{ki} \partial_j \beta^k + \gamma_{kj} \partial_i \beta^k \right ) \]
</p>
<p> where \(K_{ij}\) is the extrinsic curvature, \(\alpha\) is the lapse, \(\beta^i\) is the shift, and \(\gamma_{ij}\) is the spatial metric. In terms of the Lie derivative of the spatial metric with respect to a unit timelike vector \(n^a\) normal to the spatial slice, this corresponds to the sign convention </p><p class="formulaDsp">
\[ K_{ab} = - \frac{1}{2} \mathcal{L}_{\mathbf{n}} \gamma_{ab} \]
</p>
<p> where \(\gamma_{ab}\) is the spatial metric. See Eq. (2.53) in <b>[BaumgarteShapiro]</b>. </p>

</div>
</div>
<a id="ga8a5680c46a3e16f25d4087e94d8c3804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a5680c46a3e16f25d4087e94d8c3804">&#9670;&nbsp;</a></span>first_index_to_different_frame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename SrcFrame , typename DestFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void transform::first_index_to_different_frame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ijj&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, tmpl::integral_list&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, 2, 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; VolumeDim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, SrcFrame &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; VolumeDim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, DestFrame &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; VolumeDim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, DestFrame &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame, SrcFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms only the first index to different frame.</p>
<p>Often used for derivatives: When representing derivatives as tensors, the first index is typically the derivative index. Numerical derivatives must be computed in the logical frame or sometimes the grid frame (independent of the frame of the tensor being differentiated), and then that derivative index must later be transformed into the same frame as the other indices of the tensor.</p>
<p>The formula for transforming \(T_{i\bar{\jmath}\bar{k}}\) is </p><p class="formulaDsp">
\begin{align} T_{\bar{\imath}\bar{\jmath}\bar{k}} &amp;= T_{i\bar{\jmath}\bar{k}} \frac{\partial x^i}{\partial x^{\bar{\imath}}}, \end{align}
</p>
<p> where \(x^i\) are the source coordinates and \(x^{\bar{\imath}}\) are the destination coordinates.</p>
<p>Note that <code>Jacobian&lt;DestFrame,SrcFrame&gt;</code> is the same type as <code>InverseJacobian&lt;SrcFrame,DestFrame&gt;</code> and represents \(\partial x^i/\partial x^{\bar{\jmath}}\).</p>
<p>In principle <code>first_index_to_different_frame</code> can be extended/generalized to other tensor types if needed. </p>

</div>
</div>
<a id="gac39514d667954de838416235250c431a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac39514d667954de838416235250c431a">&#9670;&nbsp;</a></span>first_index_to_different_frame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename SrcFrame , typename DestFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto transform::first_index_to_different_frame </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, tmpl::integral_list&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, 2, 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; VolumeDim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, SrcFrame &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; VolumeDim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, DestFrame &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; VolumeDim, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, DestFrame &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame, SrcFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  tnsr::ijj&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms only the first index to different frame.</p>
<p>Often used for derivatives: When representing derivatives as tensors, the first index is typically the derivative index. Numerical derivatives must be computed in the logical frame or sometimes the grid frame (independent of the frame of the tensor being differentiated), and then that derivative index must later be transformed into the same frame as the other indices of the tensor.</p>
<p>The formula for transforming \(T_{i\bar{\jmath}\bar{k}}\) is </p><p class="formulaDsp">
\begin{align} T_{\bar{\imath}\bar{\jmath}\bar{k}} &amp;= T_{i\bar{\jmath}\bar{k}} \frac{\partial x^i}{\partial x^{\bar{\imath}}}, \end{align}
</p>
<p> where \(x^i\) are the source coordinates and \(x^{\bar{\imath}}\) are the destination coordinates.</p>
<p>Note that <code>Jacobian&lt;DestFrame,SrcFrame&gt;</code> is the same type as <code>InverseJacobian&lt;SrcFrame,DestFrame&gt;</code> and represents \(\partial x^i/\partial x^{\bar{\jmath}}\).</p>
<p>In principle <code>first_index_to_different_frame</code> can be extended/generalized to other tensor types if needed. </p>

</div>
</div>
<a id="gac8f2808408986378437dfdbe07989271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8f2808408986378437dfdbe07989271">&#9670;&nbsp;</a></span>gauge_source() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::a&lt;DataType, SpatialDim, Frame&gt; GeneralizedHarmonic::gauge_source </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>trace_extrinsic_curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>trace_christoffel_last_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes generalized harmonic gauge source function. </p>
<h3>Details</h3>
<p>If \(\alpha, \beta^i, \gamma_{ij}, \Gamma_{ijk}, K\) are the lapse, shift, spatial metric, spatial Christoffel symbols, and trace of the extrinsic curvature, then we compute </p><p class="formulaDsp">
\begin{align} H_l &amp;= \alpha^{-2} \gamma_{il}(\partial_t \beta^i - \beta^k \partial_k \beta^i) + \alpha^{-1} \partial_l \alpha - \gamma^{km}\Gamma_{lkm} \\ H_0 &amp;= -\alpha^{-1} \partial_t \alpha + \alpha^{-1} \beta^k\partial_k \alpha + \beta^k H_k - \alpha K \end{align}
</p>
<p> See Eqs. 8 and 9 of <b>[Lindblom2005qh]</b> </p>

</div>
</div>
<a id="ga8f83b458def10ba14e20e6b935bcc7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f83b458def10ba14e20e6b935bcc7c3">&#9670;&nbsp;</a></span>gauge_source() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::gauge_source </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>gauge_source_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>trace_extrinsic_curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>trace_christoffel_last_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes generalized harmonic gauge source function. </p>
<h3>Details</h3>
<p>If \(\alpha, \beta^i, \gamma_{ij}, \Gamma_{ijk}, K\) are the lapse, shift, spatial metric, spatial Christoffel symbols, and trace of the extrinsic curvature, then we compute </p><p class="formulaDsp">
\begin{align} H_l &amp;= \alpha^{-2} \gamma_{il}(\partial_t \beta^i - \beta^k \partial_k \beta^i) + \alpha^{-1} \partial_l \alpha - \gamma^{km}\Gamma_{lkm} \\ H_0 &amp;= -\alpha^{-1} \partial_t \alpha + \alpha^{-1} \beta^k\partial_k \alpha + \beta^k H_k - \alpha K \end{align}
</p>
<p> See Eqs. 8 and 9 of <b>[Lindblom2005qh]</b> </p>

</div>
</div>
<a id="ga32c048728ce86e985cfe9316939899e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32c048728ce86e985cfe9316939899e3">&#9670;&nbsp;</a></span>interface_null_normal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::a&lt;DataType, VolumeDim, Frame&gt; gr::interface_null_normal </td>
          <td>(</td>
          <td class="paramtype">const tnsr::a&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_normal_one_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_unit_normal_one_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute null normal one-form to the boundary of a closed region in a spatial slice of spacetime. </p>
<h3>Details</h3>
<p>Consider an \(n-1\)-dimensional boundary \(S\) of a closed region in an \(n\)-dimensional spatial hypersurface \(\Sigma\). Let \(s^a\) be the unit spacelike vector orthogonal to \(S\) in \(\Sigma\), and \(n^a\) be the timelike unit vector orthogonal to \(\Sigma\). This function returns the null one-form that is outgoing/incoming on \(S\):</p>
<p class="formulaDsp">
\begin{align*} k_a = \frac{1}{\sqrt{2}}\left(n_a \pm s_a\right). \end{align*}
</p>
 
</div>
</div>
<a id="ga9f732806d7a8024a76fdd3f355c48b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f732806d7a8024a76fdd3f355c48b92">&#9670;&nbsp;</a></span>interface_null_normal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::A&lt;DataType, VolumeDim, Frame&gt; gr::interface_null_normal </td>
          <td>(</td>
          <td class="paramtype">const tnsr::A&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_unit_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute null normal vector to the boundary of a closed region in a spatial slice of spacetime. </p>
<h3>Details</h3>
<p>Consider an \(n-1\)-dimensional boundary \(S\) of a closed region in an \(n\)-dimensional spatial hypersurface \(\Sigma\). Let \(s^a\) be the unit spacelike vector orthogonal to \(S\) in \(\Sigma\), and \(n^a\) be the timelike unit vector orthogonal to \(\Sigma\). This function returns the null vector that is outgoing/ingoing on \(S\):</p>
<p class="formulaDsp">
\begin{align*} k^a = \frac{1}{\sqrt{2}}\left(n^a \pm s^a\right). \end{align*}
</p>
 
</div>
</div>
<a id="gae2f3d69a00e0f3d573dd5645f3ff1197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2f3d69a00e0f3d573dd5645f3ff1197">&#9670;&nbsp;</a></span>interface_null_normal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::interface_null_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; DataType, VolumeDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>null_one_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_normal_one_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_unit_normal_one_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute null normal one-form to the boundary of a closed region in a spatial slice of spacetime. </p>
<h3>Details</h3>
<p>Consider an \(n-1\)-dimensional boundary \(S\) of a closed region in an \(n\)-dimensional spatial hypersurface \(\Sigma\). Let \(s^a\) be the unit spacelike vector orthogonal to \(S\) in \(\Sigma\), and \(n^a\) be the timelike unit vector orthogonal to \(\Sigma\). This function returns the null one-form that is outgoing/incoming on \(S\):</p>
<p class="formulaDsp">
\begin{align*} k_a = \frac{1}{\sqrt{2}}\left(n_a \pm s_a\right). \end{align*}
</p>
 
</div>
</div>
<a id="gad51b34d6b5c2c1cef5555b6030de0695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad51b34d6b5c2c1cef5555b6030de0695">&#9670;&nbsp;</a></span>interface_null_normal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::interface_null_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; DataType, VolumeDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>null_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_unit_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute null normal vector to the boundary of a closed region in a spatial slice of spacetime. </p>
<h3>Details</h3>
<p>Consider an \(n-1\)-dimensional boundary \(S\) of a closed region in an \(n\)-dimensional spatial hypersurface \(\Sigma\). Let \(s^a\) be the unit spacelike vector orthogonal to \(S\) in \(\Sigma\), and \(n^a\) be the timelike unit vector orthogonal to \(\Sigma\). This function returns the null vector that is outgoing/ingoing on \(S\):</p>
<p class="formulaDsp">
\begin{align*} k^a = \frac{1}{\sqrt{2}}\left(n^a \pm s^a\right). \end{align*}
</p>
 
</div>
</div>
<a id="ga0806dc5b6f0a4f85a7c862a605886a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0806dc5b6f0a4f85a7c862a605886a4c">&#9670;&nbsp;</a></span>inverse_spacetime_metric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::AA&lt;DataType, SpatialDim, Frame&gt; gr::inverse_spacetime_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute inverse spacetime metric from inverse spatial metric, lapse and shift. </p>
<h3>Details</h3>
<p>The inverse spacetime metric \( g^{ab} \) is calculated as </p><p class="formulaDsp">
\begin{align} g^{tt} &amp;= - 1/\alpha^2 \\ g^{ti} &amp;= \beta^i / \alpha^2 \\ g^{ij} &amp;= \gamma^{ij} - \beta^i \beta^j / \alpha^2 \end{align}
</p>
<p> where \( \alpha, \beta^i\) and \( \gamma^{ij}\) are the lapse, shift and inverse spatial metric respectively </p>

</div>
</div>
<a id="gacde5276e7ed4b8095b4a153a46476acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacde5276e7ed4b8095b4a153a46476acf">&#9670;&nbsp;</a></span>inverse_spacetime_metric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::inverse_spacetime_metric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::AA&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>inverse_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute inverse spacetime metric from inverse spatial metric, lapse and shift. </p>
<h3>Details</h3>
<p>The inverse spacetime metric \( g^{ab} \) is calculated as </p><p class="formulaDsp">
\begin{align} g^{tt} &amp;= - 1/\alpha^2 \\ g^{ti} &amp;= \beta^i / \alpha^2 \\ g^{ij} &amp;= \gamma^{ij} - \beta^i \beta^j / \alpha^2 \end{align}
</p>
<p> where \( \alpha, \beta^i\) and \( \gamma^{ij}\) are the lapse, shift and inverse spatial metric respectively </p>

</div>
</div>
<a id="ga81e8e9380f2cb257aaa9ca008d6c95bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81e8e9380f2cb257aaa9ca008d6c95bf">&#9670;&nbsp;</a></span>lapse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; gr::lapse </td>
          <td>(</td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute lapse from shift and spacetime metric. </p>
<h3>Details</h3>
<p>Computes </p><p class="formulaDsp">
\begin{align} \alpha &amp;= \sqrt{\beta^i g_{it}-g_{tt}} \end{align}
</p>
<p> where \( \alpha \), \( \beta^i\), and \(g_{ab}\) are the lapse, shift, and spacetime metric. This can be derived, e.g., from Eqs. 2.121&ndash;2.122 of Baumgarte &amp; Shapiro. </p>

</div>
</div>
<a id="ga0e4bd55a479b296ffce232442dcf6b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e4bd55a479b296ffce232442dcf6b4d">&#9670;&nbsp;</a></span>lapse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::lapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute lapse from shift and spacetime metric. </p>
<h3>Details</h3>
<p>Computes </p><p class="formulaDsp">
\begin{align} \alpha &amp;= \sqrt{\beta^i g_{it}-g_{tt}} \end{align}
</p>
<p> where \( \alpha \), \( \beta^i\), and \(g_{ab}\) are the lapse, shift, and spacetime metric. This can be derived, e.g., from Eqs. 2.121&ndash;2.122 of Baumgarte &amp; Shapiro. </p>

</div>
</div>
<a id="ga3a6ef24ec982c3afa3e1f573a937c858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a6ef24ec982c3afa3e1f573a937c858">&#9670;&nbsp;</a></span>phi() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::iaa&lt;DataType, SpatialDim, Frame&gt; GeneralizedHarmonic::phi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the auxiliary variable \(\Phi_{iab}\) used by the generalized harmonic formulation of Einstein's equations. </p>
<h3>Details</h3>
<p>If \( \alpha, \beta^i\) and \( \gamma_{ij} \) are the lapse, shift and spatial metric respectively, then \(\Phi_{iab} \) is computed as</p>
<p class="formulaDsp">
\begin{align} \Phi_{ktt} &amp;= - 2 \alpha \partial_k \alpha + 2 \gamma_{mn} \beta^m \partial_k \beta^n + \beta^m \beta^n \partial_k \gamma_{mn} \\ \Phi_{kti} &amp;= \gamma_{mi} \partial_k \beta^m + \beta^m \partial_k \gamma_{mi} \\ \Phi_{kij} &amp;= \partial_k \gamma_{ij} \end{align}
</p>
 
</div>
</div>
<a id="gaaf4f3abab8ab7a0033fe999140b72ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf4f3abab8ab7a0033fe999140b72ffc">&#9670;&nbsp;</a></span>phi() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::phi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the auxiliary variable \(\Phi_{iab}\) used by the generalized harmonic formulation of Einstein's equations. </p>
<h3>Details</h3>
<p>If \( \alpha, \beta^i\) and \( \gamma_{ij} \) are the lapse, shift and spatial metric respectively, then \(\Phi_{iab} \) is computed as</p>
<p class="formulaDsp">
\begin{align} \Phi_{ktt} &amp;= - 2 \alpha \partial_k \alpha + 2 \gamma_{mn} \beta^m \partial_k \beta^n + \beta^m \beta^n \partial_k \gamma_{mn} \\ \Phi_{kti} &amp;= \gamma_{mi} \partial_k \beta^m + \beta^m \partial_k \gamma_{mi} \\ \Phi_{kij} &amp;= \partial_k \gamma_{ij} \end{align}
</p>
 
</div>
</div>
<a id="ga024fe82a266a3c29a0a5c2abb58da963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga024fe82a266a3c29a0a5c2abb58da963">&#9670;&nbsp;</a></span>pi() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::aa&lt;DataType, SpatialDim, Frame&gt; GeneralizedHarmonic::pi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the conjugate momentum \(\Pi_{ab}\) of the spacetime metric \( g_{ab} \). </p>
<h3>Details</h3>
<p>If \( \alpha, \beta^i\) are the lapse and shift respectively, and \( \Phi_{iab} = \partial_i g_{ab} \) then \(\Pi_{\mu\nu} = -\frac{1}{\alpha} ( \partial_t g_{\mu\nu} - \beta^m \Phi_{m\mu\nu}) \) where \( \partial_t g_{ab} \) is computed as</p>
<p class="formulaDsp">
\begin{align} \partial_t g_{tt} &amp;= - 2 \alpha \partial_t \alpha + 2 \gamma_{mn} \beta^m \partial_t \beta^n + \beta^m \beta^n \partial_t \gamma_{mn} \\ \partial_t g_{ti} &amp;= \gamma_{mi} \partial_t \beta^m + \beta^m \partial_t \gamma_{mi} \\ \partial_t g_{ij} &amp;= \partial_t \gamma_{ij} \end{align}
</p>
 
</div>
</div>
<a id="ga5ad74fcd422729821afb270c95800b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ad74fcd422729821afb270c95800b83">&#9670;&nbsp;</a></span>pi() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::pi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>pi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the conjugate momentum \(\Pi_{ab}\) of the spacetime metric \( g_{ab} \). </p>
<h3>Details</h3>
<p>If \( \alpha, \beta^i\) are the lapse and shift respectively, and \( \Phi_{iab} = \partial_i g_{ab} \) then \(\Pi_{\mu\nu} = -\frac{1}{\alpha} ( \partial_t g_{\mu\nu} - \beta^m \Phi_{m\mu\nu}) \) where \( \partial_t g_{ab} \) is computed as</p>
<p class="formulaDsp">
\begin{align} \partial_t g_{tt} &amp;= - 2 \alpha \partial_t \alpha + 2 \gamma_{mn} \beta^m \partial_t \beta^n + \beta^m \beta^n \partial_t \gamma_{mn} \\ \partial_t g_{ti} &amp;= \gamma_{mi} \partial_t \beta^m + \beta^m \partial_t \gamma_{mi} \\ \partial_t g_{ij} &amp;= \partial_t \gamma_{ij} \end{align}
</p>
 
</div>
</div>
<a id="ga65bb6dfde399d573ecb051af9de78aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65bb6dfde399d573ecb051af9de78aea">&#9670;&nbsp;</a></span>raise_or_lower_first_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt;2, 1, 1&gt;, index_list&lt;<a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt;Index0&gt;, Index1, Index1&gt; &gt; raise_or_lower_first_index </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 2, 1, 1 &gt;, index_list&lt; Index0, Index1, Index1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises or lowers the first index of a rank 3 tensor which is symmetric in the last two indices. </p>
<h3>Details</h3>
<p>If \(T_{abc}\) is a tensor with \(T_{abc} = T_{acb}\) and the indices \(a,b,c,...\) can represent either spatial or spacetime indices, then the tensor \( T^a_{bc} = g^{ad} T_{abc} \) is computed, where \( g^{ab}\) is the inverse metric, which is either a spatial or spacetime metric. If a tensor \( S^a_{bc} \) is passed as an argument than the corresponding tensor \( S_{abc} \) is calculated with respect to the metric \(g_{ab}\). You may have to add a new instantiation of this template if you need a new use case. </p>

</div>
</div>
<a id="ga877184239a3161ef2bbafd1c71fec9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga877184239a3161ef2bbafd1c71fec9ae">&#9670;&nbsp;</a></span>raise_or_lower_first_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void raise_or_lower_first_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 2, 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, Index1, Index1 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 2, 1, 1 &gt;, index_list&lt; Index0, Index1, Index1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises or lowers the first index of a rank 3 tensor which is symmetric in the last two indices. </p>
<h3>Details</h3>
<p>If \(T_{abc}\) is a tensor with \(T_{abc} = T_{acb}\) and the indices \(a,b,c,...\) can represent either spatial or spacetime indices, then the tensor \( T^a_{bc} = g^{ad} T_{abc} \) is computed, where \( g^{ab}\) is the inverse metric, which is either a spatial or spacetime metric. If a tensor \( S^a_{bc} \) is passed as an argument than the corresponding tensor \( S_{abc} \) is calculated with respect to the metric \(g_{ab}\). You may have to add a new instantiation of this template if you need a new use case. </p>

</div>
</div>
<a id="ga3b541787ca9055248e7e427293956f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b541787ca9055248e7e427293956f9b">&#9670;&nbsp;</a></span>raise_or_lower_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt;1&gt;, index_list&lt;<a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt;Index0&gt; &gt; &gt; raise_or_lower_index </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; Index0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises or lowers the index of a rank 1 tensor. </p>
<h3>Details</h3>
<p>If \(T_{a}\) is a tensor and the index \(a\) can represent either a spatial or spacetime index, then the tensor \( T^a = g^{ad} T_{d} \) is computed, where \( g^{ab}\) is the inverse metric, which is either a spatial or spacetime metric. If a tensor \( S^a \) is passed as an argument than the corresponding tensor \( S_{a} \) is calculated with respect to the metric \(g_{ab}\). </p>

</div>
</div>
<a id="ga2ea873346936b497401378441ed609da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ea873346936b497401378441ed609da">&#9670;&nbsp;</a></span>raise_or_lower_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void raise_or_lower_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; Index0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises or lowers the index of a rank 1 tensor. </p>
<h3>Details</h3>
<p>If \(T_{a}\) is a tensor and the index \(a\) can represent either a spatial or spacetime index, then the tensor \( T^a = g^{ad} T_{d} \) is computed, where \( g^{ab}\) is the inverse metric, which is either a spatial or spacetime metric. If a tensor \( S^a \) is passed as an argument than the corresponding tensor \( S_{a} \) is calculated with respect to the metric \(g_{ab}\). </p>

</div>
</div>
<a id="ga42e3e01038fdee8881b28dfe7183d88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42e3e01038fdee8881b28dfe7183d88c">&#9670;&nbsp;</a></span>ricci_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::ricci_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>ricci_scalar_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ricci_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Ricci Scalar from the (spatial or spacetime) Ricci Tensor and inverse metrics. </p>
<h3>Details</h3>
<p>Computes Ricci scalar using the inverse metric (spatial or spacetime) and Ricci tensor \(R = g^{ab}R_{ab}\) </p>

</div>
</div>
<a id="gaf0ec90adc22e0707820bdc1c4dd8b11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0ec90adc22e0707820bdc1c4dd8b11f">&#9670;&nbsp;</a></span>ricci_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; gr::ricci_scalar </td>
          <td>(</td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ricci_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Ricci Scalar from the (spatial or spacetime) Ricci Tensor and inverse metrics. </p>
<h3>Details</h3>
<p>Computes Ricci scalar using the inverse metric (spatial or spacetime) and Ricci tensor \(R = g^{ab}R_{ab}\) </p>

</div>
</div>
<a id="ga8ffac4782003855a5228dbd8a0efe624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ffac4782003855a5228dbd8a0efe624">&#9670;&nbsp;</a></span>ricci_tensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::aa&lt;DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a>&gt; gr::ricci_tensor </td>
          <td>(</td>
          <td class="paramtype">const tnsr::Abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>christoffel_2nd_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aBcc&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_christoffel_2nd_kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Ricci tensor from the (spatial or spacetime) Christoffel symbol of the second kind and its derivative. </p>
<h3>Details</h3>
<p>Computes Ricci tensor \(R_{ab}\) as: \( R_{ab} = \partial_c \Gamma^{c}_{ab} - \partial_{(b} \Gamma^{c}_{a)c} + \Gamma^{d}_{ab}\Gamma^{c}_{cd} - \Gamma^{d}_{ac} \Gamma^{c}_{bd} \) where \(\Gamma^{a}_{bc}\) is the Christoffel symbol of the second kind. </p>

</div>
</div>
<a id="gad1c14854d87204ccf2c23f86d83ffbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1c14854d87204ccf2c23f86d83ffbe7">&#9670;&nbsp;</a></span>ricci_tensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , IndexType Index, typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::ricci_tensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::Abb&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>christoffel_2nd_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aBcc&lt; DataType, SpatialDim, Frame, <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_christoffel_2nd_kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Ricci tensor from the (spatial or spacetime) Christoffel symbol of the second kind and its derivative. </p>
<h3>Details</h3>
<p>Computes Ricci tensor \(R_{ab}\) as: \( R_{ab} = \partial_c \Gamma^{c}_{ab} - \partial_{(b} \Gamma^{c}_{a)c} + \Gamma^{d}_{ab}\Gamma^{c}_{cd} - \Gamma^{d}_{ac} \Gamma^{c}_{bd} \) where \(\Gamma^{a}_{bc}\) is the Christoffel symbol of the second kind. </p>

</div>
</div>
<a id="ga8a9d8994cd4fee91a6d4971ac14a31f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a9d8994cd4fee91a6d4971ac14a31f1">&#9670;&nbsp;</a></span>shift() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::I&lt;DataType, SpatialDim, Frame&gt; gr::shift </td>
          <td>(</td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute shift from spacetime metric and inverse spatial metric. </p>
<h3>Details</h3>
<p>Computes </p><p class="formulaDsp">
\begin{align} \beta^i &amp;= \gamma^{ij} g_{jt} \end{align}
</p>
<p> where \( \beta^i\), \( \gamma^{ij}\), and \(g_{ab}\) are the shift, inverse spatial metric, and spacetime metric. This can be derived, e.g., from Eqs. 2.121&ndash;2.122 of Baumgarte &amp; Shapiro. </p>

</div>
</div>
<a id="ga25bc5f470d173570d5de82508ca793a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25bc5f470d173570d5de82508ca793a4">&#9670;&nbsp;</a></span>shift() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute shift from spacetime metric and inverse spatial metric. </p>
<h3>Details</h3>
<p>Computes </p><p class="formulaDsp">
\begin{align} \beta^i &amp;= \gamma^{ij} g_{jt} \end{align}
</p>
<p> where \( \beta^i\), \( \gamma^{ij}\), and \(g_{ab}\) are the shift, inverse spatial metric, and spacetime metric. This can be derived, e.g., from Eqs. 2.121&ndash;2.122 of Baumgarte &amp; Shapiro. </p>

</div>
</div>
<a id="gab701aaed6bb5036b97891f439cc292a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab701aaed6bb5036b97891f439cc292a1">&#9670;&nbsp;</a></span>spacetime_deriv_of_det_spatial_metric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::a&lt;DataType, SpatialDim, Frame&gt; GeneralizedHarmonic::spacetime_deriv_of_det_spatial_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>sqrt_det_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spacetime derivatives of the determinant of spatial metric, using the generalized harmonic variables, spatial metric, and its time derivative. </p>
<h3>Details</h3>
<p>Using the relation \( \partial_a \gamma = \gamma \gamma^{jk} \partial_a \gamma_{jk} \) </p>

</div>
</div>
<a id="ga0426f2b24c3f088deaef7a4e5ff6160a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0426f2b24c3f088deaef7a4e5ff6160a">&#9670;&nbsp;</a></span>spacetime_deriv_of_det_spatial_metric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::spacetime_deriv_of_det_spatial_metric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>d4_det_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>sqrt_det_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spacetime derivatives of the determinant of spatial metric, using the generalized harmonic variables, spatial metric, and its time derivative. </p>
<h3>Details</h3>
<p>Using the relation \( \partial_a \gamma = \gamma \gamma^{jk} \partial_a \gamma_{jk} \) </p>

</div>
</div>
<a id="ga6ca7b33f2c45ddd2eb2dc4f88cb1bcd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ca7b33f2c45ddd2eb2dc4f88cb1bcd0">&#9670;&nbsp;</a></span>spacetime_deriv_of_norm_of_shift() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::a&lt;DataType, SpatialDim, Frame&gt; GeneralizedHarmonic::spacetime_deriv_of_norm_of_shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_unit_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spacetime derivatives of the norm of the shift vector. </p>
<h3>Details</h3>
<p>The same is computed as: </p><p class="formulaDsp">
\begin{align*} \partial_a (\beta^i \beta_i) = (\beta_i \partial_0 \beta^i + \beta^i \partial_0 \beta_i, \beta_i \partial_j \beta^i + \beta^i \partial_j \beta_i) \end{align*}
</p>
 
</div>
</div>
<a id="gade8698a459687d11bbf191c8e95c4df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade8698a459687d11bbf191c8e95c4df3">&#9670;&nbsp;</a></span>spacetime_deriv_of_norm_of_shift() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::spacetime_deriv_of_norm_of_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>d4_norm_of_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_unit_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spacetime derivatives of the norm of the shift vector. </p>
<h3>Details</h3>
<p>The same is computed as: </p><p class="formulaDsp">
\begin{align*} \partial_a (\beta^i \beta_i) = (\beta_i \partial_0 \beta^i + \beta^i \partial_0 \beta_i, \beta_i \partial_j \beta^i + \beta^i \partial_j \beta_i) \end{align*}
</p>
 
</div>
</div>
<a id="gae95d24eeb4d9fee18e49622938e00d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae95d24eeb4d9fee18e49622938e00d4f">&#9670;&nbsp;</a></span>spacetime_derivative_of_spacetime_metric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::spacetime_derivative_of_spacetime_metric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::abb&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>da_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the spacetime derivative of the spacetime metric, \(\partial_a g_{bc}\). </p>
<p class="formulaDsp">
\begin{align*} \partial_t g_{ab}&amp;=-\alpha \Pi_{ab} + \beta^i \Phi_{iab} \\ \partial_i g_{ab}&amp;=\Phi_{iab} \end{align*}
</p>
 
</div>
</div>
<a id="ga6dd05fc035883d0919a7b055460fa9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dd05fc035883d0919a7b055460fa9a3">&#9670;&nbsp;</a></span>spacetime_metric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::aa&lt;DataType, SpatialDim, Frame&gt; gr::spacetime_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the spacetime metric from the spatial metric, lapse, and shift. </p>
<h3>Details</h3>
<p>The spacetime metric \( g_{ab} \) is calculated as </p><p class="formulaDsp">
\begin{align} g_{tt} &amp;= - \alpha^2 + \beta^m \beta^n \gamma_{mn} \\ g_{ti} &amp;= \gamma_{mi} \beta^m \\ g_{ij} &amp;= \gamma_{ij} \end{align}
</p>
<p> where \( \alpha, \beta^i\) and \( \gamma_{ij}\) are the lapse, shift and spatial metric respectively </p>

</div>
</div>
<a id="ga30b4e9ea5a0b87eb9422ad9a975041b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30b4e9ea5a0b87eb9422ad9a975041b9">&#9670;&nbsp;</a></span>spacetime_metric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::spacetime_metric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; DataType, Dim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the spacetime metric from the spatial metric, lapse, and shift. </p>
<h3>Details</h3>
<p>The spacetime metric \( g_{ab} \) is calculated as </p><p class="formulaDsp">
\begin{align} g_{tt} &amp;= - \alpha^2 + \beta^m \beta^n \gamma_{mn} \\ g_{ti} &amp;= \gamma_{mi} \beta^m \\ g_{ij} &amp;= \gamma_{ij} \end{align}
</p>
<p> where \( \alpha, \beta^i\) and \( \gamma_{ij}\) are the lapse, shift and spatial metric respectively </p>

</div>
</div>
<a id="ga6b0dfbe004db0edf33e7e7d4e126e77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b0dfbe004db0edf33e7e7d4e126e77b">&#9670;&nbsp;</a></span>spacetime_normal_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::A&lt;DataType, SpatialDim, Frame&gt; gr::spacetime_normal_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spacetime normal vector from lapse and shift. </p>
<h3>Details</h3>
<p>If \(\alpha, \beta^i\) are the lapse and shift respectively, then</p>
<p class="formulaDsp">
\begin{align} n^t &amp;= 1/\alpha \\ n^i &amp;= -\frac{\beta^i}{\alpha} \end{align}
</p>
<p>is computed. </p>

</div>
</div>
<a id="gaf34b7d587da726aca87ab2754dcbab94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf34b7d587da726aca87ab2754dcbab94">&#9670;&nbsp;</a></span>spacetime_normal_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::spacetime_normal_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>spacetime_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spacetime normal vector from lapse and shift. </p>
<h3>Details</h3>
<p>If \(\alpha, \beta^i\) are the lapse and shift respectively, then</p>
<p class="formulaDsp">
\begin{align} n^t &amp;= 1/\alpha \\ n^i &amp;= -\frac{\beta^i}{\alpha} \end{align}
</p>
<p>is computed. </p>

</div>
</div>
<a id="ga564c6ea734855ce31aad41bf68b11401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga564c6ea734855ce31aad41bf68b11401">&#9670;&nbsp;</a></span>spatial_deriv_of_lapse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt;DataType, SpatialDim, Frame&gt; GeneralizedHarmonic::spatial_deriv_of_lapse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_unit_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spatial derivatives of lapse ( \(\alpha\)) from the generalized harmonic variables and spacetime unit normal 1-form. </p>
<h3>Details</h3>
<p>If the generalized harmonic conjugate momentum and spatial derivative variables are \(\Pi_{ab} = -n^c \partial_c g_{ab} \) and \(\Phi_{iab} = \partial_i g_{ab} \), the spatial derivatives of \(\alpha\) can be obtained from:</p>
<p class="formulaDsp">
\begin{align*} n^a n^b \Phi_{iab} = -\frac{1}{2\alpha} [\partial_i (-\alpha^2 + \beta_j\beta^j)- 2 \beta^j \partial_i \beta_j + \beta^j \beta^k \partial_i \gamma_{jk}] = -\frac{2}{\alpha} \partial_i \alpha, \end{align*}
</p>
<p>since</p>
<p class="formulaDsp">
\[ \partial_i (\beta_j\beta^j) = 2\beta^j \partial_i \beta_j - \beta^j \beta^k \partial_i \gamma_{jk}. \]
</p>
<p class="formulaDsp">
\[ \Longrightarrow \partial_i \alpha = -(\alpha/2) n^a \Phi_{iab} n^b \]
</p>
 
</div>
</div>
<a id="gaa4628cbcc3f9df0954efbbfada626806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4628cbcc3f9df0954efbbfada626806">&#9670;&nbsp;</a></span>spatial_deriv_of_lapse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::spatial_deriv_of_lapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>deriv_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_unit_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spatial derivatives of lapse ( \(\alpha\)) from the generalized harmonic variables and spacetime unit normal 1-form. </p>
<h3>Details</h3>
<p>If the generalized harmonic conjugate momentum and spatial derivative variables are \(\Pi_{ab} = -n^c \partial_c g_{ab} \) and \(\Phi_{iab} = \partial_i g_{ab} \), the spatial derivatives of \(\alpha\) can be obtained from:</p>
<p class="formulaDsp">
\begin{align*} n^a n^b \Phi_{iab} = -\frac{1}{2\alpha} [\partial_i (-\alpha^2 + \beta_j\beta^j)- 2 \beta^j \partial_i \beta_j + \beta^j \beta^k \partial_i \gamma_{jk}] = -\frac{2}{\alpha} \partial_i \alpha, \end{align*}
</p>
<p>since</p>
<p class="formulaDsp">
\[ \partial_i (\beta_j\beta^j) = 2\beta^j \partial_i \beta_j - \beta^j \beta^k \partial_i \gamma_{jk}. \]
</p>
<p class="formulaDsp">
\[ \Longrightarrow \partial_i \alpha = -(\alpha/2) n^a \Phi_{iab} n^b \]
</p>
 
</div>
</div>
<a id="gaa24aa403627d7091a89a41e91b78fd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa24aa403627d7091a89a41e91b78fd7e">&#9670;&nbsp;</a></span>spatial_deriv_of_shift() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::iJ&lt;DataType, SpatialDim, Frame&gt; GeneralizedHarmonic::spatial_deriv_of_shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_unit_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spatial derivatives of the shift vector from the generalized harmonic and geometric variables. </p>
<h3>Details</h3>
<p>Spatial derivatives of the shift vector \(\beta^i\) can be derived from the following steps: </p><p class="formulaDsp">
\begin{align*} \partial_i \beta^j =&amp; \gamma^{jl} \gamma_{kl} \partial_i \beta^k \\ =&amp; \gamma^{jl} (\beta^k \partial_i \gamma_{lk} + \gamma_{kl}\partial_i \beta^k - \beta^k \partial_i \gamma_{kl}) \\ =&amp; \gamma^{jl} (\partial_i \beta_l - \beta^k \partial_i \gamma_{lk}) (\because \gamma^{j0} = 0) \\ =&amp; \gamma^{ja} (\partial_i g_{a0} - \beta^k \partial _i g_{ak}) \\ =&amp; \alpha \gamma^{ja} n^b \partial_i g_{ab} \\ =&amp; (\gamma^{ja} - n^j n^a) \alpha n^b \Phi_{iab} - 2 n^j \partial_i \alpha \\ =&amp; g^{ja} \alpha n^b \Phi_{iab} - 2 n^j \partial_i \alpha \\ =&amp; \alpha (g^{ja} + n^j n^a) n^b \Phi_{iab}. \end{align*}
</p>
<p> where we used the equation from <a class="el" href="group__GeneralRelativityGroup.html#gaa4628cbcc3f9df0954efbbfada626806" title="Computes spatial derivatives of lapse ( ) from the generalized harmonic variables and spacetime unit ...">spatial_deriv_of_lapse()</a> for \(\partial_i \alpha\). </p>

</div>
</div>
<a id="ga7e61f81f9d1dc3de00e9d246ca338b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e61f81f9d1dc3de00e9d246ca338b01">&#9670;&nbsp;</a></span>spatial_deriv_of_shift() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::spatial_deriv_of_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>deriv_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_unit_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes spatial derivatives of the shift vector from the generalized harmonic and geometric variables. </p>
<h3>Details</h3>
<p>Spatial derivatives of the shift vector \(\beta^i\) can be derived from the following steps: </p><p class="formulaDsp">
\begin{align*} \partial_i \beta^j =&amp; \gamma^{jl} \gamma_{kl} \partial_i \beta^k \\ =&amp; \gamma^{jl} (\beta^k \partial_i \gamma_{lk} + \gamma_{kl}\partial_i \beta^k - \beta^k \partial_i \gamma_{kl}) \\ =&amp; \gamma^{jl} (\partial_i \beta_l - \beta^k \partial_i \gamma_{lk}) (\because \gamma^{j0} = 0) \\ =&amp; \gamma^{ja} (\partial_i g_{a0} - \beta^k \partial _i g_{ak}) \\ =&amp; \alpha \gamma^{ja} n^b \partial_i g_{ab} \\ =&amp; (\gamma^{ja} - n^j n^a) \alpha n^b \Phi_{iab} - 2 n^j \partial_i \alpha \\ =&amp; g^{ja} \alpha n^b \Phi_{iab} - 2 n^j \partial_i \alpha \\ =&amp; \alpha (g^{ja} + n^j n^a) n^b \Phi_{iab}. \end{align*}
</p>
<p> where we used the equation from <a class="el" href="group__GeneralRelativityGroup.html#gaa4628cbcc3f9df0954efbbfada626806" title="Computes spatial derivatives of lapse ( ) from the generalized harmonic variables and spacetime unit ...">spatial_deriv_of_lapse()</a> for \(\partial_i \alpha\). </p>

</div>
</div>
<a id="ga629c4a81eec057b08972c870bac4319d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga629c4a81eec057b08972c870bac4319d">&#9670;&nbsp;</a></span>spatial_metric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt;DataType, SpatialDim, Frame&gt; gr::spatial_metric </td>
          <td>(</td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute spatial metric from spacetime metric. </p>
<h3>Details</h3>
<p>Simply pull out the spatial components. </p>

</div>
</div>
<a id="ga6a6a6581e60141273cabb6c1fb29ed8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a6a6581e60141273cabb6c1fb29ed8b">&#9670;&nbsp;</a></span>spatial_metric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::spatial_metric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute spatial metric from spacetime metric. </p>
<h3>Details</h3>
<p>Simply pull out the spatial components. </p>

</div>
</div>
<a id="gaaad08e9714e4c6f4f4b2697b5eefb31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaad08e9714e4c6f4f4b2697b5eefb31e">&#9670;&nbsp;</a></span>spatial_ricci_tensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt;DataType, VolumeDim, Frame&gt; GeneralizedHarmonic::spatial_ricci_tensor </td>
          <td>(</td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijaa&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute spatial Ricci tensor using evolved variables and their first derivatives. </p>
<h3>Details</h3>
<p>Lets write the Christoffel symbols of the first kind as </p><p class="formulaDsp">
\begin{align} \Gamma_{kij} = \frac{1}{2}(\partial_i \gamma_{jk} + \partial_j \gamma_{ik} - \partial_k \gamma_{ij}) = (\Phi_{(ij)k} - \frac{1}{2}\Phi_{kij}) \end{align}
</p>
<p> substituting \(\partial_k \gamma_{ij}\rightarrow{}\Phi_{kij}\) by subtracting out the three-index constraint \(C_{kij}=\partial_{k}\gamma_{ij}-\Phi_{kij}\) from every term. We also define contractions \(d_k=\frac{1}{2}\gamma^{ij}\Phi_{kij}\) and \(b_k=\frac{1}{2}\gamma^{ij}\Phi_{ijk}\). This allows us to rewrite the spatial Ricci tensor as: </p><p class="formulaDsp">
\begin{align} R_{i j} =&amp; \partial_k \Gamma^{k}_{ij} - \partial_i \Gamma^{k}_{kj} + \Gamma^{k}_{kl}\Gamma^{l}_{ij} - \Gamma^{l}_{ki}\Gamma^{k}_{lj},\\ =&amp; \gamma^{kl}\left(\partial_{k}\Phi_{(ij)l} - \frac{1}{2}\partial_{k}\Phi_{lij}\right) - b^{l} (\Phi_{(ij)l} - \frac{1}{2}\Phi_{lij})\nonumber\\ &amp; - \gamma^{kl}\left(\partial_{i}\Phi_{(kj)l} - \frac{1}{2}\partial_{i}\Phi_{lkj}\right) - \Phi_{i}{}^{kl}\left(\Phi_{(kj)l} - \frac{1}{2}\Phi_{lkj} \right)\nonumber\\ &amp; + \gamma^{km}\left(\Phi_{(kl)m} - \frac{1}{2}\Phi_{mkl}\right) \gamma^{ln}\left(\Phi_{(ij)n} - \frac{1}{2}\Phi_{nij}\right) \nonumber\\ &amp; - \gamma^{km}\left(\Phi_{(il)m} - \frac{1}{2}\Phi_{mil}\right) \gamma^{ln}\left(\Phi_{(jk)n} - \frac{1}{2}\Phi_{njk}\right). \end{align}
</p>
<p> Gathering all terms with second derivatives: </p><p class="formulaDsp">
\begin{align} R_{i j} =&amp; \frac{1}{2} \gamma^{k l} \left(\partial_k\Phi_{ijl} + \partial_k\Phi_{jil} - \partial_k\Phi_{lij} + \partial_i\Phi_{lkj} - \partial_i\Phi_{kjl} - \partial_i\Phi_{jkl}\right) + \mathcal{O}(\Phi), \nonumber\\ =&amp; \frac{1}{2} \gamma^{kl} \left(\partial_{(j}\Phi_{lki)} - \partial_{(j}\Phi_{i)kl} + \partial_k \Phi_{(ij)l} - \partial_l \Phi_{kij} \right) + \mathcal{O}(\Phi), \end{align}
</p>
<p> where we use the four-index constraint \(C_{klij}=\partial_k\Phi_{lij}-\partial_l\Phi_{kij}=0\) to swap the first and second derivatives of the spatial metric, and symmetrize \(R_{ij} = R_{(ij)}\). Similarly gathering the remaining terms and using the four-index constraint we get: </p><p class="formulaDsp">
\begin{align} R_{i j} =&amp; - b^k\left(\Phi_{ijk} + \Phi_{jik} - \Phi_{kij}\right) -\frac{1}{2} \Phi_i{}^{kl} \left(\Phi_{jkl} + \Phi_{kjl} - \Phi_{lkj}\right)\nonumber\\ &amp;+ \frac{1}{2} d^k \left(\Phi_{ijk} + \Phi_{jik} - \Phi_{kij}\right) - \left(\Phi_{(il)}{}^k - \frac{1}{2} \Phi^k{}_{il}\right) \left(\Phi_{(kj)}{}^l - \frac{1}{2} \Phi^l{}_{kj}\right) + \mathcal{O}(\partial\Phi) \\ =&amp; \frac{1}{2} \left(\Phi_{ijk} + \Phi_{jik} - \Phi_{kij}\right) (d^k - 2 b^k) + \frac{1}{4} \Phi_{ik}{}^l \Phi_{jl}{}^k + \frac{1}{2} \left(\Phi^k{}_{il} \Phi_{kj}{}^l - \Phi^k{}_{li} \Phi^l{}_{kj}\right) + \mathcal{O}(\partial\Phi). \end{align}
</p>
<p> Gathering everything together, we compute the spatial Ricci tensor as: </p><p class="formulaDsp">
\begin{eqnarray} R_{i j} &amp;=&amp; \frac{1}{2} \gamma^{kl} \left(\partial_{(j|}\Phi_{lk|i)} - \partial_{(j}\Phi_{i)kl} + \partial_k \Phi_{(ij)l} - \partial_l \Phi_{kij}\right)\nonumber\\ &amp;+&amp; \frac{1}{2} \left(\Phi_{ijk} + \Phi_{jik} - \Phi_{kij}\right) (d^k - 2 b^k) + \frac{1}{4} \Phi_{ik}{}^l \Phi_{jl}{}^k + \frac{1}{2} \left(\Phi^k{}_{il} \Phi_{kj}{}^l - \Phi^k{}_{li} \Phi^l{}_{kj}\right). \label{eq:rij} \end{eqnarray}
</p>
<p> This follows from equations (2.13) - (2.20) of <b>[Kidder2001tz]</b> .</p>
<p>Note that, in code, the mixed-index variables \(\Phi_{ij}{}^k\) and \(\Phi^i{}_{jk}\) in Eq.( \(\ref{eq:rij}\)) are computed with a factor of \(1/2\) and so the last 3 terms in the same equation that are quadratic in these terms occur multiplied by a factor of \(4\). </p>

</div>
</div>
<a id="ga582aa60e616b2257b6d28808f704c64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga582aa60e616b2257b6d28808f704c64f">&#9670;&nbsp;</a></span>spatial_ricci_tensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::spatial_ricci_tensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, VolumeDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>ricci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijaa&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute spatial Ricci tensor using evolved variables and their first derivatives. </p>
<h3>Details</h3>
<p>Lets write the Christoffel symbols of the first kind as </p><p class="formulaDsp">
\begin{align} \Gamma_{kij} = \frac{1}{2}(\partial_i \gamma_{jk} + \partial_j \gamma_{ik} - \partial_k \gamma_{ij}) = (\Phi_{(ij)k} - \frac{1}{2}\Phi_{kij}) \end{align}
</p>
<p> substituting \(\partial_k \gamma_{ij}\rightarrow{}\Phi_{kij}\) by subtracting out the three-index constraint \(C_{kij}=\partial_{k}\gamma_{ij}-\Phi_{kij}\) from every term. We also define contractions \(d_k=\frac{1}{2}\gamma^{ij}\Phi_{kij}\) and \(b_k=\frac{1}{2}\gamma^{ij}\Phi_{ijk}\). This allows us to rewrite the spatial Ricci tensor as: </p><p class="formulaDsp">
\begin{align} R_{i j} =&amp; \partial_k \Gamma^{k}_{ij} - \partial_i \Gamma^{k}_{kj} + \Gamma^{k}_{kl}\Gamma^{l}_{ij} - \Gamma^{l}_{ki}\Gamma^{k}_{lj},\\ =&amp; \gamma^{kl}\left(\partial_{k}\Phi_{(ij)l} - \frac{1}{2}\partial_{k}\Phi_{lij}\right) - b^{l} (\Phi_{(ij)l} - \frac{1}{2}\Phi_{lij})\nonumber\\ &amp; - \gamma^{kl}\left(\partial_{i}\Phi_{(kj)l} - \frac{1}{2}\partial_{i}\Phi_{lkj}\right) - \Phi_{i}{}^{kl}\left(\Phi_{(kj)l} - \frac{1}{2}\Phi_{lkj} \right)\nonumber\\ &amp; + \gamma^{km}\left(\Phi_{(kl)m} - \frac{1}{2}\Phi_{mkl}\right) \gamma^{ln}\left(\Phi_{(ij)n} - \frac{1}{2}\Phi_{nij}\right) \nonumber\\ &amp; - \gamma^{km}\left(\Phi_{(il)m} - \frac{1}{2}\Phi_{mil}\right) \gamma^{ln}\left(\Phi_{(jk)n} - \frac{1}{2}\Phi_{njk}\right). \end{align}
</p>
<p> Gathering all terms with second derivatives: </p><p class="formulaDsp">
\begin{align} R_{i j} =&amp; \frac{1}{2} \gamma^{k l} \left(\partial_k\Phi_{ijl} + \partial_k\Phi_{jil} - \partial_k\Phi_{lij} + \partial_i\Phi_{lkj} - \partial_i\Phi_{kjl} - \partial_i\Phi_{jkl}\right) + \mathcal{O}(\Phi), \nonumber\\ =&amp; \frac{1}{2} \gamma^{kl} \left(\partial_{(j}\Phi_{lki)} - \partial_{(j}\Phi_{i)kl} + \partial_k \Phi_{(ij)l} - \partial_l \Phi_{kij} \right) + \mathcal{O}(\Phi), \end{align}
</p>
<p> where we use the four-index constraint \(C_{klij}=\partial_k\Phi_{lij}-\partial_l\Phi_{kij}=0\) to swap the first and second derivatives of the spatial metric, and symmetrize \(R_{ij} = R_{(ij)}\). Similarly gathering the remaining terms and using the four-index constraint we get: </p><p class="formulaDsp">
\begin{align} R_{i j} =&amp; - b^k\left(\Phi_{ijk} + \Phi_{jik} - \Phi_{kij}\right) -\frac{1}{2} \Phi_i{}^{kl} \left(\Phi_{jkl} + \Phi_{kjl} - \Phi_{lkj}\right)\nonumber\\ &amp;+ \frac{1}{2} d^k \left(\Phi_{ijk} + \Phi_{jik} - \Phi_{kij}\right) - \left(\Phi_{(il)}{}^k - \frac{1}{2} \Phi^k{}_{il}\right) \left(\Phi_{(kj)}{}^l - \frac{1}{2} \Phi^l{}_{kj}\right) + \mathcal{O}(\partial\Phi) \\ =&amp; \frac{1}{2} \left(\Phi_{ijk} + \Phi_{jik} - \Phi_{kij}\right) (d^k - 2 b^k) + \frac{1}{4} \Phi_{ik}{}^l \Phi_{jl}{}^k + \frac{1}{2} \left(\Phi^k{}_{il} \Phi_{kj}{}^l - \Phi^k{}_{li} \Phi^l{}_{kj}\right) + \mathcal{O}(\partial\Phi). \end{align}
</p>
<p> Gathering everything together, we compute the spatial Ricci tensor as: </p><p class="formulaDsp">
\begin{eqnarray} R_{i j} &amp;=&amp; \frac{1}{2} \gamma^{kl} \left(\partial_{(j|}\Phi_{lk|i)} - \partial_{(j}\Phi_{i)kl} + \partial_k \Phi_{(ij)l} - \partial_l \Phi_{kij}\right)\nonumber\\ &amp;+&amp; \frac{1}{2} \left(\Phi_{ijk} + \Phi_{jik} - \Phi_{kij}\right) (d^k - 2 b^k) + \frac{1}{4} \Phi_{ik}{}^l \Phi_{jl}{}^k + \frac{1}{2} \left(\Phi^k{}_{il} \Phi_{kj}{}^l - \Phi^k{}_{li} \Phi^l{}_{kj}\right). \label{eq:rij} \end{eqnarray}
</p>
<p> This follows from equations (2.13) - (2.20) of <b>[Kidder2001tz]</b> .</p>
<p>Note that, in code, the mixed-index variables \(\Phi_{ij}{}^k\) and \(\Phi^i{}_{jk}\) in Eq.( \(\ref{eq:rij}\)) are computed with a factor of \(1/2\) and so the last 3 terms in the same equation that are quadratic in these terms occur multiplied by a factor of \(4\). </p>

</div>
</div>
<a id="ga31ad1bd676bbcbcb472568c55efe27a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31ad1bd676bbcbcb472568c55efe27a1">&#9670;&nbsp;</a></span>time_deriv_of_lapse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; GeneralizedHarmonic::time_deriv_of_lapse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_unit_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes time derivative of lapse ( \(\alpha\)) from the generalized harmonic variables, lapse, shift and the spacetime unit normal 1-form. </p>
<h3>Details</h3>
<p>Let the generalized harmonic conjugate momentum and spatial derivative variables be \(\Pi_{ab} = -n^c \partial_c g_{ab} \) and \(\Phi_{iab} = \partial_i g_{ab} \), and the operator \(D := \partial_0 - \beta^k \partial_k \). The time derivative of \(\alpha\) is then:</p>
<p class="formulaDsp">
\begin{align*} \frac{1}{2} \alpha^2 n^a n^b \Pi_{ab} - \frac{1}{2} \alpha \beta^i n^a n^b \Phi_{iab} =&amp; \frac{1}{2} \alpha^2 n^a n^b n^c \partial_c g_{ab} - \frac{1}{2} \alpha \beta^i (-(2/\alpha) \partial_i \alpha) \\ =&amp; \frac{1}{2} \alpha^2 [ \\ &amp;-(1/\alpha^3) D[\gamma_{jk} \beta^j \beta^k - \alpha^2] \\ &amp;- (\beta^j \beta^k / \alpha^3)D[\gamma_{jk}] \\ &amp;+ 2 (\beta^j / \alpha^3) D[\gamma_{jk} \beta^k] \\ &amp;+ (2 / \alpha^2)(\beta^i \partial_i \alpha)]] \\ =&amp; \frac{1}{2\alpha} [-D[\gamma_{jk}\beta^j\beta^k - \alpha^2] - \beta^j\beta^k D[\gamma_{jk}] + 2\alpha \beta^k\partial_k \alpha + 2\beta^j D[\gamma_{jk}\beta^k]] \\ =&amp; D[\alpha] + \beta^k\partial_k \alpha \\ =&amp; \partial_0 \alpha \end{align*}
</p>
<p>where the simplification done for \(\partial_i \alpha\) is used to substitute for the second term ( \(\frac{1}{2} \alpha \beta^i n^a n^b \Phi_{iab}\)).</p>
<p>Thus,</p>
<p class="formulaDsp">
\[ \partial_0 \alpha = (\alpha/2)(\alpha n^a n^b \Pi_{ab} - \beta^i n^a n^b \Phi_{iab}) \]
</p>
 
</div>
</div>
<a id="gaf315d2a3e0a2cf5765805cf7a680e768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf315d2a3e0a2cf5765805cf7a680e768">&#9670;&nbsp;</a></span>time_deriv_of_lapse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::time_deriv_of_lapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dt_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_unit_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes time derivative of lapse ( \(\alpha\)) from the generalized harmonic variables, lapse, shift and the spacetime unit normal 1-form. </p>
<h3>Details</h3>
<p>Let the generalized harmonic conjugate momentum and spatial derivative variables be \(\Pi_{ab} = -n^c \partial_c g_{ab} \) and \(\Phi_{iab} = \partial_i g_{ab} \), and the operator \(D := \partial_0 - \beta^k \partial_k \). The time derivative of \(\alpha\) is then:</p>
<p class="formulaDsp">
\begin{align*} \frac{1}{2} \alpha^2 n^a n^b \Pi_{ab} - \frac{1}{2} \alpha \beta^i n^a n^b \Phi_{iab} =&amp; \frac{1}{2} \alpha^2 n^a n^b n^c \partial_c g_{ab} - \frac{1}{2} \alpha \beta^i (-(2/\alpha) \partial_i \alpha) \\ =&amp; \frac{1}{2} \alpha^2 [ \\ &amp;-(1/\alpha^3) D[\gamma_{jk} \beta^j \beta^k - \alpha^2] \\ &amp;- (\beta^j \beta^k / \alpha^3)D[\gamma_{jk}] \\ &amp;+ 2 (\beta^j / \alpha^3) D[\gamma_{jk} \beta^k] \\ &amp;+ (2 / \alpha^2)(\beta^i \partial_i \alpha)]] \\ =&amp; \frac{1}{2\alpha} [-D[\gamma_{jk}\beta^j\beta^k - \alpha^2] - \beta^j\beta^k D[\gamma_{jk}] + 2\alpha \beta^k\partial_k \alpha + 2\beta^j D[\gamma_{jk}\beta^k]] \\ =&amp; D[\alpha] + \beta^k\partial_k \alpha \\ =&amp; \partial_0 \alpha \end{align*}
</p>
<p>where the simplification done for \(\partial_i \alpha\) is used to substitute for the second term ( \(\frac{1}{2} \alpha \beta^i n^a n^b \Phi_{iab}\)).</p>
<p>Thus,</p>
<p class="formulaDsp">
\[ \partial_0 \alpha = (\alpha/2)(\alpha n^a n^b \Pi_{ab} - \beta^i n^a n^b \Phi_{iab}) \]
</p>
 
</div>
</div>
<a id="ga1fb28da7e5755e0daa515e5c48839c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fb28da7e5755e0daa515e5c48839c3c">&#9670;&nbsp;</a></span>time_deriv_of_lower_shift() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt;DataType, SpatialDim, Frame&gt; GeneralizedHarmonic::time_deriv_of_lower_shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_unit_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes time derivative of index lowered shift from generalized harmonic variables, spatial metric and its time derivative. </p>
<h3>Details</h3>
<p>The time derivative of \( \beta_i \) is given by: </p><p class="formulaDsp">
\begin{align*} \partial_0 \beta_i = \gamma_{ij} \partial_0 \beta^j + \beta^j \partial_0 \gamma_{ij} \end{align*}
</p>
<p> where the first term is obtained from <code><a class="el" href="group__GeneralRelativityGroup.html#gad224b9ff081393614b12f4c246d5a194" title="Computes time derivative of the shift vector from the generalized harmonic and geometric variables.">time_deriv_of_shift()</a></code>, and the latter is a user input. </p>

</div>
</div>
<a id="ga9f445c797aa9bd1437c872b8f84a2f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f445c797aa9bd1437c872b8f84a2f19">&#9670;&nbsp;</a></span>time_deriv_of_lower_shift() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::time_deriv_of_lower_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dt_lower_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_unit_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes time derivative of index lowered shift from generalized harmonic variables, spatial metric and its time derivative. </p>
<h3>Details</h3>
<p>The time derivative of \( \beta_i \) is given by: </p><p class="formulaDsp">
\begin{align*} \partial_0 \beta_i = \gamma_{ij} \partial_0 \beta^j + \beta^j \partial_0 \gamma_{ij} \end{align*}
</p>
<p> where the first term is obtained from <code><a class="el" href="group__GeneralRelativityGroup.html#gad224b9ff081393614b12f4c246d5a194" title="Computes time derivative of the shift vector from the generalized harmonic and geometric variables.">time_deriv_of_shift()</a></code>, and the latter is a user input. </p>

</div>
</div>
<a id="ga3ad04becb36b2aba46f0ed0bc0ba804b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ad04becb36b2aba46f0ed0bc0ba804b">&#9670;&nbsp;</a></span>time_deriv_of_shift() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::I&lt;DataType, SpatialDim, Frame&gt; GeneralizedHarmonic::time_deriv_of_shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_unit_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes time derivative of the shift vector from the generalized harmonic and geometric variables. </p>
<h3>Details</h3>
<p>The time derivative of \( \beta^i \) can be derived from the following steps: </p><p class="formulaDsp">
\begin{align*} \partial_0 \beta^i =&amp; \gamma^{ik} \partial_0 (\gamma_{kj} \beta^j) - \beta^j \gamma^{ik} \partial_0 \gamma_{kj} \\ =&amp; \alpha \gamma^{ik} n^b \partial_0 g_{kb} \\ =&amp; \alpha \gamma^{ik} n^b (\partial_0 - \beta^j\partial_j) g_{kb} + \alpha \gamma^{ik} n^b \beta^j\partial_j g_{kb} \\ =&amp; -\alpha^2 n^b\Pi_{kb} \gamma^{ik} + \alpha \beta^j n^b\Phi_{jkb} \gamma^{ik} \\ =&amp; -\alpha \gamma^{ik} n^b (\alpha \Pi_{kb} - \beta^j \Phi_{jkb}) \\ \end{align*}
</p>
 
</div>
</div>
<a id="gad224b9ff081393614b12f4c246d5a194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad224b9ff081393614b12f4c246d5a194">&#9670;&nbsp;</a></span>time_deriv_of_shift() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::time_deriv_of_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dt_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_unit_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes time derivative of the shift vector from the generalized harmonic and geometric variables. </p>
<h3>Details</h3>
<p>The time derivative of \( \beta^i \) can be derived from the following steps: </p><p class="formulaDsp">
\begin{align*} \partial_0 \beta^i =&amp; \gamma^{ik} \partial_0 (\gamma_{kj} \beta^j) - \beta^j \gamma^{ik} \partial_0 \gamma_{kj} \\ =&amp; \alpha \gamma^{ik} n^b \partial_0 g_{kb} \\ =&amp; \alpha \gamma^{ik} n^b (\partial_0 - \beta^j\partial_j) g_{kb} + \alpha \gamma^{ik} n^b \beta^j\partial_j g_{kb} \\ =&amp; -\alpha^2 n^b\Pi_{kb} \gamma^{ik} + \alpha \beta^j n^b\Phi_{jkb} \gamma^{ik} \\ =&amp; -\alpha \gamma^{ik} n^b (\alpha \Pi_{kb} - \beta^j \Phi_{jkb}) \\ \end{align*}
</p>
 
</div>
</div>
<a id="ga32556fbd094f862e1f8d413c5f57e9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32556fbd094f862e1f8d413c5f57e9da">&#9670;&nbsp;</a></span>time_deriv_of_spatial_metric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt;DataType, SpatialDim, Frame&gt; GeneralizedHarmonic::time_deriv_of_spatial_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes time derivative of the spatial metric. </p>
<h3>Details</h3>
<p>Let the generalized harmonic conjugate momentum and spatial derivative variables be \(\Pi_{ab} = -n^c \partial_c g_{ab} \) and \(\Phi_{iab} = \partial_i g_{ab} \). As \( n_i \equiv 0 \). The time derivative of the spatial metric is given by the time derivative of the spatial sector of the spacetime metric, i.e. \( \partial_0 \gamma_{ij} = \partial_0 g_{ij} \).</p>
<p>To compute the latter, we use the evolution equation for \( g_{ij} \), c.f. eq.(35) of <b>[Lindblom2005qh]</b> (with \(\gamma_1 = -1\)):</p>
<p class="formulaDsp">
\[ \partial_0 g_{ab} = - \alpha \Pi_{ab} + \beta^k \Phi_{kab} \]
</p>
 
</div>
</div>
<a id="ga06fe45b0ce075b1a6e4439455bfa9cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06fe45b0ce075b1a6e4439455bfa9cf4">&#9670;&nbsp;</a></span>time_deriv_of_spatial_metric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::time_deriv_of_spatial_metric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes time derivative of the spatial metric. </p>
<h3>Details</h3>
<p>Let the generalized harmonic conjugate momentum and spatial derivative variables be \(\Pi_{ab} = -n^c \partial_c g_{ab} \) and \(\Phi_{iab} = \partial_i g_{ab} \). As \( n_i \equiv 0 \). The time derivative of the spatial metric is given by the time derivative of the spatial sector of the spacetime metric, i.e. \( \partial_0 \gamma_{ij} = \partial_0 g_{ij} \).</p>
<p>To compute the latter, we use the evolution equation for \( g_{ij} \), c.f. eq.(35) of <b>[Lindblom2005qh]</b> (with \(\gamma_1 = -1\)):</p>
<p class="formulaDsp">
\[ \partial_0 g_{ab} = - \alpha \Pi_{ab} + \beta^k \Phi_{kab} \]
</p>
 
</div>
</div>
<a id="gab5b28f7c0048f1ce5d108496f47dadf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5b28f7c0048f1ce5d108496f47dadf4">&#9670;&nbsp;</a></span>time_derivative_of_spacetime_metric() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::aa&lt;DataType, SpatialDim, Frame&gt; gr::time_derivative_of_spacetime_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the time derivative of the spacetime metric from spatial metric, lapse, shift, and their time derivatives. </p>
<h3>Details</h3>
<p>Computes the derivative as:</p>
<p class="formulaDsp">
\begin{align} \partial_t g_{tt} &amp;= - 2 \alpha \partial_t \alpha - 2 \gamma_{i j} \beta^i \partial_t \beta^j + \beta^i \beta^j \partial_t \gamma_{i j}\\ \partial_t g_{t i} &amp;= \gamma_{j i} \partial_t \beta^j + \beta^j \partial_t \gamma_{j i}\\ \partial_t g_{i j} &amp;= \partial_t \gamma_{i j}, \end{align}
</p>
<p>where \(\alpha, \beta^i, \gamma_{ij}\) are the lapse, shift, and spatial metric respectively. </p>

</div>
</div>
<a id="gacb5cd5d5792a2bec008e77dddc7784d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb5cd5d5792a2bec008e77dddc7784d4">&#9670;&nbsp;</a></span>time_derivative_of_spacetime_metric() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::aa&lt;DataType, SpatialDim, Frame&gt; GeneralizedHarmonic::time_derivative_of_spacetime_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the time derivative of the spacetime metric from the generalized harmonic quantities \(\Pi_{a b}\), \(\Phi_{i a b}\), and the lapse \(\alpha\) and shift \(\beta^i\). </p>
<h3>Details</h3>
<p>Computes the derivative as:</p>
<p class="formulaDsp">
\begin{align} \partial_t g_{a b} = \beta^i \Phi_{i a b} - \alpha \Pi_{a b}. \end{align}
</p>
 
</div>
</div>
<a id="ga726297e2de76748fc7349184eca75839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga726297e2de76748fc7349184eca75839">&#9670;&nbsp;</a></span>time_derivative_of_spacetime_metric() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::time_derivative_of_spacetime_metric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dt_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the time derivative of the spacetime metric from spatial metric, lapse, shift, and their time derivatives. </p>
<h3>Details</h3>
<p>Computes the derivative as:</p>
<p class="formulaDsp">
\begin{align} \partial_t g_{tt} &amp;= - 2 \alpha \partial_t \alpha - 2 \gamma_{i j} \beta^i \partial_t \beta^j + \beta^i \beta^j \partial_t \gamma_{i j}\\ \partial_t g_{t i} &amp;= \gamma_{j i} \partial_t \beta^j + \beta^j \partial_t \gamma_{j i}\\ \partial_t g_{i j} &amp;= \partial_t \gamma_{i j}, \end{align}
</p>
<p>where \(\alpha, \beta^i, \gamma_{ij}\) are the lapse, shift, and spatial metric respectively. </p>

</div>
</div>
<a id="ga689776209c34d7872caca3559f4c29e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga689776209c34d7872caca3559f4c29e8">&#9670;&nbsp;</a></span>time_derivative_of_spacetime_metric() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GeneralizedHarmonic::time_derivative_of_spacetime_metric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dt_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the time derivative of the spacetime metric from the generalized harmonic quantities \(\Pi_{a b}\), \(\Phi_{i a b}\), and the lapse \(\alpha\) and shift \(\beta^i\). </p>
<h3>Details</h3>
<p>Computes the derivative as:</p>
<p class="formulaDsp">
\begin{align} \partial_t g_{a b} = \beta^i \Phi_{i a b} - \alpha \Pi_{a b}. \end{align}
</p>
 
</div>
</div>
<a id="ga8ac9fe1029ccaaf32f8ed898708dbbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ac9fe1029ccaaf32f8ed898708dbbc3">&#9670;&nbsp;</a></span>time_derivative_of_spatial_metric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt;DataType, SpatialDim, Frame&gt; gr::time_derivative_of_spatial_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>extrinsic_curvature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the time derivative of the spatial metric from extrinsic curvature, lapse, shift, and their time derivatives. </p>
<h3>Details</h3>
<p>Computes the derivative as (see e.g. <b>[BaumgarteShapiro]</b>, Eq. (2.134)):</p>
<p class="formulaDsp">
\begin{equation} \partial_t \gamma_{ij} = -2 \alpha K_{ij} + 2 \nabla_{(i} \beta_{j)} = -2 \alpha K_{ij} + \beta^k \partial_k \gamma_{ij} + \gamma_{ik} \partial_j \beta^k + \gamma_{jk} \partial_i \beta^k \end{equation}
</p>
<p>where \(\alpha\) is the lapse, \(\beta^i\) is the shift, \(\gamma_{ij}\) is the spatial metric and \(K_{ij}\) is the extrinsic curvature. </p>

</div>
</div>
<a id="ga02abbd1da4fe227e9b79b0a1799647b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02abbd1da4fe227e9b79b0a1799647b4">&#9670;&nbsp;</a></span>time_derivative_of_spatial_metric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::time_derivative_of_spatial_metric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iJ&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>extrinsic_curvature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the time derivative of the spatial metric from extrinsic curvature, lapse, shift, and their time derivatives. </p>
<h3>Details</h3>
<p>Computes the derivative as (see e.g. <b>[BaumgarteShapiro]</b>, Eq. (2.134)):</p>
<p class="formulaDsp">
\begin{equation} \partial_t \gamma_{ij} = -2 \alpha K_{ij} + 2 \nabla_{(i} \beta_{j)} = -2 \alpha K_{ij} + \beta^k \partial_k \gamma_{ij} + \gamma_{ik} \partial_j \beta^k + \gamma_{jk} \partial_i \beta^k \end{equation}
</p>
<p>where \(\alpha\) is the lapse, \(\beta^i\) is the shift, \(\gamma_{ij}\) is the spatial metric and \(K_{ij}\) is the extrinsic curvature. </p>

</div>
</div>
<a id="ga7f4b751ba525894f2ffb296607618cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f4b751ba525894f2ffb296607618cec">&#9670;&nbsp;</a></span>to_different_frame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename SrcFrame , typename DestFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void transform::to_different_frame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, SrcFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame, SrcFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms tensor to different frame.</p>
<p>The formula for transforming \(T_{ij}\) is </p><p class="formulaDsp">
\begin{align} T_{\bar{\imath}\bar{\jmath}} &amp;= T_{ij} \frac{\partial x^i}{\partial x^{\bar{\imath}}} \frac{\partial x^j}{\partial x^{\bar{\jmath}}} \end{align}
</p>
<p> where \(x^i\) are the source coordinates and \(x^{\bar{\imath}}\) are the destination coordinates.</p>
<p>Note that <code>Jacobian&lt;DestFrame,SrcFrame&gt;</code> is the same type as <code>InverseJacobian&lt;SrcFrame,DestFrame&gt;</code> and represents \(\partial x^i/\partial x^{\bar{\jmath}}\).</p>
<p>In principle <code>to_different_frame</code> can be extended/generalized to other tensor types if needed. </p>

</div>
</div>
<a id="ga859a079f096cec1caa989e6c9d1fede7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga859a079f096cec1caa989e6c9d1fede7">&#9670;&nbsp;</a></span>to_different_frame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename SrcFrame , typename DestFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto transform::to_different_frame </td>
          <td>(</td>
          <td class="paramtype">const tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, SrcFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Jacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame, SrcFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, DestFrame &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms tensor to different frame.</p>
<p>The formula for transforming \(T_{ij}\) is </p><p class="formulaDsp">
\begin{align} T_{\bar{\imath}\bar{\jmath}} &amp;= T_{ij} \frac{\partial x^i}{\partial x^{\bar{\imath}}} \frac{\partial x^j}{\partial x^{\bar{\jmath}}} \end{align}
</p>
<p> where \(x^i\) are the source coordinates and \(x^{\bar{\imath}}\) are the destination coordinates.</p>
<p>Note that <code>Jacobian&lt;DestFrame,SrcFrame&gt;</code> is the same type as <code>InverseJacobian&lt;SrcFrame,DestFrame&gt;</code> and represents \(\partial x^i/\partial x^{\bar{\jmath}}\).</p>
<p>In principle <code>to_different_frame</code> can be extended/generalized to other tensor types if needed. </p>

</div>
</div>
<a id="gac987c0a854c67954e427277beccbced4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac987c0a854c67954e427277beccbced4">&#9670;&nbsp;</a></span>trace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; trace </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; Index0, Index0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes trace of a rank-2 symmetric tensor. </p>
<h3>Details</h3>
<p>Computes \(g^{ab}T_{ab}\) or \(g_{ab}T^{ab}\) where \((a,b)\) can be spatial or spacetime indices. </p>

</div>
</div>
<a id="gacc6a7bfb2bc92b95ce132a274312d94f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc6a7bfb2bc92b95ce132a274312d94f">&#9670;&nbsp;</a></span>trace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void trace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>trace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; Index0, Index0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes trace of a rank-2 symmetric tensor. </p>
<h3>Details</h3>
<p>Computes \(g^{ab}T_{ab}\) or \(g_{ab}T^{ab}\) where \((a,b)\) can be spatial or spacetime indices. </p>

</div>
</div>
<a id="ga3e822981a2abfd63cc4218a36bae08e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e822981a2abfd63cc4218a36bae08e4">&#9670;&nbsp;</a></span>trace_last_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt;1&gt;, index_list&lt;Index0&gt; &gt; trace_last_indices </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 2, 1, 1 &gt;, index_list&lt; Index0, Index1, Index1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index1 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index1 &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes trace of a rank 3 tensor, which is symmetric in its last two indices, tracing the symmetric indices. </p>
<h3>Details</h3>
<p>For example, if \( T_{abc} \) is a tensor such that \(T_{abc} = T_{acb} \) then \( T_a = g^{bc}T_{abc} \) is computed, where \( g^{bc} \) is the inverse metric. Note that indices \(a,b,c,...\) can represent either spatial or spacetime indices, and can have either valence. You may have to add a new instantiation of this template if you need a new use case. </p>

</div>
</div>
<a id="gabd55449cbc431fe342054f29d312a6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd55449cbc431fe342054f29d312a6f1">&#9670;&nbsp;</a></span>trace_last_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void trace_last_indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; Index0 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>trace_of_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 2, 1, 1 &gt;, index_list&lt; Index0, Index1, Index1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index1 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index1 &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes trace of a rank 3 tensor, which is symmetric in its last two indices, tracing the symmetric indices. </p>
<h3>Details</h3>
<p>For example, if \( T_{abc} \) is a tensor such that \(T_{abc} = T_{acb} \) then \( T_a = g^{bc}T_{abc} \) is computed, where \( g^{bc} \) is the inverse metric. Note that indices \(a,b,c,...\) can represent either spatial or spacetime indices, and can have either valence. You may have to add a new instantiation of this template if you need a new use case. </p>

</div>
</div>
<a id="gada26975d50b5054c09b8476eb09d5daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada26975d50b5054c09b8476eb09d5daf">&#9670;&nbsp;</a></span>transverse_projection_operator() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::Ab&lt;DataType, VolumeDim, Frame&gt; gr::transverse_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const tnsr::A&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_normal_one_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_unit_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_unit_normal_one_form</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute spacetime projection operator onto an interface. </p>
<h3>Details</h3>
<p>Consider a \(d-1\)-dimensional surface \(S\) in a \(d\)-dimensional spatial hypersurface \(\Sigma\). Let \(s^a\) \((s_a)\) be the unit spacelike vector (one-form) orthogonal to \(S\) in \(\Sigma\), and \(n^a\) \((n_a)\) be the timelike unit vector (one-form) orthogonal to \(\Sigma\). This function returns the projection operator onto \(S\) for \(d+1\) dimensional quantities:</p>
<p class="formulaDsp">
\begin{align*} P^a_b = \delta^a_b + n^a n_b - s^a s_b. \end{align*}
</p>
 
</div>
</div>
<a id="ga8c0b22f7c57d918868278ed0b1e4d0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0b22f7c57d918868278ed0b1e4d0d4">&#9670;&nbsp;</a></span>transverse_projection_operator() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::AA&lt;DataType, VolumeDim, Frame&gt; gr::transverse_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const tnsr::AA&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_unit_normal_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute spacetime projection operator onto an interface. </p>
<h3>Details</h3>
<p>Consider a \(d-1\)-dimensional surface \(S\) in a \(d\)-dimensional spatial hypersurface \(\Sigma\). Let \(s^a\) be the unit spacelike vector orthogonal to \(S\) in \(\Sigma\), and \(n^a\) be the timelike unit vector orthogonal to \(\Sigma\). This function returns the projection operator onto \(S\) for \(d+1\) dimensional quantities:</p>
<p class="formulaDsp">
\begin{align*} P^{ab} = g^{ab} + n^a n^b - s^a s^b = \gamma_{ab} - s_a s_b. \end{align*}
</p>
 
</div>
</div>
<a id="ga5a9149328dbeb565834619b8d10f1eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a9149328dbeb565834619b8d10f1eae">&#9670;&nbsp;</a></span>transverse_projection_operator() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::aa&lt;DataType, VolumeDim, Frame&gt; gr::transverse_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const tnsr::aa&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_normal_one_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_unit_normal_one_form</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute spacetime projection operator onto an interface. </p>
<h3>Details</h3>
<p>Consider a \(d-1\)-dimensional surface \(S\) in a \(d\)-dimensional spatial hypersurface \(\Sigma\). Let \(s_a\) be the unit spacelike one-form orthogonal to \(S\) in \(\Sigma\), and \(n_a\) be the timelike unit vector orthogonal to \(\Sigma\). This function returns the projection operator onto \(S\) for \(d+1\) dimensional quantities:</p>
<p class="formulaDsp">
\begin{align*} P_{ab} = g_{ab} + n_a n_b - s_a s_b = \gamma_{ab} - s_a s_b. \end{align*}
</p>
 
</div>
</div>
<a id="ga700fa05b6a7985e7dd2616eaf7850bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga700fa05b6a7985e7dd2616eaf7850bb2">&#9670;&nbsp;</a></span>transverse_projection_operator() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::Ij&lt;DataType, VolumeDim, Frame&gt; gr::transverse_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal_one_form</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute projection operator onto an interface. </p>
<h3>Details</h3>
<p>Returns the operator \(P^{i}_{j} = \delta^{i}_{j} - n^i n_j\), where \(n^i\) and \(n_i\) are the normal vector and normal one-form to the interface in question. </p>

</div>
</div>
<a id="gad6471e406bac1d636e2c41f22559fdd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6471e406bac1d636e2c41f22559fdd0">&#9670;&nbsp;</a></span>transverse_projection_operator() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::II&lt;DataType, VolumeDim, Frame&gt; gr::transverse_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute projection operator onto an interface. </p>
<h3>Details</h3>
<p>Returns the operator \(P^{ij} = \gamma^{ij} - n^i n^j\), where \(\gamma^{ij}\) is the inverse spatial metric, and \(n^i\) is the normal vector to the interface in question. </p>

</div>
</div>
<a id="ga51ba489799f45a4cf45306d5376778da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51ba489799f45a4cf45306d5376778da">&#9670;&nbsp;</a></span>transverse_projection_operator() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt;DataType, VolumeDim, Frame&gt; gr::transverse_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const tnsr::ii&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal_one_form</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute projection operator onto an interface. </p>
<h3>Details</h3>
<p>Returns the operator \(P_{ij} = \gamma_{ij} - n_i n_j\), where \( \gamma_{ij}\) is the spatial metric, and \( n_i\) is the normal one-form to the interface in question. </p>

</div>
</div>
<a id="ga622250f5d3b6cfd6d12844b5d3998d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga622250f5d3b6cfd6d12844b5d3998d2d">&#9670;&nbsp;</a></span>transverse_projection_operator() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::transverse_projection_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::AA&lt; DataType, VolumeDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>projection_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_unit_normal_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute spacetime projection operator onto an interface. </p>
<h3>Details</h3>
<p>Consider a \(d-1\)-dimensional surface \(S\) in a \(d\)-dimensional spatial hypersurface \(\Sigma\). Let \(s^a\) be the unit spacelike vector orthogonal to \(S\) in \(\Sigma\), and \(n^a\) be the timelike unit vector orthogonal to \(\Sigma\). This function returns the projection operator onto \(S\) for \(d+1\) dimensional quantities:</p>
<p class="formulaDsp">
\begin{align*} P^{ab} = g^{ab} + n^a n^b - s^a s^b = \gamma_{ab} - s_a s_b. \end{align*}
</p>
 
</div>
</div>
<a id="gaeda525bdfde12746a8794e1c17e0cd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeda525bdfde12746a8794e1c17e0cd84">&#9670;&nbsp;</a></span>transverse_projection_operator() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::transverse_projection_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; DataType, VolumeDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>projection_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_normal_one_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_unit_normal_one_form</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute spacetime projection operator onto an interface. </p>
<h3>Details</h3>
<p>Consider a \(d-1\)-dimensional surface \(S\) in a \(d\)-dimensional spatial hypersurface \(\Sigma\). Let \(s_a\) be the unit spacelike one-form orthogonal to \(S\) in \(\Sigma\), and \(n_a\) be the timelike unit vector orthogonal to \(\Sigma\). This function returns the projection operator onto \(S\) for \(d+1\) dimensional quantities:</p>
<p class="formulaDsp">
\begin{align*} P_{ab} = g_{ab} + n_a n_b - s_a s_b = \gamma_{ab} - s_a s_b. \end{align*}
</p>
 
</div>
</div>
<a id="ga2d298c7ff2b19fccb9d7f3c7e15e4c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d298c7ff2b19fccb9d7f3c7e15e4c5c">&#9670;&nbsp;</a></span>transverse_projection_operator() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::transverse_projection_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::Ab&lt; DataType, VolumeDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>projection_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_normal_one_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_unit_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_unit_normal_one_form</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute spacetime projection operator onto an interface. </p>
<h3>Details</h3>
<p>Consider a \(d-1\)-dimensional surface \(S\) in a \(d\)-dimensional spatial hypersurface \(\Sigma\). Let \(s^a\) \((s_a)\) be the unit spacelike vector (one-form) orthogonal to \(S\) in \(\Sigma\), and \(n^a\) \((n_a)\) be the timelike unit vector (one-form) orthogonal to \(\Sigma\). This function returns the projection operator onto \(S\) for \(d+1\) dimensional quantities:</p>
<p class="formulaDsp">
\begin{align*} P^a_b = \delta^a_b + n^a n_b - s^a s_b. \end{align*}
</p>
 
</div>
</div>
<a id="ga5036a2fa712fa3c111f73e85457383fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5036a2fa712fa3c111f73e85457383fc">&#9670;&nbsp;</a></span>transverse_projection_operator() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::transverse_projection_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::II&lt; DataType, VolumeDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>projection_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute projection operator onto an interface. </p>
<h3>Details</h3>
<p>Returns the operator \(P^{ij} = \gamma^{ij} - n^i n^j\), where \(\gamma^{ij}\) is the inverse spatial metric, and \(n^i\) is the normal vector to the interface in question. </p>

</div>
</div>
<a id="ga670675792d7b770c0834813669f77a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga670675792d7b770c0834813669f77a82">&#9670;&nbsp;</a></span>transverse_projection_operator() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::transverse_projection_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, VolumeDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>projection_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal_one_form</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute projection operator onto an interface. </p>
<h3>Details</h3>
<p>Returns the operator \(P_{ij} = \gamma_{ij} - n_i n_j\), where \( \gamma_{ij}\) is the spatial metric, and \( n_i\) is the normal one-form to the interface in question. </p>

</div>
</div>
<a id="gaf55c99456de6de100b7169597aff2723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf55c99456de6de100b7169597aff2723">&#9670;&nbsp;</a></span>transverse_projection_operator() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::transverse_projection_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::Ij&lt; DataType, VolumeDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>projection_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal_one_form</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute projection operator onto an interface. </p>
<h3>Details</h3>
<p>Returns the operator \(P^{i}_{j} = \delta^{i}_{j} - n^i n_j\), where \(n^i\) and \(n_i\) are the normal vector and normal one-form to the interface in question. </p>

</div>
</div>
<a id="gae58ecf9d4b12748cf43c16010f7e214d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae58ecf9d4b12748cf43c16010f7e214d">&#9670;&nbsp;</a></span>weyl_electric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt;DataType, SpatialDim, Frame&gt; gr::weyl_electric </td>
          <td>(</td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_ricci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>extrinsic_curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the electric part of the Weyl tensor in vacuum. </p>
<h3>Details</h3>
<p>Computes the electric part of the Weyl tensor in vacuum \(E_{ij}\) as: \( E_{ij} = R_{ij} + KK_{ij} - K^m_{i}K_{mj}\) where \(R_{ij}\) is the spatial Ricci tensor, \(K_{ij}\) is the extrinsic curvature, and \(K\) is the trace of \(K_{ij}\). An additional definition is \(E_{ij} = n^a n^b C_{a i b j}\), where \(n\) is the unit-normal to the hypersurface and \(C\) is the Weyl tensor consistent with the conventions in <b>[Boyle2019kee]</b>. </p><dl class="section note"><dt>Note</dt><dd>This needs additional terms for computations in a non-vacuum. </dd></dl>

</div>
</div>
<a id="ga2d2c188cf0426776e831a65d8af1ab5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d2c188cf0426776e831a65d8af1ab5b">&#9670;&nbsp;</a></span>weyl_electric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::weyl_electric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>weyl_electric_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_ricci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>extrinsic_curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the electric part of the Weyl tensor in vacuum. </p>
<h3>Details</h3>
<p>Computes the electric part of the Weyl tensor in vacuum \(E_{ij}\) as: \( E_{ij} = R_{ij} + KK_{ij} - K^m_{i}K_{mj}\) where \(R_{ij}\) is the spatial Ricci tensor, \(K_{ij}\) is the extrinsic curvature, and \(K\) is the trace of \(K_{ij}\). An additional definition is \(E_{ij} = n^a n^b C_{a i b j}\), where \(n\) is the unit-normal to the hypersurface and \(C\) is the Weyl tensor consistent with the conventions in <b>[Boyle2019kee]</b>. </p><dl class="section note"><dt>Note</dt><dd>This needs additional terms for computations in a non-vacuum. </dd></dl>

</div>
</div>
<a id="ga7293171d21f1d5acd0305908034c75a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7293171d21f1d5acd0305908034c75a9">&#9670;&nbsp;</a></span>weyl_electric_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; gr::weyl_electric_scalar </td>
          <td>(</td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>weyl_electric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the scalar \(E_{ij} E^{ij}\) from the electric part of the Weyl tensor \(E_{ij}\). </p>
<h3>Details</h3>
<p>Computes the scalar \(E_{ij} E^{ij}\) from the electric part of the Weyl tensor \(E_{ij}\) and the inverse spatial metric \(\gamma^{ij}\), i.e. \(E_{ij} = \gamma^{ik}\gamma^{jl}E_{ij}E_{kl}\).</p>
<dl class="section note"><dt>Note</dt><dd>The electric part of the Weyl tensor in vacuum is available via <a class="el" href="group__GeneralRelativityGroup.html#gae58ecf9d4b12748cf43c16010f7e214d" title="Computes the electric part of the Weyl tensor in vacuum.">gr::weyl_electric()</a>. The electric part of the Weyl tensor needs additional terms for matter. </dd></dl>

</div>
</div>
<a id="gac5e668ec48e7a29fdf364805dddde395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5e668ec48e7a29fdf364805dddde395">&#9670;&nbsp;</a></span>weyl_electric_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::weyl_electric_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>weyl_electric_scalar_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>weyl_electric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the scalar \(E_{ij} E^{ij}\) from the electric part of the Weyl tensor \(E_{ij}\). </p>
<h3>Details</h3>
<p>Computes the scalar \(E_{ij} E^{ij}\) from the electric part of the Weyl tensor \(E_{ij}\) and the inverse spatial metric \(\gamma^{ij}\), i.e. \(E_{ij} = \gamma^{ik}\gamma^{jl}E_{ij}E_{kl}\).</p>
<dl class="section note"><dt>Note</dt><dd>The electric part of the Weyl tensor in vacuum is available via <a class="el" href="group__GeneralRelativityGroup.html#gae58ecf9d4b12748cf43c16010f7e214d" title="Computes the electric part of the Weyl tensor in vacuum.">gr::weyl_electric()</a>. The electric part of the Weyl tensor needs additional terms for matter. </dd></dl>

</div>
</div>
<a id="ga9d9630ccce9b0b9ab6d4492446d8f751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d9630ccce9b0b9ab6d4492446d8f751">&#9670;&nbsp;</a></span>weyl_magnetic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt;DataType, 3, Frame&gt; gr::weyl_magnetic </td>
          <td>(</td>
          <td class="paramtype">const tnsr::ijj&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_extrinsic_curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>sqrt_det_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the magnetic part of the Weyl tensor. </p>
<h3>Details</h3>
<p>Computes the magnetic part of the Weyl tensor \(B_{ij}\) as:</p>
<p class="formulaDsp">
\begin{align} B_{ij} = \left(1/\sqrt{\det\gamma}\right)D_{k}K_{l(i}\gamma_{j)m}\epsilon^{mlk} \end{align}
</p>
<p>where \(\epsilon^{ijk}\) is the spatial Levi-Civita symbol, \(K_{ij}\) is the extrinsic curvature, \(\gamma_{jm} \) is the spatial metric, and \(D_i\) is spatial covariant derivative. </p>

</div>
</div>
<a id="gab9c44307d13655ed62414c7377b33290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9c44307d13655ed62414c7377b33290">&#9670;&nbsp;</a></span>weyl_magnetic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::weyl_magnetic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, 3, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>weyl_magnetic_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijj&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_extrinsic_curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>sqrt_det_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the magnetic part of the Weyl tensor. </p>
<h3>Details</h3>
<p>Computes the magnetic part of the Weyl tensor \(B_{ij}\) as:</p>
<p class="formulaDsp">
\begin{align} B_{ij} = \left(1/\sqrt{\det\gamma}\right)D_{k}K_{l(i}\gamma_{j)m}\epsilon^{mlk} \end{align}
</p>
<p>where \(\epsilon^{ijk}\) is the spatial Levi-Civita symbol, \(K_{ij}\) is the extrinsic curvature, \(\gamma_{jm} \) is the spatial metric, and \(D_i\) is spatial covariant derivative. </p>

</div>
</div>
<a id="gabe3afc42cb2db28524fb337c4b7ece55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe3afc42cb2db28524fb337c4b7ece55">&#9670;&nbsp;</a></span>weyl_magnetic_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; gr::weyl_magnetic_scalar </td>
          <td>(</td>
          <td class="paramtype">const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>weyl_magnetic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the scalar \(B_{ij} B^{ij}\) from the magnetic part of the Weyl tensor \(B_{ij}\). </p>
<h3>Details</h3>
<p>Computes the scalar \(B_{ij} B^{ij}\) from the magnetic part of the Weyl tensor \(B_{ij}\) and the inverse spatial metric \(\gamma^{ij}\), i.e. \(B_{ij} = \gamma^{ik}\gamma^{jl}B_{ij}B_{kl}\).</p>
<dl class="section note"><dt>Note</dt><dd>The magnetic part of the Weyl tensor in vacuum is available via <code><a class="el" href="group__GeneralRelativityGroup.html#ga9d9630ccce9b0b9ab6d4492446d8f751" title="Computes the magnetic part of the Weyl tensor.">gr::weyl_magnetic()</a></code>. The magnetic part of the Weyl tensor needs additional terms for matter. </dd></dl>

</div>
</div>
<a id="gac43d0aded3ba8ae48e43c2ec79635390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac43d0aded3ba8ae48e43c2ec79635390">&#9670;&nbsp;</a></span>weyl_magnetic_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::weyl_magnetic_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>weyl_magnetic_scalar_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>weyl_magnetic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the scalar \(B_{ij} B^{ij}\) from the magnetic part of the Weyl tensor \(B_{ij}\). </p>
<h3>Details</h3>
<p>Computes the scalar \(B_{ij} B^{ij}\) from the magnetic part of the Weyl tensor \(B_{ij}\) and the inverse spatial metric \(\gamma^{ij}\), i.e. \(B_{ij} = \gamma^{ik}\gamma^{jl}B_{ij}B_{kl}\).</p>
<dl class="section note"><dt>Note</dt><dd>The magnetic part of the Weyl tensor in vacuum is available via <code><a class="el" href="group__GeneralRelativityGroup.html#ga9d9630ccce9b0b9ab6d4492446d8f751" title="Computes the magnetic part of the Weyl tensor.">gr::weyl_magnetic()</a></code>. The magnetic part of the Weyl tensor needs additional terms for matter. </dd></dl>

</div>
</div>
<a id="ga57de98a26ae1837eb2b4c66ce6fcf43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57de98a26ae1837eb2b4c66ce6fcf43b">&#9670;&nbsp;</a></span>weyl_propagating() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt;DataType, SpatialDim, Frame&gt; gr::weyl_propagating </td>
          <td>(</td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>ricci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>extrinsic_curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>cov_deriv_extrinsic_curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_interface_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_IJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_ij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::Ij&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_Ij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the propagating modes of the Weyl tensor. </p>
<h3>Details</h3>
<p>The Weyl tensor evolution system in vacuum has six characteristic fields, of which two ( \( U^{8\pm}\)) are proportional to the Newman-Penrose components of the Weyl tensor \(\Psi_4\) and \(\Psi_0\). These represent the true gravitational-wave degrees of freedom, and can be written down in terms of \(3+1\) quantities as <b>[Kidder2004rw]</b> (see Eq. 75):</p>
<p class="formulaDsp">
\begin{align} U^{8\pm}_{ij} &amp;= \left(P^{k}_i P^{l}_j - \frac{1}{2} P_{ij} P^{kl}\right) \left(R_{kl} + K K_{kl} - K_k^m K_{ml} \mp n^m \nabla_m K_{kl} \pm n^m \nabla_{(k}K_{l)m} \right),\\ &amp;= \left(P^{k}_i P^{l}_j - \frac{1}{2} P_{ij} P^{kl}\right) \left(E_{kl} \mp n^m \nabla_m K_{kl} \pm n^m \nabla_{(k}K_{l)m}\right), \end{align}
</p>
<p>where \(R_{ij}\) is the spatial Ricci tensor, \(K_{ij}\) is the extrinsic curvature, \(K\) is the trace of \(K_{ij}\), \(E_{ij}\) is the electric part of the Weyl tensor in vacuum, \(n^i\) is the outward directed unit normal vector to the interface, \(\nabla_i\) denotes the covariant derivative, and \(P^{ij}\) and its index-raised and lowered forms project tensors transverse to \(n^i\). </p>

</div>
</div>
<a id="gac54931bb321adb90f721b48601711289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac54931bb321adb90f721b48601711289">&#9670;&nbsp;</a></span>weyl_propagating() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gr::weyl_propagating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; DataType, SpatialDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>weyl_prop_u8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>ricci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>extrinsic_curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ijj&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>cov_deriv_extrinsic_curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_interface_normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_IJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_ij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::Ij&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_Ij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the propagating modes of the Weyl tensor. </p>
<h3>Details</h3>
<p>The Weyl tensor evolution system in vacuum has six characteristic fields, of which two ( \( U^{8\pm}\)) are proportional to the Newman-Penrose components of the Weyl tensor \(\Psi_4\) and \(\Psi_0\). These represent the true gravitational-wave degrees of freedom, and can be written down in terms of \(3+1\) quantities as <b>[Kidder2004rw]</b> (see Eq. 75):</p>
<p class="formulaDsp">
\begin{align} U^{8\pm}_{ij} &amp;= \left(P^{k}_i P^{l}_j - \frac{1}{2} P_{ij} P^{kl}\right) \left(R_{kl} + K K_{kl} - K_k^m K_{ml} \mp n^m \nabla_m K_{kl} \pm n^m \nabla_{(k}K_{l)m} \right),\\ &amp;= \left(P^{k}_i P^{l}_j - \frac{1}{2} P_{ij} P^{kl}\right) \left(E_{kl} \mp n^m \nabla_m K_{kl} \pm n^m \nabla_{(k}K_{l)m}\right), \end{align}
</p>
<p>where \(R_{ij}\) is the spatial Ricci tensor, \(K_{ij}\) is the extrinsic curvature, \(K\) is the trace of \(K_{ij}\), \(E_{ij}\) is the electric part of the Weyl tensor in vacuum, \(n^i\) is the outward directed unit normal vector to the interface, \(\nabla_i\) denotes the covariant derivative, and \(P^{ij}\) and its index-raised and lowered forms project tensors transverse to \(n^i\). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
