<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.1"/>
  <title>SpECTRE: Tensor</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.08.01</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__TensorGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Tensor</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFrame_1_1FrameIsPhysical.html">Frame::FrameIsPhysical</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> as being "physical" in the sense that it is meaningful to evaluate an analytic solution in that frame.  <a href="structFrame_1_1FrameIsPhysical.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtt_1_1is__tensor__index__type.html">tt::is_tensor_index_type&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherits from <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a> if T is a <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>.  <a href="structtt_1_1is__tensor__index__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor_3_01X_00_01Symm_00_01IndexList_3_01Indices_8_8_8_01_4_01_4.html">Tensor&lt; X, Symm, IndexList&lt; Indices... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an object with multiple components.  <a href="classTensor_3_01X_00_01Symm_00_01IndexList_3_01Indices_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4e16b80d37cb8a3e7c8ab95e72ab8724"><td class="memTemplParams" colspan="2">template&lt;typename CheckFrame &gt; </td></tr>
<tr class="memitem:ga4e16b80d37cb8a3e7c8ab95e72ab8724"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga4e16b80d37cb8a3e7c8ab95e72ab8724">Frame::is_frame_physical</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; bool, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_base_of.html">std::is_base_of</a>&lt; <a class="el" href="structFrame_1_1FrameIsPhysical.html">FrameIsPhysical</a>, CheckFrame &gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a> &gt;</td></tr>
<tr class="memdesc:ga4e16b80d37cb8a3e7c8ab95e72ab8724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a> if the frame is "physical" in the sense that it is meaningful to evaluate an analytic solution in that frame.  <a href="group__TensorGroup.html#ga4e16b80d37cb8a3e7c8ab95e72ab8724">More...</a><br /></td></tr>
<tr class="separator:ga4e16b80d37cb8a3e7c8ab95e72ab8724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga557beda9bce6c7f236213ec8b24b3ff3"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, UpLo Ul, typename Fr &gt; </td></tr>
<tr class="memitem:ga557beda9bce6c7f236213ec8b24b3ff3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a> = Tensor_detail::TensorIndexType&lt; SpatialDim, Ul, Fr, <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> &gt;</td></tr>
<tr class="memdesc:ga557beda9bce6c7f236213ec8b24b3ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SpatialIndex holds information about the number of spatial dimensions, whether the index is covariant or contravariant (<a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28" title="Whether a TensorIndexType is covariant or contravariant.">UpLo</a>), and the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> the index is in.  <a href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">More...</a><br /></td></tr>
<tr class="separator:ga557beda9bce6c7f236213ec8b24b3ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05c512b755e913cdbddce8634bdb4fa6"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, UpLo Ul, typename Fr &gt; </td></tr>
<tr class="memitem:ga05c512b755e913cdbddce8634bdb4fa6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">SpacetimeIndex</a> = Tensor_detail::TensorIndexType&lt; SpatialDim, Ul, Fr, <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e">IndexType::Spacetime</a> &gt;</td></tr>
<tr class="memdesc:ga05c512b755e913cdbddce8634bdb4fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SpacetimeIndex holds information about the number of spatial dimensions, whether the index is covariant or contravariant (<a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28" title="Whether a TensorIndexType is covariant or contravariant.">UpLo</a>), and the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> the index is in.  <a href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">More...</a><br /></td></tr>
<tr class="separator:ga05c512b755e913cdbddce8634bdb4fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb33fd857700a3fc87b9dce8c877fee7"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:gacb33fd857700a3fc87b9dce8c877fee7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a> = Tensor_detail::TensorIndexType&lt; Index::index_type==<a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> ? <a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">Index::value</a> :<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">Index::value</a> - 1, Index::ul==<a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a> ? <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a> :<a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a>, typename Index::Frame, Index::index_type &gt;</td></tr>
<tr class="memdesc:gacb33fd857700a3fc87b9dce8c877fee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> to be covariant if it's contravariant and vice-versa.  <a href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">More...</a><br /></td></tr>
<tr class="separator:gacb33fd857700a3fc87b9dce8c877fee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8087fef90d482c58a25934cb9346950"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:gad8087fef90d482c58a25934cb9346950"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gad8087fef90d482c58a25934cb9346950">change_index_type</a> = Tensor_detail::TensorIndexType&lt; Index::index_type==<a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> ? Index::dim :Index::dim - 1, Index::ul, typename Index::Frame, Index::index_type==<a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> ? <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e">IndexType::Spacetime</a> :<a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> &gt;</td></tr>
<tr class="memdesc:gad8087fef90d482c58a25934cb9346950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> to be spacetime if it's spatial and vice versa.  <a href="group__TensorGroup.html#gad8087fef90d482c58a25934cb9346950">More...</a><br /></td></tr>
<tr class="separator:gad8087fef90d482c58a25934cb9346950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f86692d77435c9721e1ab051232407"><td class="memTemplParams" colspan="2"><a id="gaf6f86692d77435c9721e1ab051232407"></a>
template&lt;typename Symm , typename... IndexPack&gt; </td></tr>
<tr class="memitem:gaf6f86692d77435c9721e1ab051232407"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gaf6f86692d77435c9721e1ab051232407">TensorMetafunctions::check_index_symmetry</a> = typename detail::check_index_symmetry_impl&lt; tmpl::size&lt; Symm &gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a>==0 or tmpl::size&lt; Symm &gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a>==1 ? 0 :2 &gt;::template f&lt; Symm, tmpl::map&lt;&gt;, IndexPack... &gt;</td></tr>
<tr class="memdesc:gaf6f86692d77435c9721e1ab051232407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that each of symmetric indices is in the same frame and have the same dimensionality. <br /></td></tr>
<tr class="separator:gaf6f86692d77435c9721e1ab051232407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e4aece332518b3a95c2a73557aaa596"><td class="memTemplParams" colspan="2">template&lt;typename Tensor , std::size_t VolumeDim, UpLo Ul, typename Fr  = Frame::Grid&gt; </td></tr>
<tr class="memitem:ga5e4aece332518b3a95c2a73557aaa596"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a> = ::Tensor&lt; typename Tensor::type, tmpl::push_front&lt; typename Tensor::symmetry, tmpl::int32_t&lt; 1+tmpl::fold&lt; typename Tensor::symmetry, tmpl::int32_t&lt; 0 &gt;, tmpl::max&lt; tmpl::_state, tmpl::_element &gt; &gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a> &gt; &gt;, tmpl::push_front&lt; typename Tensor::index_list, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; VolumeDim, Ul, Fr &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ga5e4aece332518b3a95c2a73557aaa596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a spatial index to the front of a Tensor.  <a href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">More...</a><br /></td></tr>
<tr class="separator:ga5e4aece332518b3a95c2a73557aaa596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef68ec7e4373c578d0a5885df8ac89fa"><td class="memTemplParams" colspan="2">template&lt;typename Tensor , std::size_t VolumeDim, UpLo Ul, typename Fr  = Frame::Grid&gt; </td></tr>
<tr class="memitem:gaef68ec7e4373c578d0a5885df8ac89fa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gaef68ec7e4373c578d0a5885df8ac89fa">TensorMetafunctions::prepend_spacetime_index</a> = ::Tensor&lt; typename Tensor::type, tmpl::push_front&lt; typename Tensor::symmetry, tmpl::int32_t&lt; 1+tmpl::fold&lt; typename Tensor::symmetry, tmpl::int32_t&lt; 0 &gt;, tmpl::max&lt; tmpl::_state, tmpl::_element &gt; &gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a> &gt; &gt;, tmpl::push_front&lt; typename Tensor::index_list, <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">SpacetimeIndex</a>&lt; VolumeDim, Ul, Fr &gt; &gt;&gt;</td></tr>
<tr class="memdesc:gaef68ec7e4373c578d0a5885df8ac89fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a spacetime index to the front of a Tensor.  <a href="group__TensorGroup.html#gaef68ec7e4373c578d0a5885df8ac89fa">More...</a><br /></td></tr>
<tr class="separator:gaef68ec7e4373c578d0a5885df8ac89fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga897a0492a08b8d3493fe552796c1cf02"><td class="memTemplParams" colspan="2">template&lt;typename Tensor &gt; </td></tr>
<tr class="memitem:ga897a0492a08b8d3493fe552796c1cf02"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga897a0492a08b8d3493fe552796c1cf02">TensorMetafunctions::remove_first_index</a> = ::Tensor&lt; typename Tensor::type, tmpl::pop_front&lt; typename Tensor::symmetry &gt;, tmpl::pop_front&lt; typename Tensor::index_list &gt; &gt;</td></tr>
<tr class="memdesc:ga897a0492a08b8d3493fe552796c1cf02"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the first index of a tensor  <a href="group__TensorGroup.html#ga897a0492a08b8d3493fe552796c1cf02">More...</a><br /></td></tr>
<tr class="separator:ga897a0492a08b8d3493fe552796c1cf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25fd6050b5c828f90dd353a44dbd8c1e"><td class="memTemplParams" colspan="2">template&lt;typename NewType , typename Tensor &gt; </td></tr>
<tr class="memitem:ga25fd6050b5c828f90dd353a44dbd8c1e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga25fd6050b5c828f90dd353a44dbd8c1e">TensorMetafunctions::swap_type</a> = ::Tensor&lt; NewType, typename Tensor::symmetry, typename Tensor::index_list &gt;</td></tr>
<tr class="memdesc:ga25fd6050b5c828f90dd353a44dbd8c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the data type of a tensor for a new type.  <a href="group__TensorGroup.html#ga25fd6050b5c828f90dd353a44dbd8c1e">More...</a><br /></td></tr>
<tr class="separator:ga25fd6050b5c828f90dd353a44dbd8c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeb947b3b07da1aaad0ba7aa3c6b7709"><td class="memTemplParams" colspan="2"><a id="gadeb947b3b07da1aaad0ba7aa3c6b7709"></a>
template&lt;typename Tensor , typename Frame &gt; </td></tr>
<tr class="memitem:gadeb947b3b07da1aaad0ba7aa3c6b7709"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gadeb947b3b07da1aaad0ba7aa3c6b7709">TensorMetafunctions::any_index_in_frame</a> = tmpl::any&lt; typename Tensor::index_list, tmpl::bind&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">detail::frame_is_the_same</a>, tmpl::_1, Frame &gt; &gt;</td></tr>
<tr class="memdesc:gadeb947b3b07da1aaad0ba7aa3c6b7709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return tmpl::true_type if any indices of the Tensor are in the frame <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a>. <br /></td></tr>
<tr class="separator:gadeb947b3b07da1aaad0ba7aa3c6b7709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b376e9167e178638a1adece2ab22ec9"><td class="memTemplParams" colspan="2">template&lt;std::int32_t... T&gt; </td></tr>
<tr class="memitem:ga3b376e9167e178638a1adece2ab22ec9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a> = typename detail::SymmetryImpl&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt; sizeof...(T)&gt;, tmpl::integral_list&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, T... &gt; &gt;::type</td></tr>
<tr class="memdesc:ga3b376e9167e178638a1adece2ab22ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the canonical symmetry from the integers <code>T</code>  <a href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">More...</a><br /></td></tr>
<tr class="separator:ga3b376e9167e178638a1adece2ab22ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06ebcb38a1f13c246e53378b9e8959ce"><td class="memTemplParams" colspan="2"><a id="ga06ebcb38a1f13c246e53378b9e8959ce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga06ebcb38a1f13c246e53378b9e8959ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a> = Tensor&lt; T, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt;&gt;, index_list&lt;&gt; &gt;</td></tr>
<tr class="memdesc:ga06ebcb38a1f13c246e53378b9e8959ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar type. <br /></td></tr>
<tr class="separator:ga06ebcb38a1f13c246e53378b9e8959ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaab1181edf2ab2b664b0f174223f08c28"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a> { <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">Up</a>
, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">Lo</a>
 }</td></tr>
<tr class="memdesc:gaab1181edf2ab2b664b0f174223f08c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> is covariant or contravariant.  <a href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">More...</a><br /></td></tr>
<tr class="separator:gaab1181edf2ab2b664b0f174223f08c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga875b107b929ff008a27078792ac0bc8e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga875b107b929ff008a27078792ac0bc8e">IndexType</a> : char { <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">Spatial</a>
, <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e">Spacetime</a>
 }</td></tr>
<tr class="memdesc:ga875b107b929ff008a27078792ac0bc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> is Spatial or Spacetime.  <a href="group__TensorGroup.html#ga875b107b929ff008a27078792ac0bc8e">More...</a><br /></td></tr>
<tr class="separator:ga875b107b929ff008a27078792ac0bc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa190e39410d6437c431b86da022f3176"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index &gt; </td></tr>
<tr class="memitem:gaa190e39410d6437c431b86da022f3176"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gaa190e39410d6437c431b86da022f3176">cross_product</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_b)</td></tr>
<tr class="memdesc:gaa190e39410d6437c431b86da022f3176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean cross product of two vectors or one forms.  <a href="group__TensorGroup.html#gaa190e39410d6437c431b86da022f3176">More...</a><br /></td></tr>
<tr class="separator:gaa190e39410d6437c431b86da022f3176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c97124e8533af3aa391a5a8925d1cf"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index &gt; </td></tr>
<tr class="memitem:ga21c97124e8533af3aa391a5a8925d1cf"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga21c97124e8533af3aa391a5a8925d1cf">cross_product</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;vector_b)</td></tr>
<tr class="memdesc:ga21c97124e8533af3aa391a5a8925d1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean cross product of a vector and a one form.  <a href="group__TensorGroup.html#ga21c97124e8533af3aa391a5a8925d1cf">More...</a><br /></td></tr>
<tr class="separator:ga21c97124e8533af3aa391a5a8925d1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4f11af0c52bc404fc28fa21c08ee632"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index &gt; </td></tr>
<tr class="memitem:gac4f11af0c52bc404fc28fa21c08ee632"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gac4f11af0c52bc404fc28fa21c08ee632">cross_product</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_b, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a>, <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;metric_or_inverse_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;metric_determinant)</td></tr>
<tr class="memdesc:gac4f11af0c52bc404fc28fa21c08ee632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cross product of two vectors or one forms.  <a href="group__TensorGroup.html#gac4f11af0c52bc404fc28fa21c08ee632">More...</a><br /></td></tr>
<tr class="separator:gac4f11af0c52bc404fc28fa21c08ee632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b1f838df16fba2a848a01b1508d5be"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index &gt; </td></tr>
<tr class="memitem:gaf9b1f838df16fba2a848a01b1508d5be"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gaf9b1f838df16fba2a848a01b1508d5be">cross_product</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;vector_b, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a>, <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;metric_or_inverse_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;metric_determinant)</td></tr>
<tr class="memdesc:gaf9b1f838df16fba2a848a01b1508d5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cross product of a vector and a one form.  <a href="group__TensorGroup.html#gaf9b1f838df16fba2a848a01b1508d5be">More...</a><br /></td></tr>
<tr class="separator:gaf9b1f838df16fba2a848a01b1508d5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d8b65ef0126f9670190c1ae186124a3"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Symm , typename IndexList &gt; </td></tr>
<tr class="memitem:ga3d8b65ef0126f9670190c1ae186124a3"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga3d8b65ef0126f9670190c1ae186124a3">l2_norm</a> (const Tensor&lt; DataType, Symm, IndexList &gt; &amp;tensor)</td></tr>
<tr class="memdesc:ga3d8b65ef0126f9670190c1ae186124a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Euclidean \(L^2\)-norm of arbitrary Tensors reduced over an element.  <a href="group__TensorGroup.html#ga3d8b65ef0126f9670190c1ae186124a3">More...</a><br /></td></tr>
<tr class="separator:ga3d8b65ef0126f9670190c1ae186124a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15e779530e94ad35ef2386f17e5f50be"><td class="memTemplParams" colspan="2"><a id="ga15e779530e94ad35ef2386f17e5f50be"></a>
template&lt;size_t Dim, typename DataType &gt; </td></tr>
<tr class="memitem:ga15e779530e94ad35ef2386f17e5f50be"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; DataType, Dim, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga15e779530e94ad35ef2386f17e5f50be">identity</a> (const DataType &amp;used_for_type)</td></tr>
<tr class="memdesc:ga15e779530e94ad35ef2386f17e5f50be"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Identity matrix <br /></td></tr>
<tr class="separator:ga15e779530e94ad35ef2386f17e5f50be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b9b1bf910598514cbeb78445c1c4dcc"><td class="memTemplParams" colspan="2">template&lt;typename Fr &gt; </td></tr>
<tr class="memitem:ga1b9b1bf910598514cbeb78445c1c4dcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga1b9b1bf910598514cbeb78445c1c4dcc">Frame::prefix</a> ()</td></tr>
<tr class="memdesc:ga1b9b1bf910598514cbeb78445c1c4dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The frame-dependent prefix used when constructing the string returned by the name function of a tag.  <a href="group__TensorGroup.html#ga1b9b1bf910598514cbeb78445c1c4dcc">More...</a><br /></td></tr>
<tr class="separator:ga1b9b1bf910598514cbeb78445c1c4dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5daee96d09341749beb47cfa8046baf"><td class="memTemplParams" colspan="2">template&lt;int I, class... Ts&gt; </td></tr>
<tr class="memitem:gad5daee96d09341749beb47cfa8046baf"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gad5daee96d09341749beb47cfa8046baf">index_dim</a> (const Tensor&lt; Ts... &gt; &amp;)</td></tr>
<tr class="memdesc:gad5daee96d09341749beb47cfa8046baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get dimensionality of i'th tensor index.  <a href="group__TensorGroup.html#gad5daee96d09341749beb47cfa8046baf">More...</a><br /></td></tr>
<tr class="separator:gad5daee96d09341749beb47cfa8046baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga36bbeb0ee2084a06f7d950201cdc0d79"><td class="memTemplParams" colspan="2">template&lt;typename CheckFrame &gt; </td></tr>
<tr class="memitem:ga36bbeb0ee2084a06f7d950201cdc0d79"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga36bbeb0ee2084a06f7d950201cdc0d79">Frame::is_frame_physical_v</a> = <a class="el" href="group__TensorGroup.html#ga4e16b80d37cb8a3e7c8ab95e72ab8724">is_frame_physical</a>&lt;CheckFrame&gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a></td></tr>
<tr class="memdesc:ga36bbeb0ee2084a06f7d950201cdc0d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the frame is "physical" in the sense that it is meaningful to evaluate an analytic solution in that frame.  <a href="group__TensorGroup.html#ga36bbeb0ee2084a06f7d950201cdc0d79">More...</a><br /></td></tr>
<tr class="separator:ga36bbeb0ee2084a06f7d950201cdc0d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ee24c7a8f513fbd7f4a7975922378e1"><td class="memTemplParams" colspan="2"><a id="ga6ee24c7a8f513fbd7f4a7975922378e1"></a>
template&lt;typename Tensor , typename Frame &gt; </td></tr>
<tr class="memitem:ga6ee24c7a8f513fbd7f4a7975922378e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga6ee24c7a8f513fbd7f4a7975922378e1">TensorMetafunctions::any_index_in_frame_v</a> = <a class="el" href="group__TensorGroup.html#gadeb947b3b07da1aaad0ba7aa3c6b7709">any_index_in_frame</a>&lt;Tensor, Frame&gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a></td></tr>
<tr class="memdesc:ga6ee24c7a8f513fbd7f4a7975922378e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any indices of the Tensor are in the frame <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a>. <br /></td></tr>
<tr class="separator:ga6ee24c7a8f513fbd7f4a7975922378e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga285b526317403b6d4a277616064ba7d1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:ga285b526317403b6d4a277616064ba7d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga285b526317403b6d4a277616064ba7d1">determinant</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; T &gt; * &gt; det_tensor, const Tensor&lt; T, Symm, index_list&lt; Index0, Index1 &gt;&gt; &amp;tensor)</td></tr>
<tr class="memdesc:ga285b526317403b6d4a277616064ba7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant of a rank-2 Tensor <code>tensor</code>.  <a href="group__TensorGroup.html#ga285b526317403b6d4a277616064ba7d1">More...</a><br /></td></tr>
<tr class="separator:ga285b526317403b6d4a277616064ba7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab08ada564d99ea087019620d2276ec50"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:gab08ada564d99ea087019620d2276ec50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gab08ada564d99ea087019620d2276ec50">determinant</a> (const Tensor&lt; T, Symm, index_list&lt; Index0, Index1 &gt;&gt; &amp;tensor)</td></tr>
<tr class="memdesc:gab08ada564d99ea087019620d2276ec50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant of a rank-2 Tensor <code>tensor</code>.  <a href="group__TensorGroup.html#gab08ada564d99ea087019620d2276ec50">More...</a><br /></td></tr>
<tr class="separator:gab08ada564d99ea087019620d2276ec50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0447022c462339702764a8ea823ba380"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:ga0447022c462339702764a8ea823ba380"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga0447022c462339702764a8ea823ba380">determinant_and_inverse</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; T &gt; * &gt; det, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; T, Symm, tmpl::list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index1 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; * &gt; inv, const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt;&gt; &amp;tensor)</td></tr>
<tr class="memdesc:ga0447022c462339702764a8ea823ba380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant and inverse of a rank-2 Tensor.  <a href="group__TensorGroup.html#ga0447022c462339702764a8ea823ba380">More...</a><br /></td></tr>
<tr class="separator:ga0447022c462339702764a8ea823ba380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0aefb84272a09e65fda4ceb81d36329"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:gaa0aefb84272a09e65fda4ceb81d36329"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gaa0aefb84272a09e65fda4ceb81d36329">determinant_and_inverse</a> (const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt;&gt; &amp;tensor) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; T &gt;, Tensor&lt; T, Symm, tmpl::list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index1 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt;&gt;</td></tr>
<tr class="memdesc:gaa0aefb84272a09e65fda4ceb81d36329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant and inverse of a rank-2 Tensor.  <a href="group__TensorGroup.html#gaa0aefb84272a09e65fda4ceb81d36329">More...</a><br /></td></tr>
<tr class="separator:gaa0aefb84272a09e65fda4ceb81d36329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc70d749c2d92aeeb243b71bfb0d0034"><td class="memTemplParams" colspan="2">template&lt;typename DetTag , typename InvTag , typename T , typename Symm , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:gadc70d749c2d92aeeb243b71bfb0d0034"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gadc70d749c2d92aeeb243b71bfb0d0034">determinant_and_inverse</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; tmpl::list&lt; DetTag, InvTag &gt;&gt; * &gt; det_and_inv, const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt;&gt; &amp;tensor)</td></tr>
<tr class="memdesc:gadc70d749c2d92aeeb243b71bfb0d0034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant and inverse of a rank-2 Tensor.  <a href="group__TensorGroup.html#gadc70d749c2d92aeeb243b71bfb0d0034">More...</a><br /></td></tr>
<tr class="separator:gadc70d749c2d92aeeb243b71bfb0d0034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga881164fc607d247c332312bdb33906b8"><td class="memTemplParams" colspan="2">template&lt;typename DetTag , typename InvTag , typename T , typename Symm , typename Index0 , typename Index1 &gt; </td></tr>
<tr class="memitem:ga881164fc607d247c332312bdb33906b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga881164fc607d247c332312bdb33906b8">determinant_and_inverse</a> (const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt;&gt; &amp;tensor) -&gt; Variables&lt; tmpl::list&lt; DetTag, InvTag &gt;&gt;</td></tr>
<tr class="memdesc:ga881164fc607d247c332312bdb33906b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant and inverse of a rank-2 Tensor.  <a href="group__TensorGroup.html#ga881164fc607d247c332312bdb33906b8">More...</a><br /></td></tr>
<tr class="separator:ga881164fc607d247c332312bdb33906b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8932a63395442db2ec51568a459c126f"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index &gt; </td></tr>
<tr class="memitem:ga8932a63395442db2ec51568a459c126f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga8932a63395442db2ec51568a459c126f">dot_product</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; dot_product, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_b)</td></tr>
<tr class="memdesc:ga8932a63395442db2ec51568a459c126f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean dot product of two vectors or one forms.  <a href="group__TensorGroup.html#ga8932a63395442db2ec51568a459c126f">More...</a><br /></td></tr>
<tr class="separator:ga8932a63395442db2ec51568a459c126f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad91158112d44a5031ab46e7fed474c86"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index &gt; </td></tr>
<tr class="memitem:gad91158112d44a5031ab46e7fed474c86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gad91158112d44a5031ab46e7fed474c86">dot_product</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_b)</td></tr>
<tr class="memdesc:gad91158112d44a5031ab46e7fed474c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean dot product of two vectors or one forms.  <a href="group__TensorGroup.html#gad91158112d44a5031ab46e7fed474c86">More...</a><br /></td></tr>
<tr class="separator:gad91158112d44a5031ab46e7fed474c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6a269d2dd336a1e3f9eb71c8944702e"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index &gt; </td></tr>
<tr class="memitem:gab6a269d2dd336a1e3f9eb71c8944702e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gab6a269d2dd336a1e3f9eb71c8944702e">dot_product</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; dot_product, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;vector_b)</td></tr>
<tr class="memdesc:gab6a269d2dd336a1e3f9eb71c8944702e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product of a vector and a one form.  <a href="group__TensorGroup.html#gab6a269d2dd336a1e3f9eb71c8944702e">More...</a><br /></td></tr>
<tr class="separator:gab6a269d2dd336a1e3f9eb71c8944702e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ff3e95f5771de81f6e7fad08c2a53f3"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index &gt; </td></tr>
<tr class="memitem:ga3ff3e95f5771de81f6e7fad08c2a53f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga3ff3e95f5771de81f6e7fad08c2a53f3">dot_product</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;vector_b)</td></tr>
<tr class="memdesc:ga3ff3e95f5771de81f6e7fad08c2a53f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product of a vector and a one form.  <a href="group__TensorGroup.html#ga3ff3e95f5771de81f6e7fad08c2a53f3">More...</a><br /></td></tr>
<tr class="separator:ga3ff3e95f5771de81f6e7fad08c2a53f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0131e30bce481bab0ea231e95a36cc9"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index &gt; </td></tr>
<tr class="memitem:gaf0131e30bce481bab0ea231e95a36cc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gaf0131e30bce481bab0ea231e95a36cc9">dot_product</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; dot_product, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_b, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;metric)</td></tr>
<tr class="memdesc:gaf0131e30bce481bab0ea231e95a36cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot_product of two vectors or one forms.  <a href="group__TensorGroup.html#gaf0131e30bce481bab0ea231e95a36cc9">More...</a><br /></td></tr>
<tr class="separator:gaf0131e30bce481bab0ea231e95a36cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e5e6b2110e35cf43ac3d1c15e968b9e"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index &gt; </td></tr>
<tr class="memitem:ga0e5e6b2110e35cf43ac3d1c15e968b9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga0e5e6b2110e35cf43ac3d1c15e968b9e">dot_product</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_a, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector_b, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;metric)</td></tr>
<tr class="memdesc:ga0e5e6b2110e35cf43ac3d1c15e968b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot_product of two vectors or one forms.  <a href="group__TensorGroup.html#ga0e5e6b2110e35cf43ac3d1c15e968b9e">More...</a><br /></td></tr>
<tr class="separator:ga0e5e6b2110e35cf43ac3d1c15e968b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdf5e1956d7009486d0ee9496f8d0cf4"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index &gt; </td></tr>
<tr class="memitem:gacdf5e1956d7009486d0ee9496f8d0cf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gacdf5e1956d7009486d0ee9496f8d0cf4">magnitude</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector)</td></tr>
<tr class="memdesc:gacdf5e1956d7009486d0ee9496f8d0cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean magnitude of a rank-1 tensor.  <a href="group__TensorGroup.html#gacdf5e1956d7009486d0ee9496f8d0cf4">More...</a><br /></td></tr>
<tr class="separator:gacdf5e1956d7009486d0ee9496f8d0cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga698e2153c0ed83afe66e12cac71090f8"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index &gt; </td></tr>
<tr class="memitem:ga698e2153c0ed83afe66e12cac71090f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga698e2153c0ed83afe66e12cac71090f8">magnitude</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; magnitude, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector)</td></tr>
<tr class="memdesc:ga698e2153c0ed83afe66e12cac71090f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean magnitude of a rank-1 tensor.  <a href="group__TensorGroup.html#ga698e2153c0ed83afe66e12cac71090f8">More...</a><br /></td></tr>
<tr class="separator:ga698e2153c0ed83afe66e12cac71090f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a33ac39c1666379149389950d66093"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index &gt; </td></tr>
<tr class="memitem:ga44a33ac39c1666379149389950d66093"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga44a33ac39c1666379149389950d66093">magnitude</a> (const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;metric)</td></tr>
<tr class="memdesc:ga44a33ac39c1666379149389950d66093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the magnitude of a rank-1 tensor.  <a href="group__TensorGroup.html#ga44a33ac39c1666379149389950d66093">More...</a><br /></td></tr>
<tr class="separator:ga44a33ac39c1666379149389950d66093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8fc180f1edab1ca2199bd57cfa79131"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Index &gt; </td></tr>
<tr class="memitem:gab8fc180f1edab1ca2199bd57cfa79131"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#gab8fc180f1edab1ca2199bd57cfa79131">magnitude</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; magnitude, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;vector, const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;metric)</td></tr>
<tr class="memdesc:gab8fc180f1edab1ca2199bd57cfa79131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the magnitude of a rank-1 tensor.  <a href="group__TensorGroup.html#gab8fc180f1edab1ca2199bd57cfa79131">More...</a><br /></td></tr>
<tr class="separator:gab8fc180f1edab1ca2199bd57cfa79131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e49f65b2dd16062d894325fe9e8c7fe"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:ga6e49f65b2dd16062d894325fe9e8c7fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga6e49f65b2dd16062d894325fe9e8c7fe">sqrt_magnitude</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;input)</td></tr>
<tr class="memdesc:ga6e49f65b2dd16062d894325fe9e8c7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute square root of the Euclidean magnitude of a rank-0 tensor.  <a href="group__TensorGroup.html#ga6e49f65b2dd16062d894325fe9e8c7fe">More...</a><br /></td></tr>
<tr class="separator:ga6e49f65b2dd16062d894325fe9e8c7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e419ac058b5a7fd034c6f27ab1461c"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:ga34e419ac058b5a7fd034c6f27ab1461c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga34e419ac058b5a7fd034c6f27ab1461c">sqrt_magnitude</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; sqrt_magnitude, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;input)</td></tr>
<tr class="memdesc:ga34e419ac058b5a7fd034c6f27ab1461c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute square root of the Euclidean magnitude of a rank-0 tensor.  <a href="group__TensorGroup.html#ga34e419ac058b5a7fd034c6f27ab1461c">More...</a><br /></td></tr>
<tr class="separator:ga34e419ac058b5a7fd034c6f27ab1461c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d141295962bfce84c1acbc1822a461e"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Symm , typename IndexList &gt; </td></tr>
<tr class="memitem:ga5d141295962bfce84c1acbc1822a461e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga5d141295962bfce84c1acbc1822a461e">pointwise_l2_norm</a> (const Tensor&lt; DataType, Symm, IndexList &gt; &amp;tensor)</td></tr>
<tr class="memdesc:ga5d141295962bfce84c1acbc1822a461e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute point-wise Euclidean \(L^2\)-norm of arbitrary Tensors.  <a href="group__TensorGroup.html#ga5d141295962bfce84c1acbc1822a461e">More...</a><br /></td></tr>
<tr class="separator:ga5d141295962bfce84c1acbc1822a461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb473fcc3adf0e77383c8a3cce60d53"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Symm , typename IndexList &gt; </td></tr>
<tr class="memitem:ga5cb473fcc3adf0e77383c8a3cce60d53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga5cb473fcc3adf0e77383c8a3cce60d53">pointwise_l2_norm</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt; norm, const Tensor&lt; DataType, Symm, IndexList &gt; &amp;tensor)</td></tr>
<tr class="memdesc:ga5cb473fcc3adf0e77383c8a3cce60d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute point-wise Euclidean \(L^2\)-norm of arbitrary Tensors.  <a href="group__TensorGroup.html#ga5cb473fcc3adf0e77383c8a3cce60d53">More...</a><br /></td></tr>
<tr class="separator:ga5cb473fcc3adf0e77383c8a3cce60d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga575809a99dff3c2a104360a1e4d9200b"><td class="memTemplParams" colspan="2">template&lt;typename DataType , size_t VolumeDim, typename Frame &gt; </td></tr>
<tr class="memitem:ga575809a99dff3c2a104360a1e4d9200b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga575809a99dff3c2a104360a1e4d9200b">orthonormal_oneform</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; DataType, VolumeDim, Frame &gt; * &gt; orthonormal_form, const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;unit_form, const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;inv_spatial_metric)</td></tr>
<tr class="memdesc:ga575809a99dff3c2a104360a1e4d9200b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a spatial one-form orthonormal to the given unit form.  <a href="group__TensorGroup.html#ga575809a99dff3c2a104360a1e4d9200b">More...</a><br /></td></tr>
<tr class="separator:ga575809a99dff3c2a104360a1e4d9200b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0973cf32fc8ebbbf8010f98c038393e2"><td class="memTemplParams" colspan="2">template&lt;typename DataType , size_t VolumeDim, typename Frame &gt; </td></tr>
<tr class="memitem:ga0973cf32fc8ebbbf8010f98c038393e2"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; DataType, VolumeDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga0973cf32fc8ebbbf8010f98c038393e2">orthonormal_oneform</a> (const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;unit_form, const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;inv_spatial_metric)</td></tr>
<tr class="memdesc:ga0973cf32fc8ebbbf8010f98c038393e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a spatial one-form orthonormal to the given unit form.  <a href="group__TensorGroup.html#ga0973cf32fc8ebbbf8010f98c038393e2">More...</a><br /></td></tr>
<tr class="separator:ga0973cf32fc8ebbbf8010f98c038393e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21685a6a82d5fb9e13e11c88ca403323"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Frame &gt; </td></tr>
<tr class="memitem:ga21685a6a82d5fb9e13e11c88ca403323"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga21685a6a82d5fb9e13e11c88ca403323">orthonormal_oneform</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; DataType, 3, Frame &gt; * &gt; orthonormal_form, const tnsr::i&lt; DataType, 3, Frame &gt; &amp;first_unit_form, const tnsr::i&lt; DataType, 3, Frame &gt; &amp;second_unit_form, const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;spatial_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;det_spatial_metric)</td></tr>
<tr class="memdesc:ga21685a6a82d5fb9e13e11c88ca403323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a spatial one-form orthonormal to two given unit forms.  <a href="group__TensorGroup.html#ga21685a6a82d5fb9e13e11c88ca403323">More...</a><br /></td></tr>
<tr class="separator:ga21685a6a82d5fb9e13e11c88ca403323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e51e84e37505e5b399d894419ff47f1"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename Frame &gt; </td></tr>
<tr class="memitem:ga4e51e84e37505e5b399d894419ff47f1"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; DataType, 3, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorGroup.html#ga4e51e84e37505e5b399d894419ff47f1">orthonormal_oneform</a> (const tnsr::i&lt; DataType, 3, Frame &gt; &amp;first_unit_form, const tnsr::i&lt; DataType, 3, Frame &gt; &amp;second_unit_form, const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;spatial_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;det_spatial_metric)</td></tr>
<tr class="memdesc:ga4e51e84e37505e5b399d894419ff47f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a spatial one-form orthonormal to two given unit forms.  <a href="group__TensorGroup.html#ga4e51e84e37505e5b399d894419ff47f1">More...</a><br /></td></tr>
<tr class="separator:ga4e51e84e37505e5b399d894419ff47f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Tensor use documentation. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad8087fef90d482c58a25934cb9346950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8087fef90d482c58a25934cb9346950">&#9670;&nbsp;</a></span>change_index_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#gad8087fef90d482c58a25934cb9346950">change_index_type</a> =  Tensor_detail::TensorIndexType&lt; Index::index_type == <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> ? Index::dim : Index::dim - 1, Index::ul, typename Index::Frame, Index::index_type == <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> ? <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e">IndexType::Spacetime</a> : <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> to be spacetime if it's spatial and vice versa. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classIndex.html" title="An integer multi-index.">Index</a></td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> to change </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb33fd857700a3fc87b9dce8c877fee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb33fd857700a3fc87b9dce8c877fee7">&#9670;&nbsp;</a></span>change_index_up_lo</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a> =  Tensor_detail::TensorIndexType&lt; Index::index_type == <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a> ? <a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">Index::value</a> : <a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">Index::value</a> - 1, Index::ul == <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a> ? <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a> : <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a>, typename Index::Frame, Index::index_type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> to be covariant if it's contravariant and vice-versa. </p>
<p>Here is an example of how to use <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7" title="Change the TensorIndexType to be covariant if it&#39;s contravariant and vice-versa.">change_index_up_lo</a> </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="classIndex.html">Index</a> = <a class="code" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex&lt;3, UpLo::Lo, Frame::Grid&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> UpIndex = <a class="code" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo&lt;Index&gt;</a>;</div>
<div class="line">static_assert(std::is_same_v&lt;UpIndex, <a class="code" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex&lt;3, UpLo::Up, Frame::Grid&gt;</a>&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing change_index_up_lo&quot;</span>);</div>
<div class="ttc" id="aclassIndex_html"><div class="ttname"><a href="classIndex.html">Index</a></div><div class="ttdoc">An integer multi-index.</div><div class="ttdef"><b>Definition:</b> Index.hpp:31</div></div>
<div class="ttc" id="agroup__TensorGroup_html_ga557beda9bce6c7f236213ec8b24b3ff3"><div class="ttname"><a href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a></div><div class="ttdeci">Tensor_detail::TensorIndexType&lt; SpatialDim, Ul, Fr, IndexType::Spatial &gt; SpatialIndex</div><div class="ttdoc">A SpatialIndex holds information about the number of spatial dimensions, whether the index is covaria...</div><div class="ttdef"><b>Definition:</b> IndexType.hpp:196</div></div>
<div class="ttc" id="agroup__TensorGroup_html_gacb33fd857700a3fc87b9dce8c877fee7"><div class="ttname"><a href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a></div><div class="ttdeci">Tensor_detail::TensorIndexType&lt; Index::index_type==IndexType::Spatial ? Index::value :Index::value - 1, Index::ul==UpLo::Up ? UpLo::Lo :UpLo::Up, typename Index::Frame, Index::index_type &gt; change_index_up_lo</div><div class="ttdoc">Change the TensorIndexType to be covariant if it's contravariant and vice-versa.</div><div class="ttdef"><b>Definition:</b> IndexType.hpp:244</div></div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classIndex.html" title="An integer multi-index.">Index</a></td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> to change </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e16b80d37cb8a3e7c8ab95e72ab8724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e16b80d37cb8a3e7c8ab95e72ab8724">&#9670;&nbsp;</a></span>is_frame_physical</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CheckFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#ga4e16b80d37cb8a3e7c8ab95e72ab8724">Frame::is_frame_physical</a> = typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt;bool, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_base_of.html">std::is_base_of</a>&lt;<a class="el" href="structFrame_1_1FrameIsPhysical.html">FrameIsPhysical</a>, CheckFrame&gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a> if the frame is "physical" in the sense that it is meaningful to evaluate an analytic solution in that frame. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">static_assert(not Frame::is_frame_physical_v&lt;Frame::BlockLogical&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line">static_assert(not Frame::is_frame_physical_v&lt;Frame::ElementLogical&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line">static_assert(not Frame::is_frame_physical_v&lt;Frame::Distorted&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line">static_assert(not Frame::is_frame_physical_v&lt;Frame::Grid&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line">static_assert(Frame::is_frame_physical_v&lt;Frame::Inertial&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaef68ec7e4373c578d0a5885df8ac89fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef68ec7e4373c578d0a5885df8ac89fa">&#9670;&nbsp;</a></span>prepend_spacetime_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tensor , std::size_t VolumeDim, UpLo Ul, typename Fr  = Frame::Grid&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#gaef68ec7e4373c578d0a5885df8ac89fa">TensorMetafunctions::prepend_spacetime_index</a> = typedef ::Tensor&lt; typename Tensor::type, tmpl::push_front&lt; typename Tensor::symmetry, tmpl::int32_t&lt; 1 + tmpl::fold&lt;typename Tensor::symmetry, tmpl::int32_t&lt;0&gt;, tmpl::max&lt;tmpl::_state, tmpl::_element&gt; &gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a>&gt; &gt;, tmpl::push_front&lt;typename Tensor::index_list, <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">SpacetimeIndex</a>&lt;VolumeDim, Ul, Fr&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a spacetime index to the front of a Tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tensor</td><td>the tensor type to which the new index is prepended </td></tr>
    <tr><td class="paramname">VolumeDim</td><td>the volume dimension of the tensor index to prepend </td></tr>
    <tr><td class="paramname">Fr</td><td>the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> of the tensor index to prepend </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e4aece332518b3a95c2a73557aaa596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e4aece332518b3a95c2a73557aaa596">&#9670;&nbsp;</a></span>prepend_spatial_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tensor , std::size_t VolumeDim, UpLo Ul, typename Fr  = Frame::Grid&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#ga5e4aece332518b3a95c2a73557aaa596">TensorMetafunctions::prepend_spatial_index</a> = typedef ::Tensor&lt; typename Tensor::type, tmpl::push_front&lt; typename Tensor::symmetry, tmpl::int32_t&lt; 1 + tmpl::fold&lt;typename Tensor::symmetry, tmpl::int32_t&lt;0&gt;, tmpl::max&lt;tmpl::_state, tmpl::_element&gt; &gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a>&gt; &gt;, tmpl::push_front&lt;typename Tensor::index_list, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt;VolumeDim, Ul, Fr&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a spatial index to the front of a Tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tensor</td><td>the tensor type to which the new index is prepended </td></tr>
    <tr><td class="paramname">VolumeDim</td><td>the volume dimension of the tensor index to prepend </td></tr>
    <tr><td class="paramname">Fr</td><td>the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> of the tensor index to prepend </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga897a0492a08b8d3493fe552796c1cf02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga897a0492a08b8d3493fe552796c1cf02">&#9670;&nbsp;</a></span>remove_first_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tensor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#ga897a0492a08b8d3493fe552796c1cf02">TensorMetafunctions::remove_first_index</a> = typedef ::Tensor&lt;typename Tensor::type, tmpl::pop_front&lt;typename Tensor::symmetry&gt;, tmpl::pop_front&lt;typename Tensor::index_list&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove the first index of a tensor </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tensor</td><td>the tensor type whose first index is removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05c512b755e913cdbddce8634bdb4fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05c512b755e913cdbddce8634bdb4fa6">&#9670;&nbsp;</a></span>SpacetimeIndex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, UpLo Ul, typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">SpacetimeIndex</a> =  Tensor_detail::TensorIndexType&lt;SpatialDim, Ul, Fr, <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e">IndexType::Spacetime</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A SpacetimeIndex holds information about the number of spatial dimensions, whether the index is covariant or contravariant (<a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28" title="Whether a TensorIndexType is covariant or contravariant.">UpLo</a>), and the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> the index is in. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SpatialDim</td><td>the spatial dimensionality of the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> </td></tr>
    <tr><td class="paramname">Ul</td><td>either <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa" title="Contravariant, or Upper index.">UpLo::Up</a> or <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911" title="Covariant, or Lower index.">UpLo::Lo</a> for contra or covariant </td></tr>
    <tr><td class="paramname">Fr</td><td>the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> is in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga557beda9bce6c7f236213ec8b24b3ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga557beda9bce6c7f236213ec8b24b3ff3">&#9670;&nbsp;</a></span>SpatialIndex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, UpLo Ul, typename Fr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a> =  Tensor_detail::TensorIndexType&lt;SpatialDim, Ul, Fr, <a class="el" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A SpatialIndex holds information about the number of spatial dimensions, whether the index is covariant or contravariant (<a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28" title="Whether a TensorIndexType is covariant or contravariant.">UpLo</a>), and the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> the index is in. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SpatialDim</td><td>the spatial dimensionality of the <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">TensorIndexType</a> </td></tr>
    <tr><td class="paramname">Ul</td><td>either <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa" title="Contravariant, or Upper index.">UpLo::Up</a> or <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911" title="Covariant, or Lower index.">UpLo::Lo</a> for contra or covariant </td></tr>
    <tr><td class="paramname">Fr</td><td>the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> the <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">TensorIndexType</a> is in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga25fd6050b5c828f90dd353a44dbd8c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25fd6050b5c828f90dd353a44dbd8c1e">&#9670;&nbsp;</a></span>swap_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NewType , typename Tensor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#ga25fd6050b5c828f90dd353a44dbd8c1e">TensorMetafunctions::swap_type</a> = typedef ::Tensor&lt;NewType, typename Tensor::symmetry, typename Tensor::index_list&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the data type of a tensor for a new type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NewType</td><td>the new data type </td></tr>
    <tr><td class="paramname">Tensor</td><td>the tensor from which to keep symmetry and index information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b376e9167e178638a1adece2ab22ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b376e9167e178638a1adece2ab22ec9">&#9670;&nbsp;</a></span>Symmetry</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::int32_t... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a> =  typename detail::SymmetryImpl&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt;sizeof...(T)&gt;, tmpl::integral_list&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, T...&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the canonical symmetry from the integers <code>T</code> </p>
<h3>Details</h3>
<p>Compute the canonical symmetry typelist given a set of integers, T. The resulting typelist is in ascending order of the integers, from right to left. For example, the result of <code>Symmetry&lt;1, 2, 1, 3&gt;</code> is <code>integral_list&lt;int32_t, 2, 3, 2, 1&gt;</code>. Anti-symmetries are not currently supported.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the integers denoting the symmetry of the Tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga875b107b929ff008a27078792ac0bc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga875b107b929ff008a27078792ac0bc8e">&#9670;&nbsp;</a></span>IndexType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__TensorGroup.html#ga875b107b929ff008a27078792ac0bc8e">IndexType</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> is Spatial or Spacetime. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504"></a>Spatial&#160;</td><td class="fielddoc"><p>The <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">TensorIndexType</a> is purely spatial. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e"></a>Spacetime&#160;</td><td class="fielddoc"><p>The <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> is a spacetime index. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaab1181edf2ab2b664b0f174223f08c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab1181edf2ab2b664b0f174223f08c28">&#9670;&nbsp;</a></span>UpLo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__TensorGroup.html#gaab1181edf2ab2b664b0f174223f08c28">UpLo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> is covariant or contravariant. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa"></a>Up&#160;</td><td class="fielddoc"><p>Contravariant, or Upper index. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911"></a>Lo&#160;</td><td class="fielddoc"><p>Covariant, or Lower index. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga21c97124e8533af3aa391a5a8925d1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21c97124e8533af3aa391a5a8925d1cf">&#9670;&nbsp;</a></span>cross_product() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt;1&gt;, index_list&lt;<a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt;<a class="el" href="classIndex.html">Index</a>&gt; &gt; &gt; cross_product </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euclidean cross product of a vector and a one form. </p>
<h3>Details</h3>
<p>Returns \(A^j B_l \delta^{lk} \epsilon_{ijk}\) for input vector \(A^j\) and input one form \(B_l\) or \(A_j B^l \delta_{lk} \epsilon^{ijk}\) for input one form \(A_j\) and input vector \(B^l\). Note that this function returns a vector if <code>vector_b</code> is a vector and a one form if <code>vector_b</code> is a one form. </p>

</div>
</div>
<a id="gaf9b1f838df16fba2a848a01b1508d5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9b1f838df16fba2a848a01b1508d5be">&#9670;&nbsp;</a></span>cross_product() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt;1&gt;, index_list&lt;<a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt;<a class="el" href="classIndex.html">Index</a>&gt; &gt; &gt; cross_product </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a>, <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric_or_inverse_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric_determinant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the cross product of a vector and a one form. </p>
<h3>Details</h3>
<p>Returns \(\sqrt{g} A^j B_l g^{lk} \epsilon_{ijk}\) for input vector \(A^j\) and input one form \(B_l\). In this case, the argument <code>vector_a</code> should be a vector, <code>vector_b</code> should be a one form, <code>metric_or_inverse_metric</code> should be the inverse spatial metric \(g^{ij}\), and <code>metric_determinant</code> should be the determinant of the spatial metric \(\det(g_{ij})\). Or, returns \(\sqrt{g}^{-1} A_j B^l g_{lk} \epsilon^{ijk}\) for input one form \(A_j\) and input vector \(B^l\). In this case, the argument <code>vector_a</code> should be a one form, <code>vector_b</code> should be a vector, <code>metric_or_inverse_metric</code> should be the spatial metric \(g_{ij}\), and <code>metric_determinant</code> should be the determinant of the spatial metric \(\det(g_{ij})\). Note that this function returns a vector if <code>vector_b</code> is a vector and a one form if <code>vector_b</code> is a one form. </p>

</div>
</div>
<a id="gaa190e39410d6437c431b86da022f3176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa190e39410d6437c431b86da022f3176">&#9670;&nbsp;</a></span>cross_product() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt;1&gt;, index_list&lt;<a class="el" href="classIndex.html">Index</a>&gt; &gt; cross_product </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euclidean cross product of two vectors or one forms. </p>
<h3>Details</h3>
<p>Returns \(A^j B^k \epsilon_{ljk} \delta^{il}\) for input vectors \(A^j\) and \(B^k\) or \(A_j B_k \epsilon^{ljk} \delta_{il}\) for input one forms \(A_j\) and \(B_k\). </p>

</div>
</div>
<a id="gac4f11af0c52bc404fc28fa21c08ee632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4f11af0c52bc404fc28fa21c08ee632">&#9670;&nbsp;</a></span>cross_product() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt;1&gt;, index_list&lt;<a class="el" href="classIndex.html">Index</a>&gt; &gt; cross_product </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a>, <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric_or_inverse_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric_determinant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the cross product of two vectors or one forms. </p>
<h3>Details</h3>
<p>Returns \(\sqrt{g} g^{li} A^j B^k \epsilon_{ljk}\), where \(A^j\) and \(B^k\) are vectors and \(g^{li}\) and \(g\) are the inverse and determinant, respectively, of the spatial metric (computed via <code>determinant_and_inverse</code>). In this case, the arguments <code>vector_a</code> and <code>vector_b</code> should be vectors, the argument <code>metric_or_inverse_metric</code> should be the inverse spatial metric \(g^{ij}\), and the argument <code>metric_determinant</code> should be the determinant of the spatial metric \(\det(g_{ij})\). Or, returns \(\sqrt{g}^{-1} g_{li} A_j B_k \epsilon^{ljk}\), where \(A_j\) and \(B_k\) are one forms and \(g_{li}\) and \(g\) are the spatial metric and its determinant. In this case, the arguments <code>vector_a</code> and <code>vector_b</code> should be one forms, the argument <code>metric_or_inverse_metric</code> should be the spatial metric \(g_{ij}\), and the argument <code>metric_determinant</code> should be the determinant of the spatial metric \(\det(g_{ij})\). </p>

</div>
</div>
<a id="ga285b526317403b6d4a277616064ba7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga285b526317403b6d4a277616064ba7d1">&#9670;&nbsp;</a></span>determinant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; T &gt; * &gt;&#160;</td>
          <td class="paramname"><em>det_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T, Symm, index_list&lt; Index0, Index1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant of a rank-2 Tensor <code>tensor</code>. </p>
<p><em>Requires:</em> That <code>tensor</code> be a rank-2 Tensor, with both indices sharing the same dimension and type. </p>

</div>
</div>
<a id="gab08ada564d99ea087019620d2276ec50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab08ada564d99ea087019620d2276ec50">&#9670;&nbsp;</a></span>determinant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;T&gt; determinant </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T, Symm, index_list&lt; Index0, Index1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant of a rank-2 Tensor <code>tensor</code>. </p>
<p><em>Requires:</em> That <code>tensor</code> be a rank-2 Tensor, with both indices sharing the same dimension and type. </p>

</div>
</div>
<a id="ga0447022c462339702764a8ea823ba380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0447022c462339702764a8ea823ba380">&#9670;&nbsp;</a></span>determinant_and_inverse() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void determinant_and_inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; T &gt; * &gt;&#160;</td>
          <td class="paramname"><em>det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; T, Symm, tmpl::list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index1 &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; Index0 &gt;&gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant and inverse of a rank-2 Tensor. </p>
<p>Computes the determinant and inverse together, because this leads to fewer operations compared to computing the determinant independently.</p>
<h3>Details</h3>
<p>Treats the input rank-2 tensor as a matrix. The first (second) index of the tensor corresponds to the rows (columns) of the matrix. The determinant is a scalar tensor. The inverse is a rank-2 tensor whose indices are reversed and of opposite valence relative to the input tensor, i.e. given \(T_a^b\) returns \((Tinv)_b^a\).</p>
<dl class="section note"><dt>Note</dt><dd>When inverting a 4x4 spacetime metric, it is typically more efficient to use the 3+1 decomposition of the 4-metric in terms of lapse, shift, and spatial 3-metric, in which only the spatial 3-metric needs to be inverted. </dd></dl>

</div>
</div>
<a id="gadc70d749c2d92aeeb243b71bfb0d0034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc70d749c2d92aeeb243b71bfb0d0034">&#9670;&nbsp;</a></span>determinant_and_inverse() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DetTag , typename InvTag , typename T , typename Symm , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void determinant_and_inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; tmpl::list&lt; DetTag, InvTag &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>det_and_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant and inverse of a rank-2 Tensor. </p>
<p>Computes the determinant and inverse together, because this leads to fewer operations compared to computing the determinant independently.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DetTag</td><td>the Tag for the determinant of input Tensor. </td></tr>
    <tr><td class="paramname">InvTag</td><td>the Tag for the inverse of input Tensor.</td></tr>
  </table>
  </dd>
</dl>
<h3>Details</h3>
<p>See <a class="el" href="group__TensorGroup.html#ga0447022c462339702764a8ea823ba380" title="Computes the determinant and inverse of a rank-2 Tensor.">determinant_and_inverse()</a>. </p>

</div>
</div>
<a id="gaa0aefb84272a09e65fda4ceb81d36329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0aefb84272a09e65fda4ceb81d36329">&#9670;&nbsp;</a></span>determinant_and_inverse() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Symm , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto determinant_and_inverse </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td> -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;T&gt;, Tensor&lt;T, Symm,
                                   tmpl::list&lt;<a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt;Index1&gt;,
                                              <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt;Index0&gt;&gt;&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant and inverse of a rank-2 Tensor. </p>
<p>Computes the determinant and inverse together, because this leads to fewer operations compared to computing the determinant independently.</p>
<h3>Details</h3>
<p>Treats the input rank-2 tensor as a matrix. The first (second) index of the tensor corresponds to the rows (columns) of the matrix. The determinant is a scalar tensor. The inverse is a rank-2 tensor whose indices are reversed and of opposite valence relative to the input tensor, i.e. given \(T_a^b\) returns \((Tinv)_b^a\).</p>
<dl class="section note"><dt>Note</dt><dd>When inverting a 4x4 spacetime metric, it is typically more efficient to use the 3+1 decomposition of the 4-metric in terms of lapse, shift, and spatial 3-metric, in which only the spatial 3-metric needs to be inverted. </dd></dl>

</div>
</div>
<a id="ga881164fc607d247c332312bdb33906b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga881164fc607d247c332312bdb33906b8">&#9670;&nbsp;</a></span>determinant_and_inverse() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DetTag , typename InvTag , typename T , typename Symm , typename Index0 , typename Index1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto determinant_and_inverse </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; T, Symm, tmpl::list&lt; Index0, Index1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td> -&gt; Variables&lt;tmpl::list&lt;DetTag, InvTag&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant and inverse of a rank-2 Tensor. </p>
<p>Computes the determinant and inverse together, because this leads to fewer operations compared to computing the determinant independently.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DetTag</td><td>the Tag for the determinant of input Tensor. </td></tr>
    <tr><td class="paramname">InvTag</td><td>the Tag for the inverse of input Tensor.</td></tr>
  </table>
  </dd>
</dl>
<h3>Details</h3>
<p>See <a class="el" href="group__TensorGroup.html#ga0447022c462339702764a8ea823ba380" title="Computes the determinant and inverse of a rank-2 Tensor.">determinant_and_inverse()</a>. </p>

</div>
</div>
<a id="gab6a269d2dd336a1e3f9eb71c8944702e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6a269d2dd336a1e3f9eb71c8944702e">&#9670;&nbsp;</a></span>dot_product() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dot_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dot_product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the dot product of a vector and a one form. </p>
<h3>Details</h3>
<p>Returns \(A^a B_b \delta_{a}^b\) for input vector \(A^a\) and input one form \(B_b\) or \(A_a B^b \delta^a_b\) for input one form \(A_a\) and input vector \(B^b\). </p>

</div>
</div>
<a id="ga8932a63395442db2ec51568a459c126f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8932a63395442db2ec51568a459c126f">&#9670;&nbsp;</a></span>dot_product() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dot_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dot_product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euclidean dot product of two vectors or one forms. </p>
<h3>Details</h3>
<p>Returns \(A^a B^b \delta_{ab}\) for input vectors \(A^a\) and \(B^b\) or \(A_a B_b \delta^{ab}\) for input one forms \(A_a\) and \(B_b\). </p>

</div>
</div>
<a id="gaf0131e30bce481bab0ea231e95a36cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0131e30bce481bab0ea231e95a36cc9">&#9670;&nbsp;</a></span>dot_product() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dot_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dot_product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the dot_product of two vectors or one forms. </p>
<h3>Details</h3>
<p>Returns \(g_{ab} A^a B^b\), where \(g_{ab}\) is the metric, \(A^a\) is vector_a, and \(B^b\) is vector_b. Or, returns \(g^{ab} A_a B_b\) when given one forms \(A_a\) and \(B_b\) with an inverse metric \(g^{ab}\). </p>

</div>
</div>
<a id="ga3ff3e95f5771de81f6e7fad08c2a53f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ff3e95f5771de81f6e7fad08c2a53f3">&#9670;&nbsp;</a></span>dot_product() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; dot_product </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the dot product of a vector and a one form. </p>
<h3>Details</h3>
<p>Returns \(A^a B_b \delta_{a}^b\) for input vector \(A^a\) and input one form \(B_b\) or \(A_a B^b \delta^a_b\) for input one form \(A_a\) and input vector \(B^b\). </p>

</div>
</div>
<a id="gad91158112d44a5031ab46e7fed474c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad91158112d44a5031ab46e7fed474c86">&#9670;&nbsp;</a></span>dot_product() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; dot_product </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euclidean dot product of two vectors or one forms. </p>
<h3>Details</h3>
<p>Returns \(A^a B^b \delta_{ab}\) for input vectors \(A^a\) and \(B^b\) or \(A_a B_b \delta^{ab}\) for input one forms \(A_a\) and \(B_b\). </p>

</div>
</div>
<a id="ga0e5e6b2110e35cf43ac3d1c15e968b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e5e6b2110e35cf43ac3d1c15e968b9e">&#9670;&nbsp;</a></span>dot_product() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; dot_product </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the dot_product of two vectors or one forms. </p>
<h3>Details</h3>
<p>Returns \(g_{ab} A^a B^b\), where \(g_{ab}\) is the metric, \(A^a\) is vector_a, and \(B^b\) is vector_b. Or, returns \(g^{ab} A_a B_b\) when given one forms \(A_a\) and \(B_b\) with an inverse metric \(g^{ab}\). </p>

</div>
</div>
<a id="gad5daee96d09341749beb47cfa8046baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5daee96d09341749beb47cfa8046baf">&#9670;&nbsp;</a></span>index_dim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int I, class... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t index_dim </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get dimensionality of i'th tensor index. </p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> T = Tensor&lt;double, Symmetry&lt;1, 2, 3&gt;,</div>
<div class="line">                     index_list&lt;SpacetimeIndex&lt;2, UpLo::Up, Frame::Inertial&gt;,</div>
<div class="line">                                <a class="code" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex&lt;1, UpLo::Up, Frame::Inertial&gt;</a>,</div>
<div class="line">                                <a class="code" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex&lt;2, UpLo::Up, Frame::Inertial&gt;</a>&gt;&gt;;</div>
<div class="line">    <span class="keyword">const</span> T t{};</div>
<div class="line">    CHECK(index_dim&lt;0&gt;(t) == 3);</div>
<div class="line">    CHECK(index_dim&lt;1&gt;(t) == 1);</div>
<div class="line">    CHECK(index_dim&lt;2&gt;(t) == 2);</div>
<div class="line">    CHECK(<a class="code" href="group__TensorGroup.html#gad5daee96d09341749beb47cfa8046baf">T::index_dim</a>(0) == 3);</div>
<div class="line">    CHECK(<a class="code" href="group__TensorGroup.html#gad5daee96d09341749beb47cfa8046baf">T::index_dim</a>(1) == 1);</div>
<div class="line">    CHECK(<a class="code" href="group__TensorGroup.html#gad5daee96d09341749beb47cfa8046baf">T::index_dim</a>(2) == 2);</div>
<div class="line">    CHECK(T::index_dims() == <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;size_t, 3&gt;</a>{{3, 1, 2}});</div>
<div class="ttc" id="aarray_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt; size_t, 3 &gt;</a></div></div>
<div class="ttc" id="agroup__TensorGroup_html_gad5daee96d09341749beb47cfa8046baf"><div class="ttname"><a href="group__TensorGroup.html#gad5daee96d09341749beb47cfa8046baf">index_dim</a></div><div class="ttdeci">constexpr size_t index_dim(const Tensor&lt; Ts... &gt; &amp;)</div><div class="ttdoc">Get dimensionality of i'th tensor index.</div><div class="ttdef"><b>Definition:</b> Tensor.hpp:562</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3d8b65ef0126f9670190c1ae186124a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d8b65ef0126f9670190c1ae186124a3">&#9670;&nbsp;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Symm , typename IndexList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double l2_norm </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, Symm, IndexList &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Euclidean \(L^2\)-norm of arbitrary Tensors reduced over an element. </p>
<h3>Details</h3>
<p>Computes the RMS value of the point-wise Frobenius norm of a given Tensor with arbitrary rank over all grid points in an element. If the Tensor \(A\) has rank \(n\) and dimensionality \(D\), and the element (of order \(N\)) has \(N+1\) points, then its element-reduced Frobenius norm is computed as:</p>
<p class="formulaDsp">
\begin{equation} ||A||_2 = \left(\frac{1}{N+1}\sum^{N}_{p=0} \left(\sum^{D-1}_{i_1=0}\sum^{D-1}_{i_2=0}\cdots \sum^{D-1}_{i_n=0} |A^p_{i_1 i_2 \cdots i_n}|^2 \right) \right)^{1/2}, \end{equation}
</p>
<p>where both contra-variant and co-variant indices are shown as lower indices, and \(p\) indexes grid points in the element.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function reduces the Frobenius norm over the element, not the whole domain. </dd></dl>

</div>
</div>
<a id="ga698e2153c0ed83afe66e12cac71090f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga698e2153c0ed83afe66e12cac71090f8">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euclidean magnitude of a rank-1 tensor. </p>
<h3>Details</h3>
<p>Computes the square root of the sum of the squares of the components of the rank-1 tensor. </p>

</div>
</div>
<a id="gab8fc180f1edab1ca2199bd57cfa79131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8fc180f1edab1ca2199bd57cfa79131">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the magnitude of a rank-1 tensor. </p>
<h3>Details</h3>
<p>Returns the square root of the input tensor contracted twice with the given metric. </p>

</div>
</div>
<a id="gacdf5e1956d7009486d0ee9496f8d0cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdf5e1956d7009486d0ee9496f8d0cf4">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; magnitude </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euclidean magnitude of a rank-1 tensor. </p>
<h3>Details</h3>
<p>Computes the square root of the sum of the squares of the components of the rank-1 tensor. </p>

</div>
</div>
<a id="ga44a33ac39c1666379149389950d66093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44a33ac39c1666379149389950d66093">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; magnitude </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;, <a class="el" href="group__TensorGroup.html#gacb33fd857700a3fc87b9dce8c877fee7">change_index_up_lo</a>&lt; <a class="el" href="classIndex.html">Index</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the magnitude of a rank-1 tensor. </p>
<h3>Details</h3>
<p>Returns the square root of the input tensor contracted twice with the given metric. </p>

</div>
</div>
<a id="ga4e51e84e37505e5b399d894419ff47f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e51e84e37505e5b399d894419ff47f1">&#9670;&nbsp;</a></span>orthonormal_oneform() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Frame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt;DataType, 3, Frame&gt; orthonormal_oneform </td>
          <td>(</td>
          <td class="paramtype">const tnsr::i&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_unit_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_unit_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>det_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a spatial one-form orthonormal to two given unit forms. </p>
<p>Given a unit spatial one-form \(s_i\) and another form \(t_i\) that is orthonormal to \(s_i\), compute a new form \(u_i\) which is orthonormal to both \(s_i\) and \(t_i\), in the sense that \(\gamma^{ij}s_i u_j = \gamma^{ij}t_i u_j = 0\), for the given inverse spatial metric \(\gamma^{ij}\). The normalization of \(u_i\) is such that \(\gamma^{ij}u_iu_j = 1\).</p>
<h3>Details</h3>
<p>The new form is obtained by taking the covariant cross product of \(s_i\) and \( t_i\), for which the spatial metric as well as its determinant must be provided. </p>

</div>
</div>
<a id="ga0973cf32fc8ebbbf8010f98c038393e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0973cf32fc8ebbbf8010f98c038393e2">&#9670;&nbsp;</a></span>orthonormal_oneform() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , size_t VolumeDim, typename Frame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt;DataType, VolumeDim, Frame&gt; orthonormal_oneform </td>
          <td>(</td>
          <td class="paramtype">const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a spatial one-form orthonormal to the given unit form. </p>
<p>Given a unit spatial one-form \(s_i\), compute a new form \(t_i\) which is orthonormal to \(s_i\), in the sense that \(\gamma^{ij}s_i t_j = 0\), for the given inverse spatial metric \(\gamma^{ij}\). The normalization of \(t_i\) is such that \(\gamma^{ij}t_it_j = 1\).</p>
<h3>Details</h3>
<p>The new form is obtained via Gram-Schmidt process, starting from a form whose components are \(t_i = \delta_i^I\), where \(I\) is the index of the component of \(s_i\) with the smallest absolute value. </p>

</div>
</div>
<a id="ga21685a6a82d5fb9e13e11c88ca403323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21685a6a82d5fb9e13e11c88ca403323">&#9670;&nbsp;</a></span>orthonormal_oneform() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Frame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void orthonormal_oneform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; DataType, 3, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>orthonormal_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_unit_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_unit_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, 3, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>det_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a spatial one-form orthonormal to two given unit forms. </p>
<p>Given a unit spatial one-form \(s_i\) and another form \(t_i\) that is orthonormal to \(s_i\), compute a new form \(u_i\) which is orthonormal to both \(s_i\) and \(t_i\), in the sense that \(\gamma^{ij}s_i u_j = \gamma^{ij}t_i u_j = 0\), for the given inverse spatial metric \(\gamma^{ij}\). The normalization of \(u_i\) is such that \(\gamma^{ij}u_iu_j = 1\).</p>
<h3>Details</h3>
<p>The new form is obtained by taking the covariant cross product of \(s_i\) and \( t_i\), for which the spatial metric as well as its determinant must be provided. </p>

</div>
</div>
<a id="ga575809a99dff3c2a104360a1e4d9200b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga575809a99dff3c2a104360a1e4d9200b">&#9670;&nbsp;</a></span>orthonormal_oneform() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , size_t VolumeDim, typename Frame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void orthonormal_oneform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; DataType, VolumeDim, Frame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>orthonormal_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; DataType, VolumeDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a spatial one-form orthonormal to the given unit form. </p>
<p>Given a unit spatial one-form \(s_i\), compute a new form \(t_i\) which is orthonormal to \(s_i\), in the sense that \(\gamma^{ij}s_i t_j = 0\), for the given inverse spatial metric \(\gamma^{ij}\). The normalization of \(t_i\) is such that \(\gamma^{ij}t_it_j = 1\).</p>
<h3>Details</h3>
<p>The new form is obtained via Gram-Schmidt process, starting from a form whose components are \(t_i = \delta_i^I\), where \(I\) is the index of the component of \(s_i\) with the smallest absolute value. </p>

</div>
</div>
<a id="ga5cb473fcc3adf0e77383c8a3cce60d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cb473fcc3adf0e77383c8a3cce60d53">&#9670;&nbsp;</a></span>pointwise_l2_norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Symm , typename IndexList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pointwise_l2_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; DataType, Symm, IndexList &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute point-wise Euclidean \(L^2\)-norm of arbitrary Tensors. </p>
<h3>Details</h3>
<p>At each grid point \(p\) in the element, this function computes the point-wise Frobenius norm of a given Tensor with arbitrary rank. If the Tensor \(A\) has rank \(n\) and dimensionality \(D\), then its Frobenius norm at point \(p\) is computed as:</p>
<p class="formulaDsp">
\begin{equation} ||A||_2(p) = \left(\sum^{D-1}_{i_1=0}\sum^{D-1}_{i_2=0}\cdots \sum^{D-1}_{i_n=0} |A_{i_1 i_2 \cdots i_n}(p)|^2 \right)^{1/2}, \end{equation}
</p>
<p>where both contra-variant and co-variant indices are shown as lower indices. </p>

</div>
</div>
<a id="ga5d141295962bfce84c1acbc1822a461e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d141295962bfce84c1acbc1822a461e">&#9670;&nbsp;</a></span>pointwise_l2_norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename Symm , typename IndexList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; pointwise_l2_norm </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; DataType, Symm, IndexList &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute point-wise Euclidean \(L^2\)-norm of arbitrary Tensors. </p>
<h3>Details</h3>
<p>At each grid point \(p\) in the element, this function computes the point-wise Frobenius norm of a given Tensor with arbitrary rank. If the Tensor \(A\) has rank \(n\) and dimensionality \(D\), then its Frobenius norm at point \(p\) is computed as:</p>
<p class="formulaDsp">
\begin{equation} ||A||_2(p) = \left(\sum^{D-1}_{i_1=0}\sum^{D-1}_{i_2=0}\cdots \sum^{D-1}_{i_n=0} |A_{i_1 i_2 \cdots i_n}(p)|^2 \right)^{1/2}, \end{equation}
</p>
<p>where both contra-variant and co-variant indices are shown as lower indices. </p>

</div>
</div>
<a id="ga1b9b1bf910598514cbeb78445c1c4dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b9b1bf910598514cbeb78445c1c4dcc">&#9670;&nbsp;</a></span>prefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> Frame::prefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The frame-dependent prefix used when constructing the string returned by the name function of a tag. </p>
<p>For <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> it is the empty string, otherwise, it is the name of the <a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a> followed by an underscore (as the name will be used in I/O). </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  TestHelpers::db::test_simple_tag&lt;</div>
<div class="line">      <a class="code" href="structhydro_1_1Tags_1_1SpatialVelocity.html">hydro::Tags::SpatialVelocity&lt;DataVector, 3, Frame::Grid&gt;</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;Grid_SpatialVelocity&quot;</span>);</div>
<div class="line">  TestHelpers::db::test_simple_tag&lt;<a class="code" href="structhydro_1_1Tags_1_1SpatialVelocityOneForm.html">hydro::Tags::SpatialVelocityOneForm</a>&lt;</div>
<div class="line">      <a class="code" href="classDataVector.html">DataVector</a>, 3, <a class="code" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>&gt;&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;ElementLogical_SpatialVelocityOneForm&quot;</span>);</div>
<div class="ttc" id="aclassDataVector_html"><div class="ttname"><a href="classDataVector.html">DataVector</a></div><div class="ttdoc">Stores a collection of function values.</div><div class="ttdef"><b>Definition:</b> DataVector.hpp:48</div></div>
<div class="ttc" id="astructFrame_1_1ElementLogical_html"><div class="ttname"><a href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a></div><div class="ttdef"><b>Definition:</b> IndexType.hpp:43</div></div>
<div class="ttc" id="astructhydro_1_1Tags_1_1SpatialVelocityOneForm_html"><div class="ttname"><a href="structhydro_1_1Tags_1_1SpatialVelocityOneForm.html">hydro::Tags::SpatialVelocityOneForm</a></div><div class="ttdoc">The spatial velocity one-form , where  is raised and lowered with the spatial metric.</div><div class="ttdef"><b>Definition:</b> Tags.hpp:148</div></div>
<div class="ttc" id="astructhydro_1_1Tags_1_1SpatialVelocity_html"><div class="ttname"><a href="structhydro_1_1Tags_1_1SpatialVelocity.html">hydro::Tags::SpatialVelocity</a></div><div class="ttdoc">The spatial velocity  of the fluid, where . Here  is the spatial part of the 4-velocity of the fluid,...</div><div class="ttdef"><b>Definition:</b> Tags.hpp:140</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga34e419ac058b5a7fd034c6f27ab1461c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34e419ac058b5a7fd034c6f27ab1461c">&#9670;&nbsp;</a></span>sqrt_magnitude() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sqrt_magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; * &gt;&#160;</td>
          <td class="paramname"><em>sqrt_magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute square root of the Euclidean magnitude of a rank-0 tensor. </p>
<h3>Details</h3>
<p>Computes the square root of the absolute value of the scalar. </p>

</div>
</div>
<a id="ga6e49f65b2dd16062d894325fe9e8c7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e49f65b2dd16062d894325fe9e8c7fe">&#9670;&nbsp;</a></span>sqrt_magnitude() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; sqrt_magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute square root of the Euclidean magnitude of a rank-0 tensor. </p>
<h3>Details</h3>
<p>Computes the square root of the absolute value of the scalar. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga36bbeb0ee2084a06f7d950201cdc0d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36bbeb0ee2084a06f7d950201cdc0d79">&#9670;&nbsp;</a></span>is_frame_physical_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CheckFrame &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Frame::is_frame_physical_v = <a class="el" href="group__TensorGroup.html#ga4e16b80d37cb8a3e7c8ab95e72ab8724">is_frame_physical</a>&lt;CheckFrame&gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the frame is "physical" in the sense that it is meaningful to evaluate an analytic solution in that frame. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">static_assert(not Frame::is_frame_physical_v&lt;Frame::BlockLogical&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line">static_assert(not Frame::is_frame_physical_v&lt;Frame::ElementLogical&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line">static_assert(not Frame::is_frame_physical_v&lt;Frame::Distorted&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line">static_assert(not Frame::is_frame_physical_v&lt;Frame::Grid&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
<div class="line">static_assert(Frame::is_frame_physical_v&lt;Frame::Inertial&gt;,</div>
<div class="line">              <span class="stringliteral">&quot;Failed testing Frame::is_frame_physical&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
