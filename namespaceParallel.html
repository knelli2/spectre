<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.1"/>
  <title>SpECTRE: Parallel Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.08.01</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceParallel.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Parallel Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functionality for parallelization.  
<a href="namespaceParallel.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceParallel_1_1InboxInserters"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParallel_1_1InboxInserters.html">InboxInserters</a></td></tr>
<tr class="memdesc:namespaceParallel_1_1InboxInserters"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structs that have <code>insert_into_inbox</code> methods for commonly used cases. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array index used for indexing Chare Arrays, mostly an implementation detail.  <a href="structParallel_1_1ArrayIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1Callback.html">Callback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract base class, whose derived class holds a function that can be invoked at a later time. The function is intended to be invoked only once.  <a href="classParallel_1_1Callback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1SimpleActionCallback.html">SimpleActionCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a call to a simple action and its arguments. Can be invoked only once.  <a href="classParallel_1_1SimpleActionCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1SimpleActionCallback_3_01SimpleAction_00_01Proxy_01_4.html">SimpleActionCallback&lt; SimpleAction, Proxy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a call to a simple action without arguments.  <a href="classParallel_1_1SimpleActionCallback_3_01SimpleAction_00_01Proxy_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1PerformAlgorithmCallback.html">PerformAlgorithmCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a call to perform_algorithm.  <a href="classParallel_1_1PerformAlgorithmCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1MutableGlobalCache.html">MutableGlobalCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Charm++ chare that caches mutable data once per Charm++ core.  <a href="classParallel_1_1MutableGlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++ core.  <a href="classParallel_1_1GlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1Main.html">Main</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main function of a Charm++ executable. See <a href="group__ParallelGroup.html#details">the Parallelization documentation</a> for an overview of Metavariables, Phases, and parallel components.  <a href="classParallel_1_1Main.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1NodeLock.html">NodeLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typesafe wrapper for a lock for synchronization of shared resources on a given node, with safe creation, destruction, and serialization.  <a href="classParallel_1_1NodeLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1MutableCacheTag.html">MutableCacheTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__mutable__cache__tag.html">get_mutable_cache_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1PhaseActions.html">PhaseActions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all the actions to be executed in the specified phase.  <a href="structParallel_1_1PhaseActions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__action__list__from__phase__dep__action__list.html">get_action_list_from_phase_dep_action_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Lazy) metafunction to get the action list from a <code><a class="el" href="structParallel_1_1PhaseActions.html" title="List of all the actions to be executed in the specified phase.">PhaseActions</a></code>  <a href="structParallel_1_1get__action__list__from__phase__dep__action__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ReductionDatum.html">ReductionDatum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data to be reduced, and invokables to be called whenever two reduction messages are combined and after the reduction has been completed.  <a href="structParallel_1_1ReductionDatum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ReductionData_3_01ReductionDatum_3_01Ts_00_01InvokeCombines_00_01InvokeFinals_92b572618a1ebe21ccf137654ec822ac.html">ReductionData&lt; ReductionDatum&lt; Ts, InvokeCombines, InvokeFinals, InvokeFinalExtraArgsIndices &gt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for reducing a possibly heterogeneous collection of types in a single reduction call.  <a href="structParallel_1_1ReductionData_3_01ReductionDatum_3_01Ts_00_01InvokeCombines_00_01InvokeFinals_92b572618a1ebe21ccf137654ec822ac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1NoSection.html">NoSection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used instead of a <code><a class="el" href="structParallel_1_1Section.html" title="A subset of chares in a parallel component.">Parallel::Section</a></code> when no section is desired.  <a href="structParallel_1_1NoSection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1SingletonInfoHolder.html">SingletonInfoHolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds resource info for a single singleton component.  <a href="structParallel_1_1SingletonInfoHolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1SingletonPack.html">SingletonPack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1SingletonPack_3_01tmpl_1_1list_3_01ParallelComponents_8_8_8_01_4_01_4.html">SingletonPack&lt; tmpl::list&lt; ParallelComponents... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds options for a group of singleton components.  <a href="structParallel_1_1SingletonPack_3_01tmpl_1_1list_3_01ParallelComponents_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ResourceInfo.html">ResourceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds resource info for all singletons and for avoiding placing array elements/singletons on the global proc 0.  <a href="structParallel_1_1ResourceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Section.html">Section</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A subset of chares in a parallel component.  <a href="structParallel_1_1Section.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__array__proxy.html">is_array_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for an array chare (the entire array)  <a href="structParallel_1_1is__array__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__array__element__proxy.html">is_array_element_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for an array chare element (from indexing into the array chare)  <a href="structParallel_1_1is__array__element__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__group__proxy.html">is_group_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a group chare.  <a href="structParallel_1_1is__group__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__node__group__proxy.html">is_node_group_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a node group chare.  <a href="structParallel_1_1is__node__group__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__bound__array.html">is_bound_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a ParallelComponent for a Charm++ bound array.  <a href="structParallel_1_1is__bound__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_bound_array&lt; T, std::void_t&lt; typename T::bind_to &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__array.html">is_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a SpECTRE Array.  <a href="structParallel_1_1is__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__singleton.html">is_singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a SpECTRE Singleton.  <a href="structParallel_1_1is__singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__group.html">is_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a SpECTRE Group.  <a href="structParallel_1_1is__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__nodegroup.html">is_nodegroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a SpECTRE Nodegroup.  <a href="structParallel_1_1is__nodegroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__parallel__component__from__proxy.html">get_parallel_component_from_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a parallel component from its proxy.  <a href="structParallel_1_1get__parallel__component__from__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__parallel__component__from__proxy_3_01Proxy_3_01ParallelComponent_00_01Ts_8_8_8_01_4_01_4.html">get_parallel_component_from_proxy&lt; Proxy&lt; ParallelComponent, Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1has__pup__member.html">has_pup_member</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> has a <code>pup</code> member function.  <a href="structParallel_1_1has__pup__member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__pupable.html">is_pupable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type <code>T</code> has operator| defined for Charm++ serialization.  <a href="structParallel_1_1is__pupable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af78863455c4051f7335d78eaa9c5c4e8"><td class="memItemLeft" align="right" valign="top"><a id="af78863455c4051f7335d78eaa9c5c4e8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#af78863455c4051f7335d78eaa9c5c4e8">iterable_action_return_t</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; <a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cf">AlgorithmExecution</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; size_t &gt; &gt;</td></tr>
<tr class="memdesc:af78863455c4051f7335d78eaa9c5c4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for iterable actions. The <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a> can be used to specify the index of the action to be called next in the phase dependent action list. Passing std::nullopt will execute the next action in the list. <br /></td></tr>
<tr class="separator:af78863455c4051f7335d78eaa9c5c4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af00caa6f5b7401a8e0235898224263"><td class="memItemLeft" align="right" valign="top"><a id="a5af00caa6f5b7401a8e0235898224263"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayIndex1D</b> = <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a>&lt; CkIndex1D &gt;</td></tr>
<tr class="separator:a5af00caa6f5b7401a8e0235898224263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708856568c7f6b3cf04998b8d3b313b5"><td class="memItemLeft" align="right" valign="top"><a id="a708856568c7f6b3cf04998b8d3b313b5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayIndex2D</b> = <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a>&lt; CkIndex2D &gt;</td></tr>
<tr class="separator:a708856568c7f6b3cf04998b8d3b313b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e74268e437cfcbd24c65c9f483bd7b"><td class="memItemLeft" align="right" valign="top"><a id="a51e74268e437cfcbd24c65c9f483bd7b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayIndex3D</b> = <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a>&lt; CkIndex3D &gt;</td></tr>
<tr class="separator:a51e74268e437cfcbd24c65c9f483bd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2716038682076ad43ca77c3e516db722"><td class="memItemLeft" align="right" valign="top"><a id="a2716038682076ad43ca77c3e516db722"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayIndex4D</b> = <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a>&lt; CkIndex4D &gt;</td></tr>
<tr class="separator:a2716038682076ad43ca77c3e516db722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec254431cf1a28459a5baea688877fc"><td class="memItemLeft" align="right" valign="top"><a id="a5ec254431cf1a28459a5baea688877fc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayIndex5D</b> = <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a>&lt; CkIndex5D &gt;</td></tr>
<tr class="separator:a5ec254431cf1a28459a5baea688877fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2d628261f946a0f57d2e9cb90efe3d"><td class="memItemLeft" align="right" valign="top"><a id="a0b2d628261f946a0f57d2e9cb90efe3d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayIndex6D</b> = <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a>&lt; CkIndex6D &gt;</td></tr>
<tr class="separator:a0b2d628261f946a0f57d2e9cb90efe3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae918917e798cb6dd36a6cca9ede77616"><td class="memTemplParams" colspan="2">
template&lt;class ActionsList &gt; </td></tr>
<tr class="memitem:gae918917e798cb6dd36a6cca9ede77616"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gae918917e798cb6dd36a6cca9ede77616">get_inbox_tags</a> = tmpl::remove_duplicates&lt; tmpl::join&lt; tmpl::transform&lt; ActionsList, detail::get_inbox_tags_from_action&lt; tmpl::_1 &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:gae918917e798cb6dd36a6cca9ede77616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of Actions, get a list of the unique inbox tags. <br /></td></tr>
<tr class="separator:gae918917e798cb6dd36a6cca9ede77616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memTemplParams" colspan="2">
template&lt;class ActionsList &gt; </td></tr>
<tr class="memitem:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gab2c3e5b7084f5cb31c8c5cc7595349a6">get_const_global_cache_tags_from_actions</a> = tmpl::remove_duplicates&lt; tmpl::join&lt; tmpl::transform&lt; ActionsList, detail::get_const_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of Actions, get a list of the unique tags specified in the actions' <code>const_global_cache_tags</code> aliases. <br /></td></tr>
<tr class="separator:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c47960b4397660c8ece4b63da46558"><td class="memTemplParams" colspan="2">
template&lt;class ActionsList &gt; </td></tr>
<tr class="memitem:ga54c47960b4397660c8ece4b63da46558"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga54c47960b4397660c8ece4b63da46558">get_mutable_global_cache_tags_from_actions</a> = tmpl::remove_duplicates&lt; tmpl::join&lt; tmpl::transform&lt; ActionsList, detail::get_mutable_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:ga54c47960b4397660c8ece4b63da46558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of Actions, get a list of the unique tags specified in the actions' <code>mutable_global_cache_tags</code> aliases. <br /></td></tr>
<tr class="separator:ga54c47960b4397660c8ece4b63da46558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e3053314568ebf144ba895c04ead0e"><td class="memTemplParams" colspan="2">
template&lt;typename Metavariables &gt; </td></tr>
<tr class="memitem:ga03e3053314568ebf144ba895c04ead0e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga03e3053314568ebf144ba895c04ead0e">get_const_global_cache_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; typename detail::get_const_global_cache_tags_from_parallel_struct&lt; Metavariables &gt;::type, tmpl::transform&lt; typename Metavariables::component_list, detail::get_const_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt;, tmpl::transform&lt; typename Metavariables::component_list, detail::get_const_global_cache_tags_from_pdal&lt; tmpl::_1 &gt; &gt;&gt; &gt;&gt;</td></tr>
<tr class="memdesc:ga03e3053314568ebf144ba895c04ead0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the metavariables, get a list of the unique tags that will specify the items in the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">GlobalCache</a>. <br /></td></tr>
<tr class="separator:ga03e3053314568ebf144ba895c04ead0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="memTemplParams" colspan="2">
template&lt;typename Metavariables &gt; </td></tr>
<tr class="memitem:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gab10d351ad8ecf07b1ec23dbad2e70a3d">get_mutable_global_cache_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; typename detail::get_mutable_global_cache_tags_from_parallel_struct&lt; Metavariables &gt;::type, tmpl::transform&lt; typename Metavariables::component_list, detail::get_mutable_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt;, tmpl::transform&lt; typename Metavariables::component_list, detail::get_mutable_global_cache_tags_from_pdal&lt; tmpl::_1 &gt; &gt;&gt; &gt;&gt;</td></tr>
<tr class="memdesc:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the metavariables, get a list of the unique tags that will specify the mutable items in the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">GlobalCache</a>. <br /></td></tr>
<tr class="separator:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dc75a2988c215c842aa1192219b192"><td class="memTemplParams" colspan="2"><a id="a38dc75a2988c215c842aa1192219b192"></a>
template&lt;typename Metavariables &gt; </td></tr>
<tr class="memitem:a38dc75a2988c215c842aa1192219b192"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_mutable_global_cache_tag_storage</b> = tmpl::transform&lt; <a class="el" href="group__ParallelGroup.html#gab10d351ad8ecf07b1ec23dbad2e70a3d">get_mutable_global_cache_tags</a>&lt; Metavariables &gt;, <a class="el" href="structParallel_1_1get__mutable__cache__tag.html">get_mutable_cache_tag</a>&lt; tmpl::_1 &gt; &gt;</td></tr>
<tr class="separator:a38dc75a2988c215c842aa1192219b192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memTemplParams" colspan="2">
template&lt;typename PhaseDepActionList &gt; </td></tr>
<tr class="memitem:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gac5fb42f8eaf4da2707e32ed37ecf4e66">get_initialization_actions_list</a> = tmpl::flatten&lt; tmpl::transform&lt; PhaseDepActionList, detail::get_initialization_actions_list&lt; tmpl::_1 &gt; &gt;&gt;</td></tr>
<tr class="memdesc:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the phase dependent action list, return the list of actions in the Initialization phase (or an empty list if the Initialization phase is absent from the phase dependent action list) <br /></td></tr>
<tr class="separator:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e2e4c961e55eb461d66770393e4f45d"><td class="memTemplParams" colspan="2">
template&lt;typename InitializationActionsList , typename AllocationTagsList  = tmpl::list&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga1e2e4c961e55eb461d66770393e4f45d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga1e2e4c961e55eb461d66770393e4f45d">get_initialization_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; AllocationTagsList, tmpl::transform&lt; InitializationActionsList, detail::get_initialization_tags_from_action&lt; tmpl::_1 &gt; &gt;&gt; &gt;&gt;</td></tr>
<tr class="memdesc:ga1e2e4c961e55eb461d66770393e4f45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of initialization actions, and possibly a list of tags needed for allocation of an array component, returns a list of the unique initialization_tags for all the actions (and the allocate function). <br /></td></tr>
<tr class="separator:ga1e2e4c961e55eb461d66770393e4f45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc2e63ea42550ab888291b78b3a0bb4"><td class="memTemplParams" colspan="2">
template&lt;typename InitializationActionsList &gt; </td></tr>
<tr class="memitem:ga5fc2e63ea42550ab888291b78b3a0bb4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga5fc2e63ea42550ab888291b78b3a0bb4">get_initialization_tags_to_keep</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; InitializationActionsList, detail::get_initialization_tags_to_keep_from_action&lt; tmpl::_1 &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:ga5fc2e63ea42550ab888291b78b3a0bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of initialization actions, returns a list of the unique initialization_tags_to_keep for all the actions. These are the tags that are not removed from the DataBox after initialization. <br /></td></tr>
<tr class="separator:ga5fc2e63ea42550ab888291b78b3a0bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga619cbb884a70fef0cc726ffe1b379201"><td class="memTemplParams" colspan="2">
template&lt;typename InitializationTagsList , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga619cbb884a70fef0cc726ffe1b379201"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga619cbb884a70fef0cc726ffe1b379201">get_option_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; InitializationTagsList, tmpl::bind&lt; detail::get_option_tags_from_initialization_tag&lt; Metavariables &gt;::template f, tmpl::_1 &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:ga619cbb884a70fef0cc726ffe1b379201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of initialization tags, returns a list of the unique option tags required to construct them. <br /></td></tr>
<tr class="separator:ga619cbb884a70fef0cc726ffe1b379201"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af31fff079d116e958890e079a35955cf"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cf">AlgorithmExecution</a> { <a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cfaa0bfb8e59e6c13fc8d990781f77694fe">Continue</a>
, <a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cfa6327b4e59f58137083214a1fec358855">Retry</a>
, <a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cfa105b296a83f9c105355403f3332af50f">Pause</a>
, <a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cfa4558f7fa8f5356a88a53347ad89babde">Halt</a>
 }</td></tr>
<tr class="memdesc:af31fff079d116e958890e079a35955cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible options for altering the current execution of the algorithm, used in the return type of iterable actions.  <a href="namespaceParallel.html#af31fff079d116e958890e079a35955cf">More...</a><br /></td></tr>
<tr class="separator:af31fff079d116e958890e079a35955cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga027a2e60b10898507f92ba7290f0ba61"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Phase</a> { <br />
&#160;&#160;<a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a8c6384dda98d8864d00e29dc96179970">Cleanup</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a022b83d0b2bb2af3709c384b36e7ce2b">Evolve</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a40cd014b7b6251e3a22e6a45a73a64e1">Execute</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afef46e5063ce3dc78b8ae64fa474241d">Exit</a>
, <br />
&#160;&#160;<a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a0fff9cc14992a69d78edc10a85206c01">ImportInitialData</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a61bcd96a2c1f8026527cbf2019d6e9a4">Initialization</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61ab0fc63355327fdd0b60d600564afcc63">InitializeInitialDataDependentQuantities</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a8c04c19a8219116bb54698ec3a8544c2">InitializeTimeStepperHistory</a>
, <br />
&#160;&#160;<a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a5fb96ac8b4e030b4e88bd71b95460d02">LoadBalancing</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a0ba7583639a274c434bbe6ef797115a4">Register</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a303602e6afb9f2d4b528497410bdec47">RegisterWithElementDataReader</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a97817e0979af8f0291365165b76a45b5">Solve</a>
, <br />
&#160;&#160;<a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61afa6a5a3224d7da66d9e0bdec25f62cf0">Testing</a>
, <a class="el" href="group__ParallelGroup.html#gga027a2e60b10898507f92ba7290f0ba61a667488c55c3abca96b02755bfe193681">WriteCheckpoint</a>
<br />
 }</td></tr>
<tr class="memdesc:ga027a2e60b10898507f92ba7290f0ba61"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible phases of an executable.  <a href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">More...</a><br /></td></tr>
<tr class="separator:ga027a2e60b10898507f92ba7290f0ba61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3a840bdd21a6f17bd10c0c05250c2da9"><td class="memTemplParams" colspan="2">
template&lt;typename Metavariables , typename... Tags, typename... OptionTags&gt; </td></tr>
<tr class="memitem:ga3a840bdd21a6f17bd10c0c05250c2da9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; Tags... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga3a840bdd21a6f17bd10c0c05250c2da9">create_from_options</a> (const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; OptionTags... &gt; &amp;options, tmpl::list&lt; Tags... &gt;)</td></tr>
<tr class="memdesc:ga3a840bdd21a6f17bd10c0c05250c2da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of tags and a tagged tuple containing items created from input options, return a tagged tuple of items constructed by calls to create_from_options for each tag in the list. <br /></td></tr>
<tr class="separator:ga3a840bdd21a6f17bd10c0c05250c2da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb89645162cd107cd89f55bd23a33a94"><td class="memTemplParams" colspan="2">template&lt;typename ParallelComponent , typename SectionIdTag , typename DbTagsList &gt; </td></tr>
<tr class="memitem:abb89645162cd107cd89f55bd23a33a94"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#abb89645162cd107cd89f55bd23a33a94">get_section</a> ([[maybe_unused]] const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTagsList &gt; * &gt; box)</td></tr>
<tr class="memdesc:abb89645162cd107cd89f55bd23a33a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the section that the element belongs to, or <code>Parallel::no_section()</code> if <code>SectionIdTag</code> is <code>void</code>.  <a href="namespaceParallel.html#abb89645162cd107cd89f55bd23a33a94">More...</a><br /></td></tr>
<tr class="separator:abb89645162cd107cd89f55bd23a33a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga602c224997d604c7741c21dd4138e29d"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga602c224997d604c7741c21dd4138e29d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga602c224997d604c7741c21dd4138e29d">number_of_procs</a> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga602c224997d604c7741c21dd4138e29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements. <br /></td></tr>
<tr class="separator:ga602c224997d604c7741c21dd4138e29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf89c583112f5be12c618a0ec2fc0cfb"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:gadf89c583112f5be12c618a0ec2fc0cfb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gadf89c583112f5be12c618a0ec2fc0cfb">my_proc</a> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gadf89c583112f5be12c618a0ec2fc0cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my processing element. <br /></td></tr>
<tr class="separator:gadf89c583112f5be12c618a0ec2fc0cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf79215bb2d12770fdbd2ad6c3cec91a8"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:gaf79215bb2d12770fdbd2ad6c3cec91a8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaf79215bb2d12770fdbd2ad6c3cec91a8">number_of_nodes</a> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gaf79215bb2d12770fdbd2ad6c3cec91a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes. <br /></td></tr>
<tr class="separator:gaf79215bb2d12770fdbd2ad6c3cec91a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03ed6d71aee72251a19eb2c7d25b621"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:gad03ed6d71aee72251a19eb2c7d25b621"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gad03ed6d71aee72251a19eb2c7d25b621">my_node</a> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gad03ed6d71aee72251a19eb2c7d25b621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my node. <br /></td></tr>
<tr class="separator:gad03ed6d71aee72251a19eb2c7d25b621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga360db89dbc73353e6bf4c484db619403"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename R , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga360db89dbc73353e6bf4c484db619403"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga360db89dbc73353e6bf4c484db619403">procs_on_node</a> (const R node_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga360db89dbc73353e6bf4c484db619403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements on the given node. <br /></td></tr>
<tr class="separator:ga360db89dbc73353e6bf4c484db619403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a1e2bd8f33a1eb980b4eae811c0575"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga76a1e2bd8f33a1eb980b4eae811c0575"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga76a1e2bd8f33a1eb980b4eae811c0575">my_local_rank</a> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga76a1e2bd8f33a1eb980b4eae811c0575"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index of my processing element on my node. This is in the interval 0, ..., procs_on_node(my_node()) - 1. <br /></td></tr>
<tr class="separator:ga76a1e2bd8f33a1eb980b4eae811c0575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga004b55d123b4f2541b38c16c195c07d1"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename R , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga004b55d123b4f2541b38c16c195c07d1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga004b55d123b4f2541b38c16c195c07d1">first_proc_on_node</a> (const R node_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga004b55d123b4f2541b38c16c195c07d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of first processing element on the given node. <br /></td></tr>
<tr class="separator:ga004b55d123b4f2541b38c16c195c07d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga224caf730591903abf339e9f551adddc"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename R , typename DistribObject &gt; </td></tr>
<tr class="memitem:ga224caf730591903abf339e9f551adddc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga224caf730591903abf339e9f551adddc">node_of</a> (const R proc_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga224caf730591903abf339e9f551adddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the node for the given processing element. <br /></td></tr>
<tr class="separator:ga224caf730591903abf339e9f551adddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbdc7feb7a9dfc90022976465b747d8c"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename R , typename DistribObject &gt; </td></tr>
<tr class="memitem:gafbdc7feb7a9dfc90022976465b747d8c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gafbdc7feb7a9dfc90022976465b747d8c">local_rank_of</a> (const R proc_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gafbdc7feb7a9dfc90022976465b747d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index for the given processing element on its node. <br /></td></tr>
<tr class="separator:gafbdc7feb7a9dfc90022976465b747d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1078fa99233851c6475fbfa99a2f51d"><td class="memTemplParams" colspan="2">template&lt;typename ReceiveTag , typename Proxy , typename ReceiveDataType &gt; </td></tr>
<tr class="memitem:gad1078fa99233851c6475fbfa99a2f51d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gad1078fa99233851c6475fbfa99a2f51d">receive_data</a> (Proxy &amp;&amp;proxy, typename ReceiveTag::temporal_id temporal_id, ReceiveDataType &amp;&amp;receive_data, const bool enable_if_disabled=false)</td></tr>
<tr class="memdesc:gad1078fa99233851c6475fbfa99a2f51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the data <code>args...</code> to the algorithm running on <code>proxy</code>, and tag the message with the identifier <code>temporal_id</code>.  <a href="group__ParallelGroup.html#gad1078fa99233851c6475fbfa99a2f51d">More...</a><br /></td></tr>
<tr class="separator:gad1078fa99233851c6475fbfa99a2f51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="memTemplParams" colspan="2">
template&lt;typename Action , typename Proxy , typename... Args&gt; </td></tr>
<tr class="memitem:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gabed954105c6dfd7cc13d07dbcb0504b1">local_synchronous_action</a> (Proxy &amp;&amp;proxy, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a local synchronous action on <code>proxy</code> <br /></td></tr>
<tr class="separator:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557f16668f1b946565c3149382d1ac76"><td class="memTemplParams" colspan="2">template&lt;typename Proxy &gt; </td></tr>
<tr class="memitem:a557f16668f1b946565c3149382d1ac76"><td class="memTemplItemLeft" align="right" valign="top">auto *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#a557f16668f1b946565c3149382d1ac76">local</a> (Proxy &amp;&amp;proxy)</td></tr>
<tr class="memdesc:a557f16668f1b946565c3149382d1ac76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for calling Charm++'s <code>.ckLocal()</code> on a proxy.  <a href="namespaceParallel.html#a557f16668f1b946565c3149382d1ac76">More...</a><br /></td></tr>
<tr class="separator:a557f16668f1b946565c3149382d1ac76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe3b59007ab65d3b61564ebaadc473b"><td class="memTemplParams" colspan="2">template&lt;typename Proxy &gt; </td></tr>
<tr class="memitem:aabe3b59007ab65d3b61564ebaadc473b"><td class="memTemplItemLeft" align="right" valign="top">auto *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#aabe3b59007ab65d3b61564ebaadc473b">local_branch</a> (Proxy &amp;&amp;proxy)</td></tr>
<tr class="memdesc:aabe3b59007ab65d3b61564ebaadc473b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for calling Charm++'s <code>.ckLocalBranch()</code> on a proxy.  <a href="namespaceParallel.html#aabe3b59007ab65d3b61564ebaadc473b">More...</a><br /></td></tr>
<tr class="separator:aabe3b59007ab65d3b61564ebaadc473b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01e5160d209eb4467e3b741515e518e"><td class="memItemLeft" align="right" valign="top"><a id="ad01e5160d209eb4467e3b741515e518e"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Phase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>known_phases</b> ()</td></tr>
<tr class="separator:ad01e5160d209eb4467e3b741515e518e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e532fb219884217d45941f9450feb18"><td class="memItemLeft" align="right" valign="top"><a id="a3e532fb219884217d45941f9450feb18"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#a3e532fb219884217d45941f9450feb18">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="el" href="group__ParallelGroup.html#ga027a2e60b10898507f92ba7290f0ba61">Phase</a> &amp;phase)</td></tr>
<tr class="memdesc:a3e532fb219884217d45941f9450feb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for a Phase. <br /></td></tr>
<tr class="separator:a3e532fb219884217d45941f9450feb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21964b5d28608afd21ae090c1c4c073"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gae21964b5d28608afd21ae090c1c4c073"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">printf</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;format, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gae21964b5d28608afd21ae090c1c4c073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an atomic message to stdout with C printf usage.  <a href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">More...</a><br /></td></tr>
<tr class="separator:gae21964b5d28608afd21ae090c1c4c073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaa8448205dbaf9741505bd30dfad2cadc">printf_error</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;format, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaa8448205dbaf9741505bd30dfad2cadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an atomic message to stderr with C printf usage.  <a href="group__ParallelGroup.html#gaa8448205dbaf9741505bd30dfad2cadc">More...</a><br /></td></tr>
<tr class="separator:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4abbfa6be8e3cb276b3fe1e762eb01f"><td class="memTemplParams" colspan="2">template&lt;class Action , class SenderProxy , class TargetProxy , class... Ts, class SectionType  = NoSection&gt; </td></tr>
<tr class="memitem:gac4abbfa6be8e3cb276b3fe1e762eb01f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gac4abbfa6be8e3cb276b3fe1e762eb01f">contribute_to_reduction</a> (ReductionData&lt; Ts... &gt; reduction_data, const SenderProxy &amp;sender_component, const TargetProxy &amp;target_component, [[maybe_unused]] const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; SectionType * &gt; section=&amp;no_section())</td></tr>
<tr class="memdesc:gac4abbfa6be8e3cb276b3fe1e762eb01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a reduction from the <code>sender_component</code> (typically your own parallel component) to the <code>target_component</code>, performing the <code>Action</code> upon receiving the reduction.  <a href="group__ParallelGroup.html#gac4abbfa6be8e3cb276b3fe1e762eb01f">More...</a><br /></td></tr>
<tr class="separator:gac4abbfa6be8e3cb276b3fe1e762eb01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae233a5cb5a0d7468356bb4b89363554e"><td class="memTemplParams" colspan="2"><a id="ae233a5cb5a0d7468356bb4b89363554e"></a>
template&lt;typename... Registrants&gt; </td></tr>
<tr class="memitem:ae233a5cb5a0d7468356bb4b89363554e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#ae233a5cb5a0d7468356bb4b89363554e">register_classes_with_charm</a> (const tmpl::list&lt; Registrants... &gt;={})</td></tr>
<tr class="memdesc:ae233a5cb5a0d7468356bb4b89363554e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register specified classes. This function can either take classes to register as template arguments or take a <code>tmpl::list</code> of classes as a function argument. <br /></td></tr>
<tr class="separator:ae233a5cb5a0d7468356bb4b89363554e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf58332a13c64add7decc0d504523c89"><td class="memTemplParams" colspan="2"><a id="adf58332a13c64add7decc0d504523c89"></a>
template&lt;typename Base &gt; </td></tr>
<tr class="memitem:adf58332a13c64add7decc0d504523c89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#adf58332a13c64add7decc0d504523c89">register_derived_classes_with_charm</a> ()</td></tr>
<tr class="memdesc:adf58332a13c64add7decc0d504523c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register derived classes of the <code>Base</code> class. <br /></td></tr>
<tr class="separator:adf58332a13c64add7decc0d504523c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003b78f6cc305b6ebfbf91cc84a74e18"><td class="memTemplParams" colspan="2"><a id="a003b78f6cc305b6ebfbf91cc84a74e18"></a>
template&lt;typename Metavariables &gt; </td></tr>
<tr class="memitem:a003b78f6cc305b6ebfbf91cc84a74e18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#a003b78f6cc305b6ebfbf91cc84a74e18">register_factory_classes_with_charm</a> ()</td></tr>
<tr class="memdesc:a003b78f6cc305b6ebfbf91cc84a74e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register all classes in Metavariables::factory_classes. <br /></td></tr>
<tr class="separator:a003b78f6cc305b6ebfbf91cc84a74e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga7b4fa6bda7d10c243548504faa4f2877"><td class="memTemplParams" colspan="2">template&lt;typename ParallelComponentTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga7b4fa6bda7d10c243548504faa4f2877"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga7b4fa6bda7d10c243548504faa4f2877">get_parallel_component</a> (<a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache) -&gt; Parallel::proxy_from_parallel_component&lt; GlobalCache_detail::get_component_if_mocked&lt; typename Metavariables::component_list, ParallelComponentTag &gt;&gt; &amp;</td></tr>
<tr class="memdesc:ga7b4fa6bda7d10c243548504faa4f2877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the Charm++ proxy associated with a ParallelComponent.  <a href="group__ParallelGroup.html#ga7b4fa6bda7d10c243548504faa4f2877">More...</a><br /></td></tr>
<tr class="separator:ga7b4fa6bda7d10c243548504faa4f2877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e70551351aa531321d524727c577c4"><td class="memTemplParams" colspan="2">template&lt;typename ParallelComponentTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga78e70551351aa531321d524727c577c4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga78e70551351aa531321d524727c577c4">get_parallel_component</a> (const <a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache) -&gt; const Parallel::proxy_from_parallel_component&lt; GlobalCache_detail::get_component_if_mocked&lt; typename Metavariables::component_list, ParallelComponentTag &gt;&gt; &amp;</td></tr>
<tr class="memdesc:ga78e70551351aa531321d524727c577c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the Charm++ proxy associated with a ParallelComponent.  <a href="group__ParallelGroup.html#ga78e70551351aa531321d524727c577c4">More...</a><br /></td></tr>
<tr class="separator:ga78e70551351aa531321d524727c577c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga43c98b994ca4a6ef61235109c5b94e14"><td class="memTemplParams" colspan="2">template&lt;typename GlobalCacheTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga43c98b994ca4a6ef61235109c5b94e14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga43c98b994ca4a6ef61235109c5b94e14">get</a> (const <a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache) -&gt; const GlobalCache_detail::type_for_get&lt; GlobalCacheTag, Metavariables &gt; &amp;</td></tr>
<tr class="memdesc:ga43c98b994ca4a6ef61235109c5b94e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access data in the cache.  <a href="group__ParallelGroup.html#ga43c98b994ca4a6ef61235109c5b94e14">More...</a><br /></td></tr>
<tr class="separator:ga43c98b994ca4a6ef61235109c5b94e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="memTemplParams" colspan="2">template&lt;typename GlobalCacheTag , typename Function , typename Metavariables &gt; </td></tr>
<tr class="memitem:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaee973d82ab6a1dbac2b504e86d8de2e5">mutable_cache_item_is_ready</a> (<a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache, const Function &amp;function)</td></tr>
<tr class="memdesc:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the object identified by <code>GlobalCacheTag</code> is ready to be accessed by <code>get</code>.  <a href="group__ParallelGroup.html#gaee973d82ab6a1dbac2b504e86d8de2e5">More...</a><br /></td></tr>
<tr class="separator:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb8fc6f30581c450abecc8258dead3c"><td class="memTemplParams" colspan="2">template&lt;typename GlobalCacheTag , typename Function , typename Metavariables , typename... Args&gt; </td></tr>
<tr class="memitem:ga8fb8fc6f30581c450abecc8258dead3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c">mutate</a> (<a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga8fb8fc6f30581c450abecc8258dead3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutates non-const data in the cache, by calling <code>Function::apply()</code>  <a href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c">More...</a><br /></td></tr>
<tr class="separator:ga8fb8fc6f30581c450abecc8258dead3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="memTemplParams" colspan="2">
template&lt;typename Action , typename Proxy &gt; </td></tr>
<tr class="memitem:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga1902e18e22b3092208b8dd9f0e5f11c0">simple_action</a> (Proxy &amp;&amp;proxy)</td></tr>
<tr class="memdesc:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a simple action on <code>proxy</code> <br /></td></tr>
<tr class="separator:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9708c581cfd958746b601be4a03eb5"><td class="memTemplParams" colspan="2">
template&lt;typename Action , typename Proxy , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ga8e9708c581cfd958746b601be4a03eb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga8e9708c581cfd958746b601be4a03eb5">simple_action</a> (Proxy &amp;&amp;proxy, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga8e9708c581cfd958746b601be4a03eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a simple action on <code>proxy</code> <br /></td></tr>
<tr class="separator:ga8e9708c581cfd958746b601be4a03eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga49eb59320a0258c95d58b1447ff8702b"><td class="memTemplParams" colspan="2">
template&lt;typename Action , typename Proxy &gt; </td></tr>
<tr class="memitem:ga49eb59320a0258c95d58b1447ff8702b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga49eb59320a0258c95d58b1447ff8702b">threaded_action</a> (Proxy &amp;&amp;proxy)</td></tr>
<tr class="memdesc:ga49eb59320a0258c95d58b1447ff8702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a threaded action on <code>proxy</code>, where the proxy must be a nodegroup. <br /></td></tr>
<tr class="separator:ga49eb59320a0258c95d58b1447ff8702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga942169b97926623cb569158e724e62e0"><td class="memTemplParams" colspan="2">
template&lt;typename Action , typename Proxy , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ga942169b97926623cb569158e724e62e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga942169b97926623cb569158e724e62e0">threaded_action</a> (Proxy &amp;&amp;proxy, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga942169b97926623cb569158e724e62e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a threaded action on <code>proxy</code>, where the proxy must be a nodegroup. <br /></td></tr>
<tr class="separator:ga942169b97926623cb569158e724e62e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab3efd47ce7ceacc271fd4f6809230deb"><td class="memTemplParams" colspan="2">template&lt;typename SenderComponent , typename ArrayIndex , typename Metavariables , class... Ts&gt; </td></tr>
<tr class="memitem:ab3efd47ce7ceacc271fd4f6809230deb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#ab3efd47ce7ceacc271fd4f6809230deb">contribute_to_phase_change_reduction</a> (<a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; Ts... &gt; data_for_reduction, <a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;cache, const <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a> &amp;array_index)</td></tr>
<tr class="memdesc:ab3efd47ce7ceacc271fd4f6809230deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data from a parallel component to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare for making phase-change decisions.  <a href="namespaceParallel.html#ab3efd47ce7ceacc271fd4f6809230deb">More...</a><br /></td></tr>
<tr class="separator:ab3efd47ce7ceacc271fd4f6809230deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4026b678032c7c72edca27c1675f9da"><td class="memTemplParams" colspan="2">template&lt;typename SenderComponent , typename Metavariables , class... Ts&gt; </td></tr>
<tr class="memitem:ae4026b678032c7c72edca27c1675f9da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#ae4026b678032c7c72edca27c1675f9da">contribute_to_phase_change_reduction</a> (<a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; Ts... &gt; data_for_reduction, <a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;cache)</td></tr>
<tr class="memdesc:ae4026b678032c7c72edca27c1675f9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data from a parallel component to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare for making phase-change decisions.  <a href="namespaceParallel.html#ae4026b678032c7c72edca27c1675f9da">More...</a><br /></td></tr>
<tr class="separator:ae4026b678032c7c72edca27c1675f9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a38aa656aa26371838b9b92da83794414"><td class="memItemLeft" align="right" valign="top"><a id="a38aa656aa26371838b9b92da83794414"></a>
<a class="el" href="structParallel_1_1NoSection.html">NoSection</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>no_section</b> ()</td></tr>
<tr class="separator:a38aa656aa26371838b9b92da83794414"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga6794d6d662e9f601ebdbd8528536ead1"><td class="memTemplParams" colspan="2">template&lt;typename Metavariables , typename Tag &gt; </td></tr>
<tr class="memitem:ga6794d6d662e9f601ebdbd8528536ead1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga6794d6d662e9f601ebdbd8528536ead1">is_in_const_global_cache</a></td></tr>
<tr class="memdesc:ga6794d6d662e9f601ebdbd8528536ead1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a tag is retrievable from the const portion of the global cache.  <a href="group__ParallelGroup.html#ga6794d6d662e9f601ebdbd8528536ead1">More...</a><br /></td></tr>
<tr class="separator:ga6794d6d662e9f601ebdbd8528536ead1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f79ab2930d68c2050849ff60f80f162"><td class="memTemplParams" colspan="2">template&lt;typename Metavariables , typename Tag &gt; </td></tr>
<tr class="memitem:ga6f79ab2930d68c2050849ff60f80f162"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga6f79ab2930d68c2050849ff60f80f162">is_in_mutable_global_cache</a></td></tr>
<tr class="memdesc:ga6f79ab2930d68c2050849ff60f80f162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a tag is retrievable from the mutable portion of the global cache.  <a href="group__ParallelGroup.html#ga6f79ab2930d68c2050849ff60f80f162">More...</a><br /></td></tr>
<tr class="separator:ga6f79ab2930d68c2050849ff60f80f162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118c900b55b0e55a8d11cef00c77bd2d"><td class="memTemplParams" colspan="2">template&lt;typename Metavariables , typename Tag &gt; </td></tr>
<tr class="memitem:ga118c900b55b0e55a8d11cef00c77bd2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga118c900b55b0e55a8d11cef00c77bd2d">is_in_global_cache</a></td></tr>
<tr class="memdesc:ga118c900b55b0e55a8d11cef00c77bd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a tag is retrievable from the global cache.  <a href="group__ParallelGroup.html#ga118c900b55b0e55a8d11cef00c77bd2d">More...</a><br /></td></tr>
<tr class="separator:ga118c900b55b0e55a8d11cef00c77bd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7f44f7252bb541984b8010ed8e40728e"><td class="memTemplParams" colspan="2"><a id="a7f44f7252bb541984b8010ed8e40728e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f44f7252bb541984b8010ed8e40728e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_array_v</b> = <a class="el" href="structParallel_1_1is__array.html">is_array</a>&lt;T&gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a></td></tr>
<tr class="separator:a7f44f7252bb541984b8010ed8e40728e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a39e2a2af240311b7eefd6ae99f7e2a94"><td class="memTemplParams" colspan="2"><a id="a39e2a2af240311b7eefd6ae99f7e2a94"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39e2a2af240311b7eefd6ae99f7e2a94"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_singleton_v</b> = <a class="el" href="structParallel_1_1is__singleton.html">is_singleton</a>&lt;T&gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a></td></tr>
<tr class="separator:a39e2a2af240311b7eefd6ae99f7e2a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab52c36a18b398dd30610e5ec1924fbdf"><td class="memTemplParams" colspan="2"><a id="ab52c36a18b398dd30610e5ec1924fbdf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab52c36a18b398dd30610e5ec1924fbdf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_group_v</b> = <a class="el" href="structParallel_1_1is__group.html">is_group</a>&lt;T&gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a></td></tr>
<tr class="separator:ab52c36a18b398dd30610e5ec1924fbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac9745c720ae59a68cbd2c5a837db00ec"><td class="memTemplParams" colspan="2"><a id="ac9745c720ae59a68cbd2c5a837db00ec"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9745c720ae59a68cbd2c5a837db00ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_nodegroup_v</b> = <a class="el" href="structParallel_1_1is__nodegroup.html">is_nodegroup</a>&lt;T&gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a></td></tr>
<tr class="separator:ac9745c720ae59a68cbd2c5a837db00ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27907852d1e51848fc42c073f824554c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27907852d1e51848fc42c073f824554c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#a27907852d1e51848fc42c073f824554c">has_pup_member_t</a> = typename <a class="el" href="structParallel_1_1has__pup__member.html">has_pup_member</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a27907852d1e51848fc42c073f824554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bb92f00c4aa3fb15b1888332bc5462"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9bb92f00c4aa3fb15b1888332bc5462"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#ae9bb92f00c4aa3fb15b1888332bc5462">has_pup_member_v</a> = <a class="el" href="structParallel_1_1has__pup__member.html">has_pup_member</a>&lt;T&gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a></td></tr>
<tr class="separator:ae9bb92f00c4aa3fb15b1888332bc5462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f8a5f10d370ff570bb623bf858b6ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9f8a5f10d370ff570bb623bf858b6ed"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#af9f8a5f10d370ff570bb623bf858b6ed">is_pupable_t</a> = typename <a class="el" href="structParallel_1_1is__pupable.html">is_pupable</a>&lt; T &gt;::type</td></tr>
<tr class="separator:af9f8a5f10d370ff570bb623bf858b6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e5e039d67f87cc794544f3eb871029"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99e5e039d67f87cc794544f3eb871029"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParallel.html#a99e5e039d67f87cc794544f3eb871029">is_pupable_v</a> = <a class="el" href="structParallel_1_1is__pupable.html">is_pupable</a>&lt;T&gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a></td></tr>
<tr class="separator:a99e5e039d67f87cc794544f3eb871029"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functionality for parallelization. </p>
<p>The functions in namespace <code><a class="el" href="namespaceParallel.html" title="Functionality for parallelization.">Parallel</a></code> that return information on nodes and cores are templated on DistribObject. Actions should use these functions rather than the raw charm++ versions (in the sys namespace in Utilities/System/ParallelInfo.hpp) so that the mocking framework will see the mocked cores and nodes. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a27907852d1e51848fc42c073f824554c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27907852d1e51848fc42c073f824554c">&#9670;&nbsp;</a></span>has_pup_member_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceParallel.html#a27907852d1e51848fc42c073f824554c">Parallel::has_pup_member_t</a> = typedef typename <a class="el" href="structParallel_1_1has__pup__member.html">has_pup_member</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structParallel_1_1has__pup__member.html" title="Check if T has a pup member function.">has_pup_member</a> </dd></dl>

</div>
</div>
<a id="af9f8a5f10d370ff570bb623bf858b6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f8a5f10d370ff570bb623bf858b6ed">&#9670;&nbsp;</a></span>is_pupable_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceParallel.html#af9f8a5f10d370ff570bb623bf858b6ed">Parallel::is_pupable_t</a> = typedef typename <a class="el" href="structParallel_1_1is__pupable.html">is_pupable</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structParallel_1_1is__pupable.html" title="Check if type T has operator| defined for Charm++ serialization.">is_pupable</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="af31fff079d116e958890e079a35955cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31fff079d116e958890e079a35955cf">&#9670;&nbsp;</a></span>AlgorithmExecution</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceParallel.html#af31fff079d116e958890e079a35955cf">Parallel::AlgorithmExecution</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The possible options for altering the current execution of the algorithm, used in the return type of iterable actions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af31fff079d116e958890e079a35955cfaa0bfb8e59e6c13fc8d990781f77694fe"></a>Continue&#160;</td><td class="fielddoc"><p>Continue executing iterable actions. </p>
</td></tr>
<tr><td class="fieldname"><a id="af31fff079d116e958890e079a35955cfa6327b4e59f58137083214a1fec358855"></a>Retry&#160;</td><td class="fielddoc"><p>Temporarily stop executing iterable actions, but try the same action again after receiving data from other distributed objects. </p>
</td></tr>
<tr><td class="fieldname"><a id="af31fff079d116e958890e079a35955cfa105b296a83f9c105355403f3332af50f"></a>Pause&#160;</td><td class="fielddoc"><p>Stop the execution of iterable actions, but allow entry methods (communication) to explicitly request restarting the execution. </p>
</td></tr>
<tr><td class="fieldname"><a id="af31fff079d116e958890e079a35955cfa4558f7fa8f5356a88a53347ad89babde"></a>Halt&#160;</td><td class="fielddoc"><p>Stop the execution of iterable actions and do not allow their execution until after a phase change. Simple actions will still execute. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae4026b678032c7c72edca27c1675f9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4026b678032c7c72edca27c1675f9da">&#9670;&nbsp;</a></span>contribute_to_phase_change_reduction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SenderComponent , typename Metavariables , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::contribute_to_phase_change_reduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; Ts... &gt;&#160;</td>
          <td class="paramname"><em>data_for_reduction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data from a parallel component to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare for making phase-change decisions. </p>
<p>This function is distinct from <code><a class="el" href="group__ParallelGroup.html#gac4abbfa6be8e3cb276b3fe1e762eb01f" title="Perform a reduction from the sender_component (typically your own parallel component) to the target_c...">Parallel::contribute_to_reduction</a></code> because this function contributes reduction data to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare via the entry method <code>phase_change_reduction</code>. This must be done because the entry method must alter member data specific to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare, and the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare cannot execute actions like most SpECTRE parallel components. For all cases other than sending phase-change decision data to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare, you should use <code><a class="el" href="group__ParallelGroup.html#gac4abbfa6be8e3cb276b3fe1e762eb01f" title="Perform a reduction from the sender_component (typically your own parallel component) to the target_c...">Parallel::contribute_to_reduction</a></code>. </p>

</div>
</div>
<a id="ab3efd47ce7ceacc271fd4f6809230deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3efd47ce7ceacc271fd4f6809230deb">&#9670;&nbsp;</a></span>contribute_to_phase_change_reduction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SenderComponent , typename ArrayIndex , typename Metavariables , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::contribute_to_phase_change_reduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; Ts... &gt;&#160;</td>
          <td class="paramname"><em>data_for_reduction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>array_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data from a parallel component to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare for making phase-change decisions. </p>
<p>This function is distinct from <code><a class="el" href="group__ParallelGroup.html#gac4abbfa6be8e3cb276b3fe1e762eb01f" title="Perform a reduction from the sender_component (typically your own parallel component) to the target_c...">Parallel::contribute_to_reduction</a></code> because this function contributes reduction data to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare via the entry method <code>phase_change_reduction</code>. This must be done because the entry method must alter member data specific to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare, and the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare cannot execute actions like most SpECTRE parallel components. For all cases other than sending phase-change decision data to the <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> chare, you should use <code><a class="el" href="group__ParallelGroup.html#gac4abbfa6be8e3cb276b3fe1e762eb01f" title="Perform a reduction from the sender_component (typically your own parallel component) to the target_c...">Parallel::contribute_to_reduction</a></code>. </p>

</div>
</div>
<a id="abb89645162cd107cd89f55bd23a33a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb89645162cd107cd89f55bd23a33a94">&#9670;&nbsp;</a></span>get_section()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponent , typename SectionIdTag , typename DbTagsList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; Parallel::get_section </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTagsList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the section that the element belongs to, or <code>Parallel::no_section()</code> if <code>SectionIdTag</code> is <code>void</code>. </p>
<p>This function is useful to support sections in parallel algorithms. Specify the <code>SectionIdTag</code> template parameter to retrieve the associated section, or set it to <code>void</code> when the parallel algorithm runs over all elements of the parallel component. See <code><a class="el" href="structParallel_1_1Section.html" title="A subset of chares in a parallel component.">Parallel::Section</a></code> for details on sections.</p>
<p>Only call this function on elements that are part of a section. In case not all elements are part of a section with the <code>SectionIdTag</code>, make sure to skip those elements before calling this function. </p>

</div>
</div>
<a id="a557f16668f1b946565c3149382d1ac76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557f16668f1b946565c3149382d1ac76">&#9670;&nbsp;</a></span>local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Proxy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto* Parallel::local </td>
          <td>(</td>
          <td class="paramtype">Proxy &amp;&amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for calling Charm++'s <code>.ckLocal()</code> on a proxy. </p>
<p>The Proxy must be to a Charm++ array chare (implementing a singleton design pattern using a single-element array) or to a Charm++ array element chare (i.e., the proxy obtained by indexing into a Charm++ array chare).</p>
<p>The function returns a pointer to the chare if it exists on the local processor, and NULL if it does not. See the Charm++ documentation. It is the responsibility of the user to check the result pointer is valid. </p>

</div>
</div>
<a id="aabe3b59007ab65d3b61564ebaadc473b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe3b59007ab65d3b61564ebaadc473b">&#9670;&nbsp;</a></span>local_branch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Proxy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto* Parallel::local_branch </td>
          <td>(</td>
          <td class="paramtype">Proxy &amp;&amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for calling Charm++'s <code>.ckLocalBranch()</code> on a proxy. </p>
<p>The Proxy must be to a Charm++ group chare or nodegroup chare.</p>
<p>The function returns a pointer to the local group/nodegroup chare. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae9bb92f00c4aa3fb15b1888332bc5462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bb92f00c4aa3fb15b1888332bc5462">&#9670;&nbsp;</a></span>has_pup_member_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Parallel::has_pup_member_v = <a class="el" href="structParallel_1_1has__pup__member.html">has_pup_member</a>&lt;T&gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structParallel_1_1has__pup__member.html" title="Check if T has a pup member function.">has_pup_member</a> </dd></dl>

</div>
</div>
<a id="a99e5e039d67f87cc794544f3eb871029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e5e039d67f87cc794544f3eb871029">&#9670;&nbsp;</a></span>is_pupable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Parallel::is_pupable_v = <a class="el" href="structParallel_1_1is__pupable.html">is_pupable</a>&lt;T&gt;::<a class="el" href="group__UtilitiesGroup.html#gad75a9bd1792f43ccf8e6edf254f090ab">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structParallel_1_1is__pupable.html" title="Check if type T has operator| defined for Charm++ serialization.">is_pupable</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceParallel.html">Parallel</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
