<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.1"/>
  <title>SpECTRE: Spectral Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.08.01</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceSpectral.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Spectral Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functionality associated with a particular choice of basis functions and quadrature for spectral operations.  
<a href="namespaceSpectral.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceSpectral_1_1filtering"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral_1_1filtering.html">filtering</a></td></tr>
<tr class="memdesc:namespaceSpectral_1_1filtering"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrices for filtering spectral coefficients. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceSpectral_1_1Swsh"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral_1_1Swsh.html">Swsh</a></td></tr>
<tr class="memdesc:namespaceSpectral_1_1Swsh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for spin-weighted spherical harmonic utilities. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a333f93eb48b32a0468af7aa9e01eac5e"><td class="memItemLeft" align="right" valign="top"><a id="a333f93eb48b32a0468af7aa9e01eac5e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a333f93eb48b32a0468af7aa9e01eac5e">MortarSize</a> = <a class="el" href="namespaceSpectral.html#a29a5155276364fffc6ecdaadb0ba3935">ChildSize</a></td></tr>
<tr class="memdesc:a333f93eb48b32a0468af7aa9e01eac5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The portion of an element covered by a mortar. <br /></td></tr>
<tr class="separator:a333f93eb48b32a0468af7aa9e01eac5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a29a5155276364fffc6ecdaadb0ba3935"><td class="memItemLeft" align="right" valign="top"><a id="a29a5155276364fffc6ecdaadb0ba3935"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a29a5155276364fffc6ecdaadb0ba3935">ChildSize</a> { <b>Full</b>
, <b>UpperHalf</b>
, <b>LowerHalf</b>
 }</td></tr>
<tr class="memdesc:a29a5155276364fffc6ecdaadb0ba3935"><td class="mdescLeft">&#160;</td><td class="mdescRight">The portion of a mesh covered by a child mesh. <br /></td></tr>
<tr class="separator:a29a5155276364fffc6ecdaadb0ba3935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37c9c17d05dccca652060d117f72ee21"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga37c9c17d05dccca652060d117f72ee21">Basis</a> { <b>Chebyshev</b>
, <b>Legendre</b>
, <b>FiniteDifference</b>
, <b>SphericalHarmonic</b>
 }</td></tr>
<tr class="memdesc:ga37c9c17d05dccca652060d117f72ee21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The choice of basis functions for computing collocation points and weights.  <a href="group__SpectralGroup.html#ga37c9c17d05dccca652060d117f72ee21">More...</a><br /></td></tr>
<tr class="separator:ga37c9c17d05dccca652060d117f72ee21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7744e520f6d553caf358a6f09f5978c1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga7744e520f6d553caf358a6f09f5978c1">Quadrature</a> { <br />
&#160;&#160;<b>Gauss</b>
, <b>GaussLobatto</b>
, <b>CellCentered</b>
, <b>FaceCentered</b>
, <br />
&#160;&#160;<b>Equiangular</b>
<br />
 }</td></tr>
<tr class="memdesc:ga7744e520f6d553caf358a6f09f5978c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The choice of quadrature method to compute integration weights.  <a href="group__SpectralGroup.html#ga7744e520f6d553caf358a6f09f5978c1">More...</a><br /></td></tr>
<tr class="separator:ga7744e520f6d553caf358a6f09f5978c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a67f98654ba9e0dce9531062b0f82df4f"><td class="memItemLeft" align="right" valign="top"><a id="a67f98654ba9e0dce9531062b0f82df4f"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, <a class="el" href="namespaceSpectral.html#a29a5155276364fffc6ecdaadb0ba3935">ChildSize</a> mortar_size)</td></tr>
<tr class="separator:a67f98654ba9e0dce9531062b0f82df4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae686cf37de660a26a6c6a7f98676642"><td class="memTemplParams" colspan="2"><a id="aae686cf37de660a26a6c6a7f98676642"></a>
template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:aae686cf37de660a26a6c6a7f98676642"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#aae686cf37de660a26a6c6a7f98676642">needs_projection</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh1, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;mesh2, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="namespaceSpectral.html#a29a5155276364fffc6ecdaadb0ba3935">ChildSize</a>, Dim &gt; &amp;child_sizes)</td></tr>
<tr class="memdesc:aae686cf37de660a26a6c6a7f98676642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether data needs to be projected between a child mesh and its parent mesh. If no projection is necessary the data may be used as-is. Projection is necessary if the child is either p-refined or h-refined relative to its parent, or both. This operation is symmetric, i.e. it is irrelevant in which order the child and the parent mesh are passed in. <br /></td></tr>
<tr class="separator:aae686cf37de660a26a6c6a7f98676642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ece319cd1c9031f9b513dc3370087f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a1ece319cd1c9031f9b513dc3370087f5">projection_matrix_child_to_parent</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;child_mesh, const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;parent_mesh, <a class="el" href="namespaceSpectral.html#a29a5155276364fffc6ecdaadb0ba3935">ChildSize</a> size, bool operand_is_massive=false)</td></tr>
<tr class="memdesc:a1ece319cd1c9031f9b513dc3370087f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The projection matrix from a child mesh to its parent.  <a href="namespaceSpectral.html#a1ece319cd1c9031f9b513dc3370087f5">More...</a><br /></td></tr>
<tr class="separator:a1ece319cd1c9031f9b513dc3370087f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6755a27e3400cd3a6e983dcb669b7558"><td class="memTemplParams" colspan="2"><a id="a6755a27e3400cd3a6e983dcb669b7558"></a>
template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a6755a27e3400cd3a6e983dcb669b7558"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a>&lt; const <a class="el" href="classMatrix.html">Matrix</a> &gt;, Dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a6755a27e3400cd3a6e983dcb669b7558">projection_matrix_child_to_parent</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;child_mesh, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;parent_mesh, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="namespaceSpectral.html#a29a5155276364fffc6ecdaadb0ba3935">ChildSize</a>, Dim &gt; &amp;child_sizes, bool operand_is_massive=false)</td></tr>
<tr class="memdesc:a6755a27e3400cd3a6e983dcb669b7558"><td class="mdescLeft">&#160;</td><td class="mdescRight">The projection matrix from a child mesh to its parent, in <code>Dim</code> dimensions. <br /></td></tr>
<tr class="separator:a6755a27e3400cd3a6e983dcb669b7558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9ce13d144a629adb3abc3e70dbe1fe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a4b9ce13d144a629adb3abc3e70dbe1fe">projection_matrix_parent_to_child</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;parent_mesh, const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;child_mesh, <a class="el" href="namespaceSpectral.html#a29a5155276364fffc6ecdaadb0ba3935">ChildSize</a> size)</td></tr>
<tr class="memdesc:a4b9ce13d144a629adb3abc3e70dbe1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The projection matrix from a parent mesh to one of its children.  <a href="namespaceSpectral.html#a4b9ce13d144a629adb3abc3e70dbe1fe">More...</a><br /></td></tr>
<tr class="separator:a4b9ce13d144a629adb3abc3e70dbe1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ee6855b288a64764017fc0674dc188"><td class="memTemplParams" colspan="2"><a id="a49ee6855b288a64764017fc0674dc188"></a>
template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a49ee6855b288a64764017fc0674dc188"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a>&lt; const <a class="el" href="classMatrix.html">Matrix</a> &gt;, Dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a49ee6855b288a64764017fc0674dc188">projection_matrix_parent_to_child</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;parent_mesh, const <a class="el" href="classMesh.html">Mesh</a>&lt; Dim &gt; &amp;child_mesh, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="namespaceSpectral.html#a29a5155276364fffc6ecdaadb0ba3935">ChildSize</a>, Dim &gt; &amp;child_sizes)</td></tr>
<tr class="memdesc:a49ee6855b288a64764017fc0674dc188"><td class="mdescLeft">&#160;</td><td class="mdescRight">The projection matrix from a parent mesh to one of its children, in <code>Dim</code> dimensions. <br /></td></tr>
<tr class="separator:a49ee6855b288a64764017fc0674dc188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc06f75e321814cac120e79596487cc"><td class="memItemLeft" align="right" valign="top"><a id="a7fc06f75e321814cac120e79596487cc"></a>
<a class="el" href="group__SpectralGroup.html#ga37c9c17d05dccca652060d117f72ee21">Basis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a7fc06f75e321814cac120e79596487cc">to_basis</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;basis)</td></tr>
<tr class="memdesc:a7fc06f75e321814cac120e79596487cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a Basis enum. <br /></td></tr>
<tr class="separator:a7fc06f75e321814cac120e79596487cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98554766ae679ca2506f78ceb18837c7"><td class="memItemLeft" align="right" valign="top"><a id="a98554766ae679ca2506f78ceb18837c7"></a>
<a class="el" href="group__SpectralGroup.html#ga7744e520f6d553caf358a6f09f5978c1">Quadrature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a98554766ae679ca2506f78ceb18837c7">to_quadrature</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;quadrature)</td></tr>
<tr class="memdesc:a98554766ae679ca2506f78ceb18837c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a Basis enum. <br /></td></tr>
<tr class="separator:a98554766ae679ca2506f78ceb18837c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847fcdaa3319e19b7f8539da7758ca88"><td class="memTemplParams" colspan="2"><a id="a847fcdaa3319e19b7f8539da7758ca88"></a>
template&lt;Basis BasisType, typename T &gt; </td></tr>
<tr class="memitem:a847fcdaa3319e19b7f8539da7758ca88"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a847fcdaa3319e19b7f8539da7758ca88">compute_basis_function_value</a> (size_t k, const T &amp;x)</td></tr>
<tr class="memdesc:a847fcdaa3319e19b7f8539da7758ca88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the function values of the basis function \(\Phi_k(x)\) (zero-indexed). <br /></td></tr>
<tr class="separator:a847fcdaa3319e19b7f8539da7758ca88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e394660b1504c1a8fc36231476ed41f"><td class="memTemplParams" colspan="2"><a id="a7e394660b1504c1a8fc36231476ed41f"></a>
template&lt;Basis &gt; </td></tr>
<tr class="memitem:a7e394660b1504c1a8fc36231476ed41f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a7e394660b1504c1a8fc36231476ed41f">compute_inverse_weight_function_values</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;)</td></tr>
<tr class="memdesc:a7e394660b1504c1a8fc36231476ed41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of the weight function \(w(x)\) w.r.t. which the basis functions are orthogonal. See the description of <code><a class="el" href="namespaceSpectral.html#a4d88a8b9bb3ad3c8ce3071b8bf529c14" title="Weights to compute definite integrals.">quadrature_weights(size_t)</a></code> for details. <br /></td></tr>
<tr class="separator:a7e394660b1504c1a8fc36231476ed41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fe2e76c5f7976f4b333aaef4e7130c"><td class="memTemplParams" colspan="2"><a id="a77fe2e76c5f7976f4b333aaef4e7130c"></a>
template&lt;Basis BasisType&gt; </td></tr>
<tr class="memitem:a77fe2e76c5f7976f4b333aaef4e7130c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a77fe2e76c5f7976f4b333aaef4e7130c">compute_basis_function_normalization_square</a> (size_t k)</td></tr>
<tr class="memdesc:a77fe2e76c5f7976f4b333aaef4e7130c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalization square of the basis function \(\Phi_k\) (zero-indexed), i.e. the weighted definite integral over its square. <br /></td></tr>
<tr class="separator:a77fe2e76c5f7976f4b333aaef4e7130c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b73b4651ed37edff6450d3af554114"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:a64b73b4651ed37edff6450d3af554114"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a64b73b4651ed37edff6450d3af554114">compute_collocation_points_and_weights</a> (size_t num_points)</td></tr>
<tr class="memdesc:a64b73b4651ed37edff6450d3af554114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the collocation points and weights associated to the basis and quadrature.  <a href="namespaceSpectral.html#a64b73b4651ed37edff6450d3af554114">More...</a><br /></td></tr>
<tr class="separator:a64b73b4651ed37edff6450d3af554114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ef631a3d4a5132a4158ddf27346537"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:a09ef631a3d4a5132a4158ddf27346537"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a09ef631a3d4a5132a4158ddf27346537">collocation_points</a> (size_t num_points)</td></tr>
<tr class="memdesc:a09ef631a3d4a5132a4158ddf27346537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collocation points.  <a href="namespaceSpectral.html#a09ef631a3d4a5132a4158ddf27346537">More...</a><br /></td></tr>
<tr class="separator:a09ef631a3d4a5132a4158ddf27346537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af153197d0ae3dafebbfc9708403ee9dd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#af153197d0ae3dafebbfc9708403ee9dd">collocation_points</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh)</td></tr>
<tr class="memdesc:af153197d0ae3dafebbfc9708403ee9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collocation points for a one-dimensional mesh.  <a href="namespaceSpectral.html#af153197d0ae3dafebbfc9708403ee9dd">More...</a><br /></td></tr>
<tr class="separator:af153197d0ae3dafebbfc9708403ee9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d88a8b9bb3ad3c8ce3071b8bf529c14"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:a4d88a8b9bb3ad3c8ce3071b8bf529c14"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a4d88a8b9bb3ad3c8ce3071b8bf529c14">quadrature_weights</a> (size_t num_points)</td></tr>
<tr class="memdesc:a4d88a8b9bb3ad3c8ce3071b8bf529c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights to compute definite integrals.  <a href="namespaceSpectral.html#a4d88a8b9bb3ad3c8ce3071b8bf529c14">More...</a><br /></td></tr>
<tr class="separator:a4d88a8b9bb3ad3c8ce3071b8bf529c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69e37093fb49fac7b75a14faefe7705"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#ad69e37093fb49fac7b75a14faefe7705">quadrature_weights</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ad69e37093fb49fac7b75a14faefe7705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quadrature weights for a one-dimensional mesh.  <a href="namespaceSpectral.html#ad69e37093fb49fac7b75a14faefe7705">More...</a><br /></td></tr>
<tr class="separator:ad69e37093fb49fac7b75a14faefe7705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5624836eb75a5903cb1a2b63d2152b6"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:ac5624836eb75a5903cb1a2b63d2152b6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#ac5624836eb75a5903cb1a2b63d2152b6">differentiation_matrix</a> (size_t num_points)</td></tr>
<tr class="memdesc:ac5624836eb75a5903cb1a2b63d2152b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to compute the derivative of a function.  <a href="namespaceSpectral.html#ac5624836eb75a5903cb1a2b63d2152b6">More...</a><br /></td></tr>
<tr class="separator:ac5624836eb75a5903cb1a2b63d2152b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af0b282bf3f80f1c25e92241104196e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a6af0b282bf3f80f1c25e92241104196e">differentiation_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh)</td></tr>
<tr class="memdesc:a6af0b282bf3f80f1c25e92241104196e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Differentiation matrix for a one-dimensional mesh.  <a href="namespaceSpectral.html#a6af0b282bf3f80f1c25e92241104196e">More...</a><br /></td></tr>
<tr class="separator:a6af0b282bf3f80f1c25e92241104196e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad536bc470b570e28015795de20b9aa9d"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:ad536bc470b570e28015795de20b9aa9d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#ad536bc470b570e28015795de20b9aa9d">weak_flux_differentiation_matrix</a> (size_t num_points)</td></tr>
<tr class="memdesc:ad536bc470b570e28015795de20b9aa9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to compute the divergence of the flux in weak form.  <a href="namespaceSpectral.html#ad536bc470b570e28015795de20b9aa9d">More...</a><br /></td></tr>
<tr class="separator:ad536bc470b570e28015795de20b9aa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9c9e62ddf450d869eb06fc437cbc80"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#afd9c9e62ddf450d869eb06fc437cbc80">weak_flux_differentiation_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh)</td></tr>
<tr class="memdesc:afd9c9e62ddf450d869eb06fc437cbc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to compute the divergence of the flux in weak form.  <a href="namespaceSpectral.html#afd9c9e62ddf450d869eb06fc437cbc80">More...</a><br /></td></tr>
<tr class="separator:afd9c9e62ddf450d869eb06fc437cbc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553a3425a58318d0feead9dda4b4c488"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:a553a3425a58318d0feead9dda4b4c488"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a553a3425a58318d0feead9dda4b4c488">integration_matrix</a> (size_t num_points)</td></tr>
<tr class="memdesc:a553a3425a58318d0feead9dda4b4c488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to perform an indefinite integral of a function over the logical grid. The left boundary condition is such that the integral is 0 at \(\xi=-1\)  <a href="namespaceSpectral.html#a553a3425a58318d0feead9dda4b4c488">More...</a><br /></td></tr>
<tr class="separator:a553a3425a58318d0feead9dda4b4c488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806c47a76aa319ece2adfa73ae679fde"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a806c47a76aa319ece2adfa73ae679fde">integration_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh)</td></tr>
<tr class="memdesc:a806c47a76aa319ece2adfa73ae679fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indefinite integration matrix for a one-dimensional mesh.  <a href="namespaceSpectral.html#a806c47a76aa319ece2adfa73ae679fde">More...</a><br /></td></tr>
<tr class="separator:a806c47a76aa319ece2adfa73ae679fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75d175cf6d52b0e07daf2e8e831ca50"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType, typename T &gt; </td></tr>
<tr class="memitem:ae75d175cf6d52b0e07daf2e8e831ca50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#ae75d175cf6d52b0e07daf2e8e831ca50">interpolation_matrix</a> (size_t num_points, const T &amp;target_points)</td></tr>
<tr class="memdesc:ae75d175cf6d52b0e07daf2e8e831ca50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to interpolate to the <code>target_points</code>.  <a href="namespaceSpectral.html#ae75d175cf6d52b0e07daf2e8e831ca50">More...</a><br /></td></tr>
<tr class="separator:ae75d175cf6d52b0e07daf2e8e831ca50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe804f85f89b43fe2e8ed5a1447194ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe804f85f89b43fe2e8ed5a1447194ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#afe804f85f89b43fe2e8ed5a1447194ed">interpolation_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh, const T &amp;target_points)</td></tr>
<tr class="memdesc:afe804f85f89b43fe2e8ed5a1447194ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolation matrix to the <code>target_points</code> for a one-dimensional mesh.  <a href="namespaceSpectral.html#afe804f85f89b43fe2e8ed5a1447194ed">More...</a><br /></td></tr>
<tr class="separator:afe804f85f89b43fe2e8ed5a1447194ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af429e9dd3493dc1b472f1787f49b880d"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:af429e9dd3493dc1b472f1787f49b880d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#af429e9dd3493dc1b472f1787f49b880d">modal_to_nodal_matrix</a> (size_t num_points)</td></tr>
<tr class="memdesc:af429e9dd3493dc1b472f1787f49b880d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficients. Also referred to as the <em>Vandermonde matrix</em>.  <a href="namespaceSpectral.html#af429e9dd3493dc1b472f1787f49b880d">More...</a><br /></td></tr>
<tr class="separator:af429e9dd3493dc1b472f1787f49b880d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e6610729d071fad37ffecf0c49930d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a95e6610729d071fad37ffecf0c49930d">modal_to_nodal_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh)</td></tr>
<tr class="memdesc:a95e6610729d071fad37ffecf0c49930d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation matrix from modal to nodal coefficients for a one-dimensional mesh.  <a href="namespaceSpectral.html#a95e6610729d071fad37ffecf0c49930d">More...</a><br /></td></tr>
<tr class="separator:a95e6610729d071fad37ffecf0c49930d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2970df2506f321ea8d41ff826583b1"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:acf2970df2506f321ea8d41ff826583b1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#acf2970df2506f321ea8d41ff826583b1">nodal_to_modal_matrix</a> (size_t num_points)</td></tr>
<tr class="memdesc:acf2970df2506f321ea8d41ff826583b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to transform from the nodal coefficients of a function to its spectral coefficients (modes). Also referred to as the inverse <em>Vandermonde matrix</em>.  <a href="namespaceSpectral.html#acf2970df2506f321ea8d41ff826583b1">More...</a><br /></td></tr>
<tr class="separator:acf2970df2506f321ea8d41ff826583b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139e8255c7876a8d47337f9b0f59eda3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a139e8255c7876a8d47337f9b0f59eda3">nodal_to_modal_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh)</td></tr>
<tr class="memdesc:a139e8255c7876a8d47337f9b0f59eda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation matrix from nodal to modal coefficients for a one-dimensional mesh.  <a href="namespaceSpectral.html#a139e8255c7876a8d47337f9b0f59eda3">More...</a><br /></td></tr>
<tr class="separator:a139e8255c7876a8d47337f9b0f59eda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac324fab3f659f99d836db4f97171c0e"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:aac324fab3f659f99d836db4f97171c0e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#aac324fab3f659f99d836db4f97171c0e">linear_filter_matrix</a> (size_t num_points)</td></tr>
<tr class="memdesc:aac324fab3f659f99d836db4f97171c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to linearize a function.  <a href="namespaceSpectral.html#aac324fab3f659f99d836db4f97171c0e">More...</a><br /></td></tr>
<tr class="separator:aac324fab3f659f99d836db4f97171c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add023746c5027d26aad2fc0ad4c482a7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#add023746c5027d26aad2fc0ad4c482a7">linear_filter_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh)</td></tr>
<tr class="memdesc:add023746c5027d26aad2fc0ad4c482a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear filter matrix for a one-dimensional mesh.  <a href="namespaceSpectral.html#add023746c5027d26aad2fc0ad4c482a7">More...</a><br /></td></tr>
<tr class="separator:add023746c5027d26aad2fc0ad4c482a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aadbd6975e1d12230cf4b37a909235e21"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classMatrix.html">Matrix</a>, <a class="el" href="classMatrix.html">Matrix</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#aadbd6975e1d12230cf4b37a909235e21">boundary_interpolation_matrices</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh)</td></tr>
<tr class="memdesc:aadbd6975e1d12230cf4b37a909235e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrices that interpolate to the lower and upper boundaries of the element.  <a href="namespaceSpectral.html#aadbd6975e1d12230cf4b37a909235e21">More...</a><br /></td></tr>
<tr class="separator:aadbd6975e1d12230cf4b37a909235e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64ddfa0b2548b2dd2909328142680a8"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:ab64ddfa0b2548b2dd2909328142680a8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classMatrix.html">Matrix</a>, <a class="el" href="classMatrix.html">Matrix</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#ab64ddfa0b2548b2dd2909328142680a8">boundary_interpolation_matrices</a> (size_t num_points)</td></tr>
<tr class="memdesc:ab64ddfa0b2548b2dd2909328142680a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrices that interpolate to the lower and upper boundaries of the element.  <a href="namespaceSpectral.html#ab64ddfa0b2548b2dd2909328142680a8">More...</a><br /></td></tr>
<tr class="separator:ab64ddfa0b2548b2dd2909328142680a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6753675b6ceba30af27644591d81947f"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a6753675b6ceba30af27644591d81947f">boundary_interpolation_term</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh)</td></tr>
<tr class="memdesc:a6753675b6ceba30af27644591d81947f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates values from the boundary into the volume, which is needed when applying time derivative or Bjorhus-type boundary conditions in a discontinuous Galerkin scheme using Gauss points.  <a href="namespaceSpectral.html#a6753675b6ceba30af27644591d81947f">More...</a><br /></td></tr>
<tr class="separator:a6753675b6ceba30af27644591d81947f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944ba55510898c7cbd9b35802484f33f"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:a944ba55510898c7cbd9b35802484f33f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a944ba55510898c7cbd9b35802484f33f">boundary_interpolation_term</a> (size_t num_points)</td></tr>
<tr class="memdesc:a944ba55510898c7cbd9b35802484f33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates values from the boundary into the volume, which is needed when applying time derivative or Bjorhus-type boundary conditions in a discontinuous Galerkin scheme using Gauss points.  <a href="namespaceSpectral.html#a944ba55510898c7cbd9b35802484f33f">More...</a><br /></td></tr>
<tr class="separator:a944ba55510898c7cbd9b35802484f33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3d25584dc92548020581dd3b5f02831c"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a3d25584dc92548020581dd3b5f02831c">boundary_lifting_term</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh)</td></tr>
<tr class="memdesc:a3d25584dc92548020581dd3b5f02831c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terms used during the lifting portion of a discontinuous Galerkin scheme when using Gauss points.  <a href="namespaceSpectral.html#a3d25584dc92548020581dd3b5f02831c">More...</a><br /></td></tr>
<tr class="separator:a3d25584dc92548020581dd3b5f02831c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30c85613539fbbb4a8c75e5155dba9e"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:ae30c85613539fbbb4a8c75e5155dba9e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#ae30c85613539fbbb4a8c75e5155dba9e">boundary_lifting_term</a> (size_t num_points)</td></tr>
<tr class="memdesc:ae30c85613539fbbb4a8c75e5155dba9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terms used during the lifting portion of a discontinuous Galerkin scheme when using Gauss points.  <a href="namespaceSpectral.html#ae30c85613539fbbb4a8c75e5155dba9e">More...</a><br /></td></tr>
<tr class="separator:ae30c85613539fbbb4a8c75e5155dba9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7ed70608b007d26c6e7bf23ea14e8357"><td class="memTemplParams" colspan="2">template&lt;Basis basis, Quadrature quadrature&gt; </td></tr>
<tr class="memitem:a7ed70608b007d26c6e7bf23ea14e8357"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a7ed70608b007d26c6e7bf23ea14e8357">minimum_number_of_points</a></td></tr>
<tr class="memdesc:a7ed70608b007d26c6e7bf23ea14e8357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum number of possible collocation points for a quadrature type.  <a href="namespaceSpectral.html#a7ed70608b007d26c6e7bf23ea14e8357">More...</a><br /></td></tr>
<tr class="separator:a7ed70608b007d26c6e7bf23ea14e8357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f83fd18f48d47423e1d5cf9d718a7a"><td class="memTemplParams" colspan="2">template&lt;Basis basis&gt; </td></tr>
<tr class="memitem:ad3f83fd18f48d47423e1d5cf9d718a7a"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#ad3f83fd18f48d47423e1d5cf9d718a7a">maximum_number_of_points</a></td></tr>
<tr class="memdesc:ad3f83fd18f48d47423e1d5cf9d718a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of allowed collocation points.  <a href="namespaceSpectral.html#ad3f83fd18f48d47423e1d5cf9d718a7a">More...</a><br /></td></tr>
<tr class="separator:ad3f83fd18f48d47423e1d5cf9d718a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functionality associated with a particular choice of basis functions and quadrature for spectral operations. </p>
<h3>Details</h3>
<p>The functions in this namespace provide low-level access to collocation points, quadrature weights and associated matrices, such as for differentiation and interpolation. They are available in two versions: either templated directly on the enum cases of the <a class="el" href="group__SpectralGroup.html#ga37c9c17d05dccca652060d117f72ee21" title="The choice of basis functions for computing collocation points and weights.">Spectral::Basis</a> and <a class="el" href="group__SpectralGroup.html#ga7744e520f6d553caf358a6f09f5978c1" title="The choice of quadrature method to compute integration weights.">Spectral::Quadrature</a> types, or taking a one-dimensional <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a> as their argument.</p>
<dl class="section note"><dt>Note</dt><dd>Generally you should prefer working with a <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a>. Use its <a class="el" href="classMesh.html#a5be3ff1838e9b940fa6c39187009edba" title="Returns a Mesh with the dimensions d, ... present (zero-indexed).">Mesh::slice_through()</a> method to retrieve the mesh in a particular dimension: <div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classMesh.html">Mesh&lt;2&gt;</a> mesh2d{</div>
<div class="line">      {{3, 4}},</div>
<div class="line">      {{Spectral::Basis::Legendre, Spectral::Basis::Legendre}},</div>
<div class="line">      {{Spectral::Quadrature::Gauss, Spectral::Quadrature::GaussLobatto}}};</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> collocation_points_in_first_dim =</div>
<div class="line">      <a class="code" href="namespaceSpectral.html#a09ef631a3d4a5132a4158ddf27346537">Spectral::collocation_points</a>(mesh2d.slice_through(0));</div>
<div class="ttc" id="aclassMesh_html"><div class="ttname"><a href="classMesh.html">Mesh</a></div><div class="ttdoc">Holds the number of grid points, basis, and quadrature in each direction of the computational grid.</div><div class="ttdef"><b>Definition:</b> Mesh.hpp:49</div></div>
<div class="ttc" id="anamespaceSpectral_html_a09ef631a3d4a5132a4158ddf27346537"><div class="ttname"><a href="namespaceSpectral.html#a09ef631a3d4a5132a4158ddf27346537">Spectral::collocation_points</a></div><div class="ttdeci">const DataVector &amp; collocation_points(size_t num_points)</div><div class="ttdoc">Collocation points.</div></div>
</div><!-- fragment --></dd></dl>
<p>Most algorithms in this namespace are adapted from <b>[Kopriva]</b>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aadbd6975e1d12230cf4b37a909235e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbd6975e1d12230cf4b37a909235e21">&#9670;&nbsp;</a></span>boundary_interpolation_matrices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="classMatrix.html">Matrix</a>, <a class="el" href="classMatrix.html">Matrix</a>&gt;&amp; Spectral::boundary_interpolation_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrices that interpolate to the lower and upper boundaries of the element. </p>
<p>Assumes that the logical coordinates are \([-1, 1]\). The first element of the pair interpolates to \(\xi=-1\) and the second to \(\xi=1\). These are just the Lagrange interpolating polynomials evaluated at \(\xi=\pm1\). For Gauss-Lobatto points the only non-zero element is at the boundaries and is one and so is not implemented.</p>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called with Gauss points. </dd></dl>

</div>
</div>
<a id="ab64ddfa0b2548b2dd2909328142680a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64ddfa0b2548b2dd2909328142680a8">&#9670;&nbsp;</a></span>boundary_interpolation_matrices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="classMatrix.html">Matrix</a>, <a class="el" href="classMatrix.html">Matrix</a>&gt;&amp; Spectral::boundary_interpolation_matrices </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrices that interpolate to the lower and upper boundaries of the element. </p>
<p>Assumes that the logical coordinates are \([-1, 1]\). The first element of the pair interpolates to \(\xi=-1\) and the second to \(\xi=1\). These are just the Lagrange interpolating polynomials evaluated at \(\xi=\pm1\). For Gauss-Lobatto points the only non-zero element is at the boundaries and is one and so is not implemented.</p>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called with Gauss points. </dd></dl>

</div>
</div>
<a id="a6753675b6ceba30af27644591d81947f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6753675b6ceba30af27644591d81947f">&#9670;&nbsp;</a></span>boundary_interpolation_term() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a>&gt;&amp; Spectral::boundary_interpolation_term </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates values from the boundary into the volume, which is needed when applying time derivative or Bjorhus-type boundary conditions in a discontinuous Galerkin scheme using Gauss points. </p>
<p>Assumes that the logical coordinates are \([-1, 1]\). The interpolation is done by assuming the time derivative correction is zero on interior nodes. With a nodal Lagrange polynomial basis this means that only the \(\ell^{\mathrm{Gauss-Lobatto}}_{0}\) and \(\ell^{\mathrm{Gauss-Lobatto}}_{N}\) polynomials/basis functions contribute to the correction. In order to interpolate the correction from the nodes at the boundary, the Gauss-Lobatto Lagrange polynomials must be evaluated at the Gauss grid points. The returned pair of <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>s stores</p>
<p class="formulaDsp">
\begin{align*} &amp;\ell^{\mathrm{Gauss-Lobatto}}_{0}(\xi_j^{\mathrm{Gauss}}), \\ &amp;\ell^{\mathrm{Gauss-Lobatto}}_{N}(\xi_j^{\mathrm{Gauss}}). \end{align*}
</p>
<p>This is a different correction from lifting. Lifting is done using the mass matrix, which is an integral over the basis functions, while here we use interpolation.</p>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called with Gauss points. </dd></dl>

</div>
</div>
<a id="a944ba55510898c7cbd9b35802484f33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944ba55510898c7cbd9b35802484f33f">&#9670;&nbsp;</a></span>boundary_interpolation_term() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a>&gt;&amp; Spectral::boundary_interpolation_term </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates values from the boundary into the volume, which is needed when applying time derivative or Bjorhus-type boundary conditions in a discontinuous Galerkin scheme using Gauss points. </p>
<p>Assumes that the logical coordinates are \([-1, 1]\). The interpolation is done by assuming the time derivative correction is zero on interior nodes. With a nodal Lagrange polynomial basis this means that only the \(\ell^{\mathrm{Gauss-Lobatto}}_{0}\) and \(\ell^{\mathrm{Gauss-Lobatto}}_{N}\) polynomials/basis functions contribute to the correction. In order to interpolate the correction from the nodes at the boundary, the Gauss-Lobatto Lagrange polynomials must be evaluated at the Gauss grid points. The returned pair of <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>s stores</p>
<p class="formulaDsp">
\begin{align*} &amp;\ell^{\mathrm{Gauss-Lobatto}}_{0}(\xi_j^{\mathrm{Gauss}}), \\ &amp;\ell^{\mathrm{Gauss-Lobatto}}_{N}(\xi_j^{\mathrm{Gauss}}). \end{align*}
</p>
<p>This is a different correction from lifting. Lifting is done using the mass matrix, which is an integral over the basis functions, while here we use interpolation.</p>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called with Gauss points. </dd></dl>

</div>
</div>
<a id="a3d25584dc92548020581dd3b5f02831c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d25584dc92548020581dd3b5f02831c">&#9670;&nbsp;</a></span>boundary_lifting_term() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a>&gt;&amp; Spectral::boundary_lifting_term </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terms used during the lifting portion of a discontinuous Galerkin scheme when using Gauss points. </p>
<p>Assumes that the logical coordinates are \([-1, 1]\). The first element of the pair is the Lagrange polyonmials evaluated at \(\xi=-1\) divided by the weights and the second at \(\xi=1\). Specifically,</p>
<p class="formulaDsp">
\begin{align*} \frac{\ell_j(\xi=\pm1)}{w_j} \end{align*}
</p>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called with Gauss points. </dd></dl>

</div>
</div>
<a id="ae30c85613539fbbb4a8c75e5155dba9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30c85613539fbbb4a8c75e5155dba9e">&#9670;&nbsp;</a></span>boundary_lifting_term() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a>&gt;&amp; Spectral::boundary_lifting_term </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terms used during the lifting portion of a discontinuous Galerkin scheme when using Gauss points. </p>
<p>Assumes that the logical coordinates are \([-1, 1]\). The first element of the pair is the Lagrange polyonmials evaluated at \(\xi=-1\) divided by the weights and the second at \(\xi=1\). Specifically,</p>
<p class="formulaDsp">
\begin{align*} \frac{\ell_j(\xi=\pm1)}{w_j} \end{align*}
</p>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called with Gauss points. </dd></dl>

</div>
</div>
<a id="af153197d0ae3dafebbfc9708403ee9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af153197d0ae3dafebbfc9708403ee9dd">&#9670;&nbsp;</a></span>collocation_points() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDataVector.html">DataVector</a>&amp; Spectral::collocation_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collocation points for a one-dimensional mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#a09ef631a3d4a5132a4158ddf27346537" title="Collocation points.">collocation_points(size_t)</a> </dd></dl>

</div>
</div>
<a id="a09ef631a3d4a5132a4158ddf27346537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ef631a3d4a5132a4158ddf27346537">&#9670;&nbsp;</a></span>collocation_points() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDataVector.html">DataVector</a>&amp; Spectral::collocation_points </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collocation points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64b73b4651ed37edff6450d3af554114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b73b4651ed37edff6450d3af554114">&#9670;&nbsp;</a></span>compute_collocation_points_and_weights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a>&gt; Spectral::compute_collocation_points_and_weights </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the collocation points and weights associated to the basis and quadrature. </p>
<h3>Details</h3>
<p>This function is expected to return the tuple \((\xi_k,w_k)\) where the \(\xi_k\) are the collocation points and the \(w_k\) are defined in the description of <code><a class="el" href="namespaceSpectral.html#a4d88a8b9bb3ad3c8ce3071b8bf529c14" title="Weights to compute definite integrals.">quadrature_weights(size_t)</a></code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>for a <code>FiniteDifference</code> basis or <code>CellCentered</code> and <code>FaceCentered</code> quadratures only the collocation points are set, the weights are <code>NaN</code>. </dd></dl>

</div>
</div>
<a id="a6af0b282bf3f80f1c25e92241104196e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af0b282bf3f80f1c25e92241104196e">&#9670;&nbsp;</a></span>differentiation_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::differentiation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Differentiation matrix for a one-dimensional mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#ac5624836eb75a5903cb1a2b63d2152b6" title="Matrix used to compute the derivative of a function.">differentiation_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="ac5624836eb75a5903cb1a2b63d2152b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5624836eb75a5903cb1a2b63d2152b6">&#9670;&nbsp;</a></span>differentiation_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::differentiation_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix used to compute the derivative of a function. </p>
<h3>Details</h3>
<p>For a function represented by the nodal coefficients \(u_j\) a matrix multiplication with the differentiation matrix \(D_{ij}\) gives the coefficients of the function's derivative. Since \(u(x)\) is expanded in Lagrange polynomials \(u(x)=\sum_j u_j l_j(x)\) the differentiation matrix is computed as \(D_{ij}=l_j^\prime(\xi_i)\) where the \(\xi_i\) are the collocation points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a806c47a76aa319ece2adfa73ae679fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806c47a76aa319ece2adfa73ae679fde">&#9670;&nbsp;</a></span>integration_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::integration_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indefinite integration matrix for a one-dimensional mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#a553a3425a58318d0feead9dda4b4c488" title="Matrix used to perform an indefinite integral of a function over the logical grid....">integration_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="a553a3425a58318d0feead9dda4b4c488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553a3425a58318d0feead9dda4b4c488">&#9670;&nbsp;</a></span>integration_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::integration_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix used to perform an indefinite integral of a function over the logical grid. The left boundary condition is such that the integral is 0 at \(\xi=-1\) </p>
<p>Currently only Legendre and Chebyshev polynomials are implemented, but we provide a derivation for how to compute the indefinite integration matrix for general Jacobi polynomials.</p>
<h4><a class="anchor" id="autotoc_md307"></a>
Legendre Polynomials</h4>
<p>The Legendre polynomials have the identity:</p>
<p class="formulaDsp">
\begin{align*} P_n(x) = \frac{1}{2n+1}\frac{d}{dx}\left(P_{n+1}(x) - P_{n-1}(x)\right) \end{align*}
</p>
<p>The goal is to evaluate the integral of a function \(u\) expanded in terms of Legendre polynomials as</p>
<p class="formulaDsp">
\begin{align*} u(x) = \sum_{i=0}^{N} c_i P_i(x) \end{align*}
</p>
<p>We similarly expand the indefinite integral of \(u\) as</p>
<p class="formulaDsp">
\begin{align*} \left.\int u(y) dy\right\rvert_{x}=&amp;\sum_{i=0}^N \tilde{c}_i P_i(x) \\ =&amp;\left.\int\sum_{i=1}^{N}\frac{c_i}{2i+1} \left(P_{i+1}(y)-P_{i-1}(y)\right)dy\right\rvert_{x} + \tilde{c}_0 P_0(x) \\ =&amp;\sum_{i=1}^{N}\left(\frac{c_{i-1}}{2i-1} - \frac{c_{i+1}}{2i+3}\right) P_i(x) + \tilde{c}_0 P_0(x) \end{align*}
</p>
<p>Thus we get that for \(i&gt;0\)</p>
<p class="formulaDsp">
\begin{align*} \tilde{c}_i=\frac{c_{i-1}}{2i-1}-\frac{c_{i+1}}{2i+3} \end{align*}
</p>
<p>and \(\tilde{c}_0\) is a constant of integration, which we choose such that the integral is 0 at the left boundary of the domain ( \(x=-1\)). The condition for this is:</p>
<p class="formulaDsp">
\begin{align*} \tilde{c}_0=\sum_{i=1}^{N}(-1)^{i+1}\tilde{c}_i \end{align*}
</p>
<p>The matrix returned by this function is the product of the tridiagonal matrix for the \(\tilde{c}_i\) and the matrix for the boundary condition.</p>
<h4><a class="anchor" id="autotoc_md308"></a>
Chebyshev Polynomials</h4>
<p>A similar derivation leads to the relations:</p>
<p class="formulaDsp">
\begin{align*} \tilde{c}_i=&amp;\frac{c_{i-1}-c_{i+1}}{2i},&amp;\mathrm{if}\;i&gt;1 \\ \tilde{c}_1=&amp;c_0 - \frac{c_2}{2},&amp;\mathrm{if}\;i=1 \\ \end{align*}
</p>
<p>We again have:</p>
<p class="formulaDsp">
\begin{align*} \tilde{c}_0=\sum_{i=1}^N(-1)^{i+1}\tilde{c}_i \end{align*}
</p>
<p>These are then used to define the indefinite integration matrix.</p>
<h4><a class="anchor" id="autotoc_md309"></a>
Jacobi Polynomials</h4>
<p>For general Jacobi polynomials \(P^{(\alpha,\beta)}_n(x)\) given by</p>
<p class="formulaDsp">
\begin{align*} (1-x)^\alpha(1+x)^\beta P^{(\alpha,\beta)}_n(x)=\frac{(-1)^n}{2^n n!} \frac{d^n}{dx^n}\left[(1-x)^{\alpha+n}(1+x)^{\beta+n}\right] \end{align*}
</p>
<p>we have that</p>
<p class="formulaDsp">
\begin{align*} P^{(\alpha,\beta)}_n(x)=\frac{d}{dx}\left( b^{(\alpha,\beta)}_{n-1,n}P^{(\alpha,\beta)}_{n-1}(x) + b^{(\alpha,\beta)}_{n,n}P^{(\alpha,\beta)}_n(x) + b^{(\alpha,\beta)}_{n+1,n}P^{(\alpha,\beta)}_{n+1}(x) \right) \end{align*}
</p>
<p>where</p>
<p class="formulaDsp">
\begin{align*} b^{(\alpha,\beta)}_{n-1,n}=&amp;-\frac{1}{n+\alpha+\beta} a^{(\alpha,\beta)}_{n-1,n} \\ b^{(\alpha,\beta)}_{n,n}=&amp;-\frac{2}{\alpha+\beta} a^{(\alpha,\beta)}_{n,n} \\ b^{(\alpha,\beta)}_{n+1,n}=&amp;\frac{1}{n+1} a^{(\alpha,\beta)}_{n+1,n} \\ a^{(\alpha,\beta)}_{n-1,n}=&amp;\frac{2(n+\alpha)(n+\beta)} {(2n+\alpha+\beta+1)(2n+\alpha+\beta)} \\ a^{(\alpha,\beta)}_{n,n}=&amp;-\frac{\alpha^2-\beta^2} {(2n+\alpha+\beta+2)(2n+\alpha+\beta)} \\ a^{(\alpha,\beta)}_{n-1,n}=&amp;\frac{2(n+1)(n+\alpha+\beta+1)} {(2n+\alpha+\beta+2)(2n+\alpha+\beta+1)} \end{align*}
</p>
<p>Following the same derivation we get that</p>
<p class="formulaDsp">
\begin{align*} \tilde{c}_i=c_{i+1}b^{(\alpha,\beta)}_{i,i+1} +c_i b^{(\alpha,\beta)}_{i,i} +c_{i-1}b^{(\alpha,\beta)}_{i,i-1} \end{align*}
</p>
<p>and the boundary condition is</p>
<p class="formulaDsp">
\begin{align*} \tilde{c}_0=\sum_{i=1}^N(-1)^{i+1} \frac{\Gamma(i+\alpha+1)}{i!\Gamma(\alpha+1)} \tilde{c}_i \end{align*}
</p>
<p>where \(\Gamma(x)\) is the Gamma function. </p>

</div>
</div>
<a id="afe804f85f89b43fe2e8ed5a1447194ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe804f85f89b43fe2e8ed5a1447194ed">&#9670;&nbsp;</a></span>interpolation_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> Spectral::interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>target_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolation matrix to the <code>target_points</code> for a one-dimensional mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#ae75d175cf6d52b0e07daf2e8e831ca50" title="Matrix used to interpolate to the target_points.">interpolation_matrix(size_t, const T&amp;)</a> </dd></dl>

</div>
</div>
<a id="ae75d175cf6d52b0e07daf2e8e831ca50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75d175cf6d52b0e07daf2e8e831ca50">&#9670;&nbsp;</a></span>interpolation_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> Spectral::interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>target_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix used to interpolate to the <code>target_points</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>For each target point located outside of the logical coordinate interval covered by <code>BasisType</code> (often \([-1,1]\)), the resulting matrix performs polynomial extrapolation instead of interpolation. The extrapolation will be correct but may suffer from reduced accuracy, especially for higher-order polynomials (i.e., larger values of <code>num_points</code>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points </td></tr>
    <tr><td class="paramname">target_points</td><td>The points to interpolate to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add023746c5027d26aad2fc0ad4c482a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add023746c5027d26aad2fc0ad4c482a7">&#9670;&nbsp;</a></span>linear_filter_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::linear_filter_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linear filter matrix for a one-dimensional mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#aac324fab3f659f99d836db4f97171c0e" title="Matrix used to linearize a function.">linear_filter_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="aac324fab3f659f99d836db4f97171c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac324fab3f659f99d836db4f97171c0e">&#9670;&nbsp;</a></span>linear_filter_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::linear_filter_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix used to linearize a function. </p>
<h3>Details</h3>
<p>Filters out all except the lowest two modes by applying \(\mathcal{V}^{-1}\cdot\mathrm{diag}(1,1,0,0,...)\cdot\mathcal{V}\) to the nodal coefficients, where \(\mathcal{V}\) is the Vandermonde matrix computed in <code><a class="el" href="namespaceSpectral.html#af429e9dd3493dc1b472f1787f49b880d" title="Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficien...">modal_to_nodal_matrix(size_t)</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#af429e9dd3493dc1b472f1787f49b880d" title="Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficien...">modal_to_nodal_matrix(size_t)</a> </dd>
<dd>
<a class="el" href="namespaceSpectral.html#acf2970df2506f321ea8d41ff826583b1" title="Matrix used to transform from the nodal coefficients of a function to its spectral coefficients (mode...">nodal_to_modal_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="a95e6610729d071fad37ffecf0c49930d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e6610729d071fad37ffecf0c49930d">&#9670;&nbsp;</a></span>modal_to_nodal_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::modal_to_nodal_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transformation matrix from modal to nodal coefficients for a one-dimensional mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#af429e9dd3493dc1b472f1787f49b880d" title="Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficien...">modal_to_nodal_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="af429e9dd3493dc1b472f1787f49b880d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af429e9dd3493dc1b472f1787f49b880d">&#9670;&nbsp;</a></span>modal_to_nodal_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::modal_to_nodal_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficients. Also referred to as the <em>Vandermonde matrix</em>. </p>
<h3>Details</h3>
<p>The Vandermonde matrix is computed as \(\mathcal{V}_{ij}=\Phi_j(\xi_i)\) where the \(\Phi_j(x)\) are the spectral basis functions used in the modal expansion \(u(x)=\sum_j \widetilde{u}_j\Phi_j(x)\), e.g. normalized Legendre polynomials, and the \(\xi_i\) are the collocation points used to construct the interpolating Lagrange polynomials in the nodal expansion \(u(x)=\sum_j u_j l_j(x)\). Then the Vandermonde matrix arises as \(u(\xi_i)=u_i=\sum_j \widetilde{u}_j\Phi_j(\xi_i)=\sum_j \mathcal{V}_{ij}\widetilde{u}_j\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#acf2970df2506f321ea8d41ff826583b1" title="Matrix used to transform from the nodal coefficients of a function to its spectral coefficients (mode...">nodal_to_modal_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="a139e8255c7876a8d47337f9b0f59eda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139e8255c7876a8d47337f9b0f59eda3">&#9670;&nbsp;</a></span>nodal_to_modal_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::nodal_to_modal_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transformation matrix from nodal to modal coefficients for a one-dimensional mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#acf2970df2506f321ea8d41ff826583b1" title="Matrix used to transform from the nodal coefficients of a function to its spectral coefficients (mode...">nodal_to_modal_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="acf2970df2506f321ea8d41ff826583b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2970df2506f321ea8d41ff826583b1">&#9670;&nbsp;</a></span>nodal_to_modal_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::nodal_to_modal_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix used to transform from the nodal coefficients of a function to its spectral coefficients (modes). Also referred to as the inverse <em>Vandermonde matrix</em>. </p>
<h3>Details</h3>
<p>This is the inverse to the Vandermonde matrix \(\mathcal{V}\) computed in <a class="el" href="namespaceSpectral.html#af429e9dd3493dc1b472f1787f49b880d" title="Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficien...">modal_to_nodal_matrix(size_t)</a>. It can be computed analytically for Gauss quadrature by evaluating \(\sum_j\mathcal{V}^{-1}_{ij}u_j=\widetilde{u}_i= \frac{(u,\Phi_i)}{\gamma_i}\) for a Lagrange basis function \(u(x)=l_k(x)\) to find \(\mathcal{V}^{-1}_{ij}=\mathcal{V}_{ji}\frac{w_j}{\gamma_i}\) where the \(w_j\) are the Gauss quadrature weights and \(\gamma_i\) is the norm square of the spectral basis function \(\Phi_i\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#af429e9dd3493dc1b472f1787f49b880d" title="Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficien...">modal_to_nodal_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="a1ece319cd1c9031f9b513dc3370087f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ece319cd1c9031f9b513dc3370087f5">&#9670;&nbsp;</a></span>projection_matrix_child_to_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::projection_matrix_child_to_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>child_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSpectral.html#a29a5155276364fffc6ecdaadb0ba3935">ChildSize</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>operand_is_massive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The projection matrix from a child mesh to its parent. </p>
<p>The projection matrices returned by this function (and by <a class="el" href="namespaceSpectral.html#a4b9ce13d144a629adb3abc3e70dbe1fe" title="The projection matrix from a parent mesh to one of its children.">projection_matrix_parent_to_child()</a>) define orthogonal projection operators between the spaces of functions on a parent mesh and its children. These projections are usually the correct way to transfer data between meshes in a mesh-refinement hierarchy, as well as between an element face and its adjacent mortars.</p>
<p>These functions assume that the <code>child_mesh</code> is at least as fine as the <code>parent_mesh</code>, i.e. functions on the <code>parent_mesh</code> can be represented exactly on the <code>child_mesh</code>. In practice this means that functions can be projected to a mortar (the <code>child_mesh</code>) from both adjacent element faces (the <code>parent_mesh</code>) without losing accuracy. Similarly, functions in a mesh-refinement hierarchy don't lose accuracy when an element is split (h-refined). For this reason, the <code>projection_matrix_child_to_parent</code> is sometimes referred to as a "restriction operator" and the <code>projection_matrix_parent_to_child</code> as a "prolongation operator".</p>
<dl class="section user"><dt>Massive quantities</dt><dd>If the quantity that should be projected is not a function over the computational grid but a "massive" residual, i.e. a quantity \(\int_{\Omega_k} f(x) \psi_p(x) \mathrm{d}V\) where \(\psi_p\) are the basis functions on the mesh, then pass <code>true</code> for the parameter <code>operand_is_massive</code> (default is <code>false</code>). The restriction operator for this case is just the transpose of the prolongation operator, i.e. just an interpolation matrix transpose. Note that the "massive" residual already takes the difference in element size between parent and children into account by including a Jacobian in the volume element of the integral.</dd></dl>
<dl class="section user"><dt>Implementation details</dt><dd>The half-interval projections are based on an equation derived by Saul. This shows that the projection from the spectral basis for the entire interval to the spectral basis for the upper half interval is <p class="formulaDsp">
\begin{equation*} T_{jk} = \frac{2 j + 1}{2} 2^j \sum_{n=0}^{j-k} \binom{j}{k+n} \binom{(j + k + n - 1)/2}{j} \frac{(k + n)!^2}{(2 k + n + 1)! n!} \end{equation*}
</p>
 </dd></dl>

</div>
</div>
<a id="a4b9ce13d144a629adb3abc3e70dbe1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9ce13d144a629adb3abc3e70dbe1fe">&#9670;&nbsp;</a></span>projection_matrix_parent_to_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::projection_matrix_parent_to_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>child_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSpectral.html#a29a5155276364fffc6ecdaadb0ba3935">ChildSize</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The projection matrix from a parent mesh to one of its children. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#a1ece319cd1c9031f9b513dc3370087f5" title="The projection matrix from a child mesh to its parent.">projection_matrix_child_to_parent()</a> </dd></dl>

</div>
</div>
<a id="ad69e37093fb49fac7b75a14faefe7705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69e37093fb49fac7b75a14faefe7705">&#9670;&nbsp;</a></span>quadrature_weights() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDataVector.html">DataVector</a>&amp; Spectral::quadrature_weights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quadrature weights for a one-dimensional mesh. </p>
<dl class="section warning"><dt>Warning</dt><dd>for a <code>FiniteDifference</code> basis or <code>CellCentered</code> and <code>FaceCentered</code> quadratures the weights are <code>NaN</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#a4d88a8b9bb3ad3c8ce3071b8bf529c14" title="Weights to compute definite integrals.">quadrature_weights(size_t)</a> </dd></dl>

</div>
</div>
<a id="a4d88a8b9bb3ad3c8ce3071b8bf529c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d88a8b9bb3ad3c8ce3071b8bf529c14">&#9670;&nbsp;</a></span>quadrature_weights() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDataVector.html">DataVector</a>&amp; Spectral::quadrature_weights </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weights to compute definite integrals. </p>
<h3>Details</h3>
<p>These are the coefficients to contract with the nodal function values \(f_k\) to approximate the definite integral \(I[f]=\int f(x)\mathrm{d}x\).</p>
<p>Note that the term <em>quadrature</em> also often refers to the quantity \(Q[f]=\int f(x)w(x)\mathrm{d}x\approx \sum_k f_k w_k\). Here, \(w(x)\) denotes the basis-specific weight function w.r.t. to which the basis functions \(\Phi_k\) are orthogonal, i.e \(\int\Phi_i(x)\Phi_j(x)w(x)=0\) for \(i\neq j\). The weights \(w_k\) approximate this inner product. To approximate the definite integral \(I[f]\) we must employ the coefficients \(\frac{w_k}{w(\xi_k)}\) instead, where the \(\xi_k\) are the collocation points. These are the coefficients this function returns. Only for a unit weight function \(w(x)=1\), i.e. a Legendre basis, is \(I[f]=Q[f]\) so this function returns the \(w_k\) identically.</p>
<dl class="section warning"><dt>Warning</dt><dd>for a <code>FiniteDifference</code> basis or <code>CellCentered</code> and <code>FaceCentered</code> quadratures the weights are <code>NaN</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd9c9e62ddf450d869eb06fc437cbc80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9c9e62ddf450d869eb06fc437cbc80">&#9670;&nbsp;</a></span>weak_flux_differentiation_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::weak_flux_differentiation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix used to compute the divergence of the flux in weak form. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#ad536bc470b570e28015795de20b9aa9d" title="Matrix used to compute the divergence of the flux in weak form.">weak_flux_differentiation_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="ad536bc470b570e28015795de20b9aa9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad536bc470b570e28015795de20b9aa9d">&#9670;&nbsp;</a></span>weak_flux_differentiation_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::weak_flux_differentiation_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix used to compute the divergence of the flux in weak form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad3f83fd18f48d47423e1d5cf9d718a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f83fd18f48d47423e1d5cf9d718a7a">&#9670;&nbsp;</a></span>maximum_number_of_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis basis&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t Spectral::maximum_number_of_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    basis == Basis::FiniteDifference ? 24 : 12</div>
</div><!-- fragment -->
<p>Maximum number of allowed collocation points. </p>
<h3>Details</h3>
<p>We choose a limit of 24 FD grid points because for DG-subcell the number of points in an element is <code>2 * number_dg_points - 1</code> for cell centered, and <code>2 * number_dg_points</code> for face-centered. Because there is no way of generically retrieving the maximum number of grid points for a non-FD basis, we need to hard-code both values here. If the number of grid points is increased for the non-FD bases, it should also be increased for the FD basis. Note that for good task-based parallelization 24 grid points is already a fairly large number. </p>

</div>
</div>
<a id="a7ed70608b007d26c6e7bf23ea14e8357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed70608b007d26c6e7bf23ea14e8357">&#9670;&nbsp;</a></span>minimum_number_of_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis basis, Quadrature quadrature&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t Spectral::minimum_number_of_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    detail::minimum_number_of_points(basis, quadrature)</div>
</div><!-- fragment -->
<p>Minimum number of possible collocation points for a quadrature type. </p>
<h3>Details</h3>
<p>Since Gauss-Lobatto quadrature has points on the domain boundaries it must have at least two collocation points. Gauss quadrature can have only one collocation point.</p>
<h3>Details</h3>
<p>For <code>CellCentered</code> the minimum number of points is 1, while for <code>FaceCentered</code> it is 2. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSpectral.html">Spectral</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
