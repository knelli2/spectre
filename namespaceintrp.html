<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.1"/>
  <title>SpECTRE: intrp Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.08.01</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceintrp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">intrp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains classes and functions for interpolation.  
<a href="namespaceintrp.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceintrp_1_1Actions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp_1_1Actions.html">Actions</a></td></tr>
<tr class="memdesc:namespaceintrp_1_1Actions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds <a class="el" href="namespaceintrp_1_1Actions.html" title="Holds Actions for Interpolator and InterpolationTarget.">Actions</a> for <a class="el" href="structintrp_1_1Interpolator.html" title="ParallelComponent responsible for collecting data from Elements and interpolating it onto Interpolati...">Interpolator</a> and <a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceintrp_1_1callbacks"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp_1_1callbacks.html">callbacks</a></td></tr>
<tr class="memdesc:namespaceintrp_1_1callbacks"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains callback functions called by <code><a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a></code>s. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceintrp_1_1protocols"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp_1_1protocols.html">protocols</a></td></tr>
<tr class="memdesc:namespaceintrp_1_1protocols"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all protocols used in the interpolation framework. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceintrp_1_1Tags"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp_1_1Tags.html">Tags</a></td></tr>
<tr class="memdesc:namespaceintrp_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceintrp_1_1Tags.html" title="Tags for items held in the DataBox of InterpolationTarget or Interpolator.">Tags</a> for items held in the <code>DataBox</code> of <code><a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a></code> or <code><a class="el" href="structintrp_1_1Interpolator.html" title="ParallelComponent responsible for collecting data from Elements and interpolating it onto Interpolati...">Interpolator</a></code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceintrp_1_1Vars"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp_1_1Vars.html">Vars</a></td></tr>
<tr class="memdesc:namespaceintrp_1_1Vars"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structures holding quantities that are interpolated by <code><a class="el" href="structintrp_1_1Interpolator.html" title="ParallelComponent responsible for collecting data from Elements and interpolating it onto Interpolati...">Interpolator</a></code> for use by <code><a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a></code>s. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1BarycentricRational.html">BarycentricRational</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A barycentric rational interpolation class.  <a href="classintrp_1_1BarycentricRational.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1BarycentricRationalSpanInterpolator.html">BarycentricRationalSpanInterpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a barycentric interpolation with an order in a range fixed at construction; this class can be chosen via the options factory mechanism as a possible <code><a class="el" href="classintrp_1_1SpanInterpolator.html" title="Base class for interpolators so that the factory options mechanism can be used.">SpanInterpolator</a></code>.  <a href="classintrp_1_1BarycentricRationalSpanInterpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1CubicSpanInterpolator.html">CubicSpanInterpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a cubic interpolation; this class can be chosen via the options factory mechanism as a possible <code><a class="el" href="classintrp_1_1SpanInterpolator.html" title="Base class for interpolators so that the factory options mechanism can be used.">SpanInterpolator</a></code>.  <a href="classintrp_1_1CubicSpanInterpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1CubicSpline.html">CubicSpline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A natural cubic spline interpolation class.  <a href="classintrp_1_1CubicSpline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1Irregular.html">Irregular</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates a <code>Variables</code> onto an arbitrary set of points.  <a href="classintrp_1_1Irregular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1LinearLeastSquares.html">LinearLeastSquares</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear least squares solver class.  <a href="classintrp_1_1LinearLeastSquares.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structintrp_1_1LinearRegressionResult.html">LinearRegressionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1LinearSpanInterpolator.html">LinearSpanInterpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a linear interpolation; this class can be chosen via the options factory mechanism as a possible <code><a class="el" href="classintrp_1_1SpanInterpolator.html" title="Base class for interpolators so that the factory options mechanism can be used.">SpanInterpolator</a></code>  <a href="classintrp_1_1LinearSpanInterpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1RegularGrid.html">RegularGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate data from a <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a> onto a regular grid of points.  <a href="classintrp_1_1RegularGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintrp_1_1SpanInterpolator.html">SpanInterpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for interpolators so that the factory options mechanism can be used.  <a href="classintrp_1_1SpanInterpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structintrp_1_1InterpolationTarget.html">InterpolationTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ParallelComponent representing a set of points to be interpolated to and a function to call upon interpolation to those points.  <a href="structintrp_1_1InterpolationTarget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structintrp_1_1Interpolator.html">Interpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ParallelComponent responsible for collecting data from <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s and interpolating it onto <code><a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a></code>s.  <a href="structintrp_1_1Interpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a170da17e169cf27db40c66ff20c6349b"><td class="memTemplParams" colspan="2"><a id="a170da17e169cf27db40c66ff20c6349b"></a>
template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a170da17e169cf27db40c66ff20c6349b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classintrp_1_1Irregular.html">Irregular</a>&lt; Dim &gt; &amp;lhs, const <a class="el" href="classintrp_1_1Irregular.html">Irregular</a>&lt; Dim &gt; &amp;rhs)</td></tr>
<tr class="separator:a170da17e169cf27db40c66ff20c6349b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09845b42e4ab196189f52146264d102"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa09845b42e4ab196189f52146264d102"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structintrp_1_1LinearRegressionResult.html">LinearRegressionResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NumericalAlgorithmsGroup.html#gaa09845b42e4ab196189f52146264d102">linear_regression</a> (const T &amp;x_values, const T &amp;y_values)</td></tr>
<tr class="memdesc:gaa09845b42e4ab196189f52146264d102"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear regression function.  <a href="group__NumericalAlgorithmsGroup.html#gaa09845b42e4ab196189f52146264d102">More...</a><br /></td></tr>
<tr class="separator:gaa09845b42e4ab196189f52146264d102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2b4743e6113288e9aeefa113db8e07"><td class="memTemplParams" colspan="2">template&lt;size_t Degree&gt; </td></tr>
<tr class="memitem:a5c2b4743e6113288e9aeefa113db8e07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceintrp.html#a5c2b4743e6113288e9aeefa113db8e07">polynomial_interpolation</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt; y, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt; error_in_y, double target_x, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;y_values, const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;x_values)</td></tr>
<tr class="memdesc:a5c2b4743e6113288e9aeefa113db8e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate <code>y_values</code> to <code>target_x</code> from tabulated <code>x_values</code> using a polynomial interpolant of degree <code>Degree</code>.  <a href="namespaceintrp.html#a5c2b4743e6113288e9aeefa113db8e07">More...</a><br /></td></tr>
<tr class="separator:a5c2b4743e6113288e9aeefa113db8e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b99de117dd868d0074e7fa68e2276c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp.html#ac8b99de117dd868d0074e7fa68e2276c">predicted_zero_crossing_value</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;x_values, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;y_values)</td></tr>
<tr class="memdesc:ac8b99de117dd868d0074e7fa68e2276c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts the zero crossing of a function.  <a href="namespaceintrp.html#ac8b99de117dd868d0074e7fa68e2276c">More...</a><br /></td></tr>
<tr class="separator:ac8b99de117dd868d0074e7fa68e2276c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9967aea8cc25282ab17d589de65305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceintrp.html#a5f9967aea8cc25282ab17d589de65305">predicted_zero_crossing_value</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; double &gt; &amp;x_values, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;y_values)</td></tr>
<tr class="memdesc:a5f9967aea8cc25282ab17d589de65305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts the zero crossing of multiple functions contained in a deque of DataVectors.  <a href="namespaceintrp.html#a5f9967aea8cc25282ab17d589de65305">More...</a><br /></td></tr>
<tr class="separator:a5f9967aea8cc25282ab17d589de65305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c233082887235e9c1ec6ea553e6492"><td class="memTemplParams" colspan="2"><a id="a70c233082887235e9c1ec6ea553e6492"></a>
template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a70c233082887235e9c1ec6ea553e6492"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classintrp_1_1RegularGrid.html">RegularGrid</a>&lt; Dim &gt; &amp;lhs, const <a class="el" href="classintrp_1_1RegularGrid.html">RegularGrid</a>&lt; Dim &gt; &amp;rhs)</td></tr>
<tr class="separator:a70c233082887235e9c1ec6ea553e6492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac0894403fb5f45ded3cafac7a1cfbc"><td class="memTemplParams" colspan="2"><a id="a9ac0894403fb5f45ded3cafac7a1cfbc"></a>
template&lt;typename InterpolationTargetTag , typename Metavariables , typename DbTags &gt; </td></tr>
<tr class="memitem:a9ac0894403fb5f45ded3cafac7a1cfbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceintrp.html#a9ac0894403fb5f45ded3cafac7a1cfbc">try_to_interpolate</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DbTags &gt; * &gt; box, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; * &gt; cache, const typename InterpolationTargetTag::temporal_id::type &amp;temporal_id)</td></tr>
<tr class="memdesc:a9ac0894403fb5f45ded3cafac7a1cfbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we have enough information to interpolate. If so, do the interpolation and send data to the <a class="el" href="structintrp_1_1InterpolationTarget.html" title="ParallelComponent representing a set of points to be interpolated to and a function to call upon inte...">InterpolationTarget</a>. <br /></td></tr>
<tr class="separator:a9ac0894403fb5f45ded3cafac7a1cfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12b217ce9a4208edc63e46a5330f8a3"><td class="memTemplParams" colspan="2"><a id="ad12b217ce9a4208edc63e46a5330f8a3"></a>
template&lt;typename InterpolationTargetTag , size_t VolumeDim, typename Metavariables , typename... InterpolatorSourceVars&gt; </td></tr>
<tr class="memitem:ad12b217ce9a4208edc63e46a5330f8a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interpolate</b> (const typename InterpolationTargetTag::temporal_id::type &amp;temporal_id, const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;mesh, <a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;cache, const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;array_index, const InterpolatorSourceVars &amp;... interpolator_source_vars_input)</td></tr>
<tr class="separator:ad12b217ce9a4208edc63e46a5330f8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains classes and functions for interpolation. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5c2b4743e6113288e9aeefa113db8e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2b4743e6113288e9aeefa113db8e07">&#9670;&nbsp;</a></span>polynomial_interpolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Degree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void intrp::polynomial_interpolation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; double * &gt;&#160;</td>
          <td class="paramname"><em>error_in_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1span.html">gsl::span</a>&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate <code>y_values</code> to <code>target_x</code> from tabulated <code>x_values</code> using a polynomial interpolant of degree <code>Degree</code>. </p>
<p><code>error_in_y</code> is an estimate of the error of the interpolated value. Note that at least in the tests this is a significant overestimate of the errors (several orders of magnitude). However, this could be because in the test the polynomial can be represented exactly when all terms are present, but incurs significant errors when the largest degree term is omitted. </p>

</div>
</div>
<a id="a5f9967aea8cc25282ab17d589de65305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9967aea8cc25282ab17d589de65305">&#9670;&nbsp;</a></span>predicted_zero_crossing_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataVector.html">DataVector</a> intrp::predicted_zero_crossing_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicts the zero crossing of multiple functions contained in a deque of DataVectors. </p>
<p>Fits a set of N linear functions, where N is the size of the returned <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> and the size of each <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> in the y_values. Each linear function is fit by M points, where M is the size of x_values and y_values. The Nth point in the returned <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> is the value of x for which the linear fit to the points (x[:], y[:][N]) [using python notation] crosses y = 0. The x_values contain M points in the independent variable, while the y_values contain M DataVectors that each contain (for example) the set of points on a <a class="el" href="classStrahlkorper.html" title="A star-shaped surface expanded in spherical harmonics.">Strahlkorper</a>. Each element of y_values is a <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> of size N. The first index to y_values selects a <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> of points corresponding to an x_value, and the second index selects a point in the <a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a>, so the y_values are indexed by [x_value_index][point_in_datavector]. The x_values and y_values must be of size M. Each fit determines the zero-crossing for one of the sets of points in the y_values. </p>

</div>
</div>
<a id="ac8b99de117dd868d0074e7fa68e2276c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b99de117dd868d0074e7fa68e2276c">&#9670;&nbsp;</a></span>predicted_zero_crossing_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double intrp::predicted_zero_crossing_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicts the zero crossing of a function. </p>
<p>Fits a linear function to a set of y_values at different x_values and uses the fit to predict what x_value the y_value zero will be crossed. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceintrp.html">intrp</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
